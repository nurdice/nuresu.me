<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <title>Nur | Mission Control</title>
    <link rel="icon" href="data:,">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Poppins', sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .video-story {
            position: fixed;
            top: 14%;
            left: 50%;
            transform: translateX(-50%);
            width: 86%;
            max-width: 980px;
            color: #feda4a;
            font-family: 'Arial Black', 'Franklin Gothic', sans-serif;
            font-size: 28px;
            line-height: 1.8;
            text-align: center;
            letter-spacing: 2px;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 28px rgba(254, 218, 74, 0.5);
        }

        .video-story.active {
            animation: videoStoryScroll 40s linear forwards;
            opacity: 1;
        }

        @keyframes videoStoryScroll {
            0% { transform: translate(-50%, 30%); opacity: 0; }
            5% { opacity: 1; }
            95% { opacity: 1; }
            100% { transform: translate(-50%, -140%); opacity: 0; }
        }

        .video-credits {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            flex-direction: column;
            padding: 0 40px;
            overflow: hidden;
            color: #feda4a;
            font-family: 'Arial Black', 'Franklin Gothic', sans-serif;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 28px rgba(254, 218, 74, 0.5);
        }

        .video-credits.active {
            animation: videoCreditsScroll 35s linear forwards;
            opacity: 1;
        }

        @keyframes videoCreditsScroll {
            0% { transform: translateY(100%); opacity: 0; }
            2% { opacity: 1; }
            98% { opacity: 1; }
            100% { transform: translateY(-100%); opacity: 0; }
        }

        #solar-loading-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.88);
            color: #dbeafe;
            font-family: 'Poppins', sans-serif;
            font-size: 18px;
            z-index: 6;
            letter-spacing: 0.5px;
        }

        #blackhole-overlay {
            position: fixed;
            inset: 0;
            background: #000;
            display: none;
            z-index: 8;
            pointer-events: none;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .label {
            position: absolute;
            color: rgba(255, 255, 255, 0.95);
            font-size: 16px;
            font-weight: 600;
            text-shadow: 0 0 8px rgba(0,0,0,0.8), 0 0 15px rgba(56, 189, 248, 0.4);
            pointer-events: auto;
            cursor: pointer;
            transition: opacity 0.3s, transform 0.3s;
            transform: translate(-50%, -50%);
            white-space: nowrap;
            background: transparent;
            padding: 4px 10px;
            border-radius: 12px;
            border: none;
            backdrop-filter: none;
            text-align: center;
        }

        body.labels-hidden .label {
            opacity: 0;
            pointer-events: none;
        }

        .label:hover {
            transform: translate(-50%, -50%) scale(1.1);
            text-shadow: 0 0 12px rgba(0,0,0,0.9), 0 0 25px rgba(56, 189, 248, 0.7);
        }

        .label.major {
            font-size: 22px;
            letter-spacing: 1px;
            text-transform: uppercase;
            background: transparent;
            border: none;
            backdrop-filter: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.8), 0 0 20px rgba(56, 189, 248, 0.5);
            color: #ffffff;
        }

        #overlay-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 400px;
            height: 100%;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            transform: translateX(100%);
            transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
            padding: 40px 40px 100px 40px;
            box-sizing: border-box;
            border-left: 1px solid rgba(255,255,255,0.1);
            color: #e2e8f0;
            overflow-y: auto;
            pointer-events: auto;
        }

        #overlay-panel.active {
            transform: translateX(0);
        }

        #overlay-panel h2 {
            font-size: 36px;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #38bdf8, #818cf8);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #overlay-panel h3 {
            color: #94a3b8;
            font-size: 18px;
            margin-bottom: 30px;
            font-weight: 400;
        }

        .content-block {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
        }

        .close-btn:hover { opacity: 1; }

        #controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: auto;
            z-index: 20;
            flex-wrap: wrap;
        }

        .hud-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            font-family: 'Poppins', sans-serif;
            font-size: 16px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hud-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.3);
        }

        .hud-btn:disabled,
        #solar-loading-overlay:not([style*="display: none"]) ~ #controls .hud-btn,
        #solar-loading-overlay:not([style*="display: none"]) ~ .hud-btn,
        body.loading .hud-btn {
            display: none;
            pointer-events: none;
        }

        #nur-wars-btn:hover {
            background: url('assets/images/nurwars.png') no-repeat center/contain !important;
            background-color: transparent !important;
            transform: scale(1.1) translateY(-2px) !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4) !important;
        }

        #loading {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #38bdf8;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 768px) {
            #overlay-panel { width: 100%; }
            .hud-btn { padding: 8px 16px; font-size: 12px; }
            #sky-details {
                top: 3%;
                height: 70%; /* Reduced height on mobile to avoid button overlap */
                width: 96%;
            }
            #sky-content {
                padding: 15px; /* Reduced padding on mobile */
                font-size: 12px; /* Smaller font on mobile */
                line-height: 1.4;
            }
        }

        #sky-details {
            position: fixed;
            top: 3%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #fff;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            pointer-events: auto;
            z-index: 25; /* Increased from 15 to be above controls */
            display: none;
            width: 94%;
            max-width: 1100px; /* Slightly smaller to avoid button overlap */
            height: 75%; /* Reduced height to avoid button overlap */
            animation: fadeIn 1s ease-out;
        }
        #sky-details h1 {
            font-size: 52px;
            margin-bottom: 20px;
            color: #38bdf8;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        #sky-content {
            font-size: 14px; /* Reduced font size to fit more content */
            line-height: 1.5; /* Tighter line height */
            background: rgba(15, 23, 42, 0.95);
            padding: 20px; /* Reduced padding */
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto;
            height: calc(100% - 100px); /* Adjusted height */
            overflow-y: hidden; /* Disable scrolling */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            padding-bottom: 20px; /* Minimal bottom padding */
        }
        #sky-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.3s;
            pointer-events: auto;
            z-index: 2;
        }
        #sky-close:hover { background: rgba(255, 255, 255, 0.3); }
        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -20px); } to { opacity: 1; transform: translate(-50%, 0); } }
        @keyframes simpleFadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slowSpin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes pulseGlow { 0% { box-shadow: 0 0 10px rgba(56, 189, 248, 0.5); } 50% { box-shadow: 0 0 25px rgba(56, 189, 248, 0.9); } 100% { box-shadow: 0 0 10px rgba(56, 189, 248, 0.5); } }
        @keyframes charBounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        @keyframes charHover { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
        @keyframes char3D { 
            0% { transform: perspective(600px) rotateY(0deg) rotateX(0deg) scale(1); } 
            25% { transform: perspective(600px) rotateY(90deg) rotateX(10deg) scale(1.1); } 
            50% { transform: perspective(600px) rotateY(180deg) rotateX(0deg) scale(1.2) translateY(-10px); } 
            75% { transform: perspective(600px) rotateY(270deg) rotateX(-10deg) scale(1.1); } 
            100% { transform: perspective(600px) rotateY(360deg) rotateX(0deg) scale(1); } 
        }
        @keyframes expertGlow { 
            0% { transform: perspective(600px) rotateY(0deg) scale(1); filter: drop-shadow(0 0 10px rgba(56, 189, 248, 0.5)); } 
            50% { transform: perspective(600px) rotateY(180deg) scale(1.15); filter: drop-shadow(0 0 25px rgba(56, 189, 248, 0.8)); } 
            100% { transform: perspective(600px) rotateY(360deg) scale(1); filter: drop-shadow(0 0 10px rgba(56, 189, 248, 0.5)); } 
        }
        @keyframes professionalFloat { 
            0%, 100% { transform: perspective(400px) rotateY(0deg) translateY(0px); } 
            33% { transform: perspective(400px) rotateY(120deg) translateY(-5px); } 
            66% { transform: perspective(400px) rotateY(240deg) translateY(-3px); } 
        }
        @keyframes beginnerWobble { 
            0%, 100% { transform: rotate(0deg) scale(1); } 
            25% { transform: rotate(-5deg) scale(0.95); } 
            75% { transform: rotate(5deg) scale(1.05); } 
        }

        /* 3D Hero Face Animations */
        @keyframes einsteinThink {
            0%, 100% { transform: perspective(800px) rotateY(0deg) rotateX(0deg) scale(1); }
            25% { transform: perspective(800px) rotateY(15deg) rotateX(-5deg) scale(1.05); }
            50% { transform: perspective(800px) rotateY(0deg) rotateX(5deg) scale(1.1); }
            75% { transform: perspective(800px) rotateY(-15deg) rotateX(-5deg) scale(1.05); }
        }

        @keyframes newtonApple {
            0%, 100% { transform: perspective(800px) rotateY(0deg) translateY(0px) scale(1); }
            25% { transform: perspective(800px) rotateY(90deg) translateY(-3px) scale(1.02); }
            50% { transform: perspective(800px) rotateY(180deg) translateY(-5px) scale(1.05); }
            75% { transform: perspective(800px) rotateY(270deg) translateY(-3px) scale(1.02); }
        }

        @keyframes gandhiPeace {
            0%, 100% { transform: perspective(800px) rotateX(0deg) rotateY(0deg) scale(1); }
            33% { transform: perspective(800px) rotateX(10deg) rotateY(120deg) scale(1.03); }
            66% { transform: perspective(800px) rotateX(-10deg) rotateY(240deg) scale(1.03); }
        }

        @keyframes buddhaSerenity {
            0%, 100% { transform: perspective(800px) rotateY(0deg) scale(1) translateZ(0px); }
            25% { transform: perspective(800px) rotateY(90deg) scale(1.08) translateZ(10px); }
            50% { transform: perspective(800px) rotateY(180deg) scale(1.15) translateZ(20px); }
            75% { transform: perspective(800px) rotateY(270deg) scale(1.08) translateZ(10px); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        /* NUR WARS Crawl Animation - Fixed */
        @keyframes crawl {
            0% {
                top: 100vh;
                opacity: 1;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                top: -150vh;
                opacity: 0;
            }
        }

        .crawl-text-animated {
            position: absolute;
            left: 50%;
            transform: translateX(-50%) rotateX(25deg);
            transform-origin: 50% 100%;
            width: 80%;
            max-width: 800px;
            color: #FFFFFF;
            font-family: 'Orbitron', serif;
            font-size: 32px;
            line-height: 1.8;
            text-align: justify;
            animation: crawl 60s linear forwards;
        }

        @keyframes crawlFadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes panZoomToBattle {
            0% { 
                transform: scale(1) translateZ(0px);
                opacity: 1;
            }
            50% {
                transform: scale(1.8) translateZ(150px);
                opacity: 0.5;
            }
            100% { 
                transform: scale(3) translateZ(300px);
                opacity: 0;
            }
        }

        /* Hide controls during NUR WARS */
        .nur-wars-active #controls {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-out;
        }

        /* Audio controls - hidden by default, shown on hover or during NUR WARS */
        #audio-controls {
            display: none !important;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .nur-wars-active #audio-controls {
            display: flex !important;
            opacity: 0;
            pointer-events: auto;
        }

        .nur-wars-active #audio-controls:hover {
            opacity: 1 !important;
        }

        @keyframes slideInAudio {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Language Card Glow Effect */
        @keyframes languageCardGlow {
            0% { box-shadow: 0 0 5px rgba(56, 189, 248, 0.3), 0 0 10px rgba(56, 189, 248, 0.2), 0 0 15px rgba(56, 189, 248, 0.1); }
            50% { box-shadow: 0 0 20px rgba(56, 189, 248, 0.6), 0 0 30px rgba(56, 189, 248, 0.4), 0 0 40px rgba(56, 189, 248, 0.2); }
            100% { box-shadow: 0 0 5px rgba(56, 189, 248, 0.3), 0 0 10px rgba(56, 189, 248, 0.2), 0 0 15px rgba(56, 189, 248, 0.1); }
        }

        /* Custom scrollbar for language modal */
        .language-grid::-webkit-scrollbar {
            width: 4px;
        }
        .language-grid::-webkit-scrollbar-track {
            background: rgba(56, 189, 248, 0.1);
            border-radius: 2px;
        }
        .language-grid::-webkit-scrollbar-thumb {
            background: rgba(56, 189, 248, 0.4);
            border-radius: 2px;
        }
        .language-grid::-webkit-scrollbar-thumb:hover {
            background: rgba(56, 189, 248, 0.6);
        }

        /* Mobile View Styles */
        #mobile-view {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #05050c;
            color: #f0f0ff;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
            overflow-y: auto;
            z-index: 2000; /* Above loading screen initially */
        }
        .mobile-header { text-align: center; margin-bottom: 30px; border-bottom: 1px solid #1e293b; padding-bottom: 20px; }
        .mobile-header h1 { color: #38bdf8; font-size: 24px; margin: 0 0 10px 0; }
        .mobile-header h2 { font-size: 16px; color: #94a3b8; margin: 0 0 15px 0; }
        .mobile-contact { 
            font-size: 14px; 
            color: #94a3b8; 
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .mobile-contact a { color: #38bdf8; text-decoration: none; }
        .contact-separator { display: inline; opacity: 0.4; }
        .contact-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            align-items: center;
        }
        .mobile-buttons { 
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex; 
            flex-direction: row; 
            gap: 15px; 
            justify-content: center; 
            padding: 0 20px;
            background: transparent;
            border: none;
            box-sizing: border-box;
            z-index: 2001;
            pointer-events: none;
        }
        .mobile-buttons button {
            flex: 1;
            max-width: 250px;
            padding: 14px;
            border-radius: 30px;
            color: white;
            font-family: inherit;
            font-weight: bold;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
            transition: transform 0.2s;
        }
        .mobile-buttons button:active { transform: scale(0.96); }
        #mobile-view section { margin-bottom: 30px; }
        #mobile-view h3 {
            border-bottom: 1px solid #1e293b;
            padding-bottom: 5px;
            margin-bottom: 15px;
            font-size: 20px;
            letter-spacing: 1px;
        }
        .job-block, .project-block, .edu-block, .skill-block { margin-bottom: 20px; }
        #mobile-view h4 { margin: 0 0 5px 0; font-size: 18px; }
        .job-meta { font-size: 14px; margin-bottom: 10px; font-style: italic; }
        #mobile-view ul { margin: 0; padding-left: 20px; }
        #mobile-view li { margin-bottom: 8px; font-size: 16px; line-height: 1.6; }
        #mobile-view p { font-size: 16px; line-height: 1.6; margin: 0 0 15px 0; }

        /* Desktop Fallback Layout */
        .resume-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 80px 20px 120px 20px;
            animation: simpleFadeIn 0.8s ease-out;
        }
        .resume-grid {
            display: flex;
            flex-direction: column;
            gap: 40px;
        }
        
        @media (min-width: 900px) {
            .resume-container {
                padding: 40px 40px 120px 40px;
            }
            .resume-grid {
                display: grid;
                grid-template-columns: 320px 1fr;
                gap: 40px;
                align-items: start;
            }
            .resume-sidebar {
                border-right: 1px solid var(--border-color);
                padding-right: 30px;
                order: 0;
            }
            .resume-main {
                order: 0;
            }
            if (battlePhase === 'approach') {
                display: grid;
                grid-template-columns: 320px 1fr;
                gap: 40px;
                align-items: center;
                text-align: left !important;
            }
            .header-image-container {
                text-align: right;
                padding-right: 30px;
            }
            .mobile-contact {
                if (deathStar) {
                    const lookTarget = focusPos.clone().lerp(deathStar.object.position, 0.35);
                    battleCameraDesiredLook.copy(lookTarget);
                } else {
                    battleCameraDesiredLook.copy(focusPos);
                }
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .contact-group { display: contents; }
        }
        
        #back-to-top {
                if (deathStar) {
                    const lookTarget = focus.clone().lerp(deathStar.object.position, 0.4);
                    battleCameraDesiredLook.copy(lookTarget);
                } else {
                    battleCameraDesiredLook.copy(focus);
                }
            bottom: 90px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 2002;
            backdrop-filter: blur(5px);
            font-size: 18px;
            transition: transform 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
                if (deathStar) {
                    const lookTarget = focus.clone().lerp(deathStar.object.position, 0.5);
                    battleCameraDesiredLook.copy(lookTarget);
                } else {
                    battleCameraDesiredLook.copy(focus);
                }

        @media (max-width: 899px) {
            .resume-sidebar {
                order: 2;
                margin-top: 40px;
                        60 + camWobble,
                        320 + Math.sin(camOrbit) * 60
                order: 1;
            }
                    battleCameraDesiredLook.copy(deathStar.exhaustPort ? deathStar.exhaustPort.position : deathStar.object.position);

        @media print {
            .mobile-buttons, #controls, .hud-btn, #sky-details, #ui-layer, #loading, .mobile-header button {
                display: none !important;
            }
            #mobile-view {
                        80 + camWobble,
                        280 + Math.sin(camOrbit) * 80
                overflow: visible;
                background: white !important;
                color: black !important;
            }
            .resume-container {
                width: 100%;
                max-width: none;
                    const pullback = Math.min(Math.max((t - 280) / 20, 0), 1);
                padding: 0;
                        Math.cos(camOrbit) * (700 + pullback * 600),
                        420 + camWobble + pullback * 200,
                        900 + Math.sin(camOrbit) * 220 + pullback * 600
                background: white !important;
                overflow: visible;
            }
        }
    </style>
</head>
<body class="labels-hidden">

    <div id="loading" style="display:none;"><div class="loader"></div></div>
    <div id="mobile-view"></div>
    <div id="canvas-container" style="display:none;"></div>
    <div id="solar-loading-overlay" style="display:flex;">
        <div style="font-weight:600; margin-bottom:6px;">Loading solar system‚Ä¶</div>
        <div id="solar-loading-progress" style="opacity:0.8; font-size:14px;">0%</div>
    </div>
    <div id="blackhole-overlay"></div>
    <div id="ui-layer" style="display:none;"></div>
    <div id="sky-details">
        <div id="sky-close" onclick="closeSkyModal()">‚úï</div>
        <h1 id="sky-title">Moon Title</h1>
        <div id="sky-content">Details go here...</div>
    </div>

    <div id="pdf-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:100; justify-content:center; align-items:center;">
        <div style="background:rgba(15, 23, 42, 0.95); padding:40px; border-radius:20px; border:1px solid rgba(255,255,255,0.1); text-align:center; backdrop-filter:blur(10px); max-width: 400px; width: 90%;">
            <h2 style="color:#38bdf8; margin-top:0;">Download Resume</h2>
            <p style="color:#cbd5e1; margin-bottom:30px;">Choose a style for your PDF resume:</p>
            
            <div style="display:flex; gap:20px; justify-content:center; flex-wrap:wrap;">
                <button onclick="generatePDF('professional')" style="
                    background: #e2e8f0; color: #0f172a; border:none; padding:12px 24px; border-radius:8px; 
                    cursor:pointer; font-weight:600; font-family:'Poppins',sans-serif; transition:transform 0.2s;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    Professional
                </button>
                
                <button onclick="generatePDF('space')" style="
                    background: linear-gradient(135deg, #38bdf8, #818cf8); color: white; border:none; padding:12px 24px; border-radius:8px; 
                    cursor:pointer; font-weight:600; font-family:'Poppins',sans-serif; transition:transform 0.2s;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    Space Theme
                </button>
            </div>
            
            <button onclick="document.getElementById('pdf-modal').style.display='none'" style="margin-top:30px; background:transparent; border:1px solid rgba(255,255,255,0.3); color:rgba(255,255,255,0.7); padding:8px 16px; border-radius:20px; cursor:pointer;">
                Cancel
            </button>
        </div>
    </div>

    <div id="overlay-panel">
        <button class="close-btn" onclick="closeOverlay()">√ó</button>
        <h2 id="panel-title">Title</h2>
        <h3 id="panel-subtitle">Subtitle</h3>
        <div id="panel-content"></div>
    </div>

    <div id="controls">
        <button class="hud-btn" onclick="event.stopPropagation(); resetView()">‚äô Reset View</button>
        <button class="hud-btn" onclick="toggleSound()" id="sound-btn">üîá Sound Off</button>
        <button class="hud-btn" onclick="toggleOrbits()" id="orbits-btn">ü™ê Show Orbits</button>
        <button class="hud-btn" onclick="goToPreviousView()" id="back-btn" style="display: none;">‚Üê Back</button>
        <button class="hud-btn" onclick="startNurWars()" id="nur-wars-btn" aria-label="Nur Wars" style="background: url('assets/images/nurwars.png') no-repeat center/contain; background-color: transparent; border: none; width: 120px; height: 60px; padding: 0; min-width: auto; box-shadow: none; backdrop-filter: none;"></button>
        <button class="hud-btn" onclick="document.getElementById('pdf-modal').style.display='flex'">üìÑ PDF Resume</button>
    </div>

    <!-- Movie Controls (NUR WARS only) -->
    <div id="audio-controls" style="position: fixed; top: 30px; right: 30px; display: flex; gap: 10px; z-index: 1002; flex-wrap: nowrap; align-items: center;">
        <button class="hud-btn" onclick="toggleSound()" id="nur-wars-sound-btn" aria-label="Toggle sound" style="padding: 10px 16px; font-size: 14px;">üîä</button>
        <button class="hud-btn" onclick="skipMovie(-5)" id="movie-back-btn" aria-label="Back 5 seconds" style="padding: 10px 16px; font-size: 14px;">‚è™ -5s</button>
        <button class="hud-btn" onclick="toggleMoviePlayPause()" id="movie-play-btn" aria-label="Play or pause movie" style="padding: 10px 16px; font-size: 14px;">‚è∏Ô∏è Pause</button>
        <button class="hud-btn" onclick="skipMovie(5)" id="movie-forward-btn" aria-label="Forward 5 seconds" style="padding: 10px 16px; font-size: 14px;">‚è© +5s</button>
    </div>

    <!-- NUR WARS Experience -->
    <div id="nur-wars-container" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: transparent; z-index: 1000; overflow: hidden; pointer-events: none;">
        <!-- Opening Crawl -->
        <div id="opening-crawl" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; perspective: 1200px; overflow: hidden; background: transparent; -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0.2) 8%, rgba(0,0,0,1) 20%, rgba(0,0,0,1) 100%); mask-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0.2) 8%, rgba(0,0,0,1) 20%, rgba(0,0,0,1) 100%); pointer-events: none;">
            <!-- Opening text - fixed position, not affected by scroll -->
            <p id="opening-text" style="font-size: 20px; text-align: center; opacity: 0.9; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; width: 90%; max-width: 800px; z-index: 1001; color: #0099FF; font-family: 'Arial Black', 'Franklin Gothic', sans-serif; letter-spacing: 2px; line-height: 1.4; font-weight: bold; text-transform: uppercase;">A long time ago in a galaxy far, far away....</p>
            
            <!-- Nur Wars image - fixed position overlay, animated separately -->
            <div id="nurwars-image-container" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; z-index: 999; width: 90%; max-width: 600px;">
                <img src="assets/images/nurwars opening.png" alt="NUR WARS" style="width: 100%; height: auto;">
            </div>
            
            <div id="crawl-text" style="position: absolute; top: 100vh; left: 50%; transform: translateX(-50%) rotateX(0deg) scale(1); transform-origin: 50% bottom; width: 98%; max-width: 1200px; color: #feda4a; font-family: 'Arial Black', 'Franklin Gothic', sans-serif; font-size: 36px; line-height: 1.8; text-align: center; letter-spacing: 2px; font-weight: bold;">
                
                <div style="height: 50vh;"></div>
                
                <p style="margin: 0 0 30px 0;">It is a period of digital transformation. Rebel analysts, striking from hidden offices, have won their first victory against the evil Legacy Systems Empire.</p>
                
                <p style="margin: 0 0 30px 0;">During the battle, rebel spies managed to steal secret plans to the Empire's ultimate weapon, the MONOLITHIC ARCHITECTURE‚Äîa legacy system with enough power to destroy an entire business process.</p>
                
                <p style="margin: 0 0 30px 0;">In this epic tale, young NUR DAWOODANI emerges as the chosen Business Analyst, wielding 18+ years of experience across retail and banking galaxies. From the corporate towers of LULULEMON to the financial fortresses of HSBC, he has brought balance to the Force of digital transformation.</p>
                
                <p style="margin: 0 0 30px 0;">His legendary achievements include architecting the Great Revamp that saved the Retail Galaxy from scalability collapse, wielding AI-driven Product Highlights to generate multi-million credit revenues, and leading the Paperless Rebellion that eliminated 2+ million sheets annually.</p>
                
                <p style="margin: 0 0 30px 0;">Now, as the Empire of Technical Debt threatens to engulf all business processes, the galaxy's only hope lies with this Business Analysis Jedi Master...</p>
                
                <p style="margin: 0 0 30px 0;">Will Nur's mastery of SAFe, stakeholder management, and epic decomposition be enough to restore order to the chaotic universe of enterprise software?</p>
                
                <p style="margin: 0;">The fate of digital transformation rests in his capable hands...</p>
            </div>
        </div>
        
        <!-- Battle Scene -->
        <div id="battle-scene" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
            <canvas id="battle-canvas" style="width: 100%; height: 100%;"></canvas>
            <div id="battle-video-layer" style="position: absolute; inset: 0; display: none; background: #000; pointer-events: auto;">
                <video id="battle-video" style="width: 100%; height: 100%; object-fit: cover; display: block;" playsinline preload="metadata"></video>
                <div id="battle-video-transition" style="position: absolute; inset: 0; background: #000; opacity: 0; transition: opacity 0.6s ease; pointer-events: none;"></div>
                <div id="battle-video-overlay" style="position: fixed; bottom: 56px; left: 50%; transform: translateX(-50%); text-align: center; color: #feda4a; font-family: 'Arial Black', 'Franklin Gothic', sans-serif; text-shadow: 0 0 20px rgba(254,218,74,0.6); pointer-events: none;">
                    <div id="battle-video-title" style="font-size: 32px; margin-bottom: 10px; font-weight: bold; letter-spacing: 2px;">REBEL ALLIANCE MISSION</div>
                    <div id="battle-video-subtitle" style="font-size: 20px; letter-spacing: 1px;">Destroy the Legacy System Death Star</div>
                    <div id="battle-video-tagline" style="font-size: 16px; margin-top: 8px; opacity: 0.85; font-style: italic;">Use the Force of Business Analysis, Nur...</div>
                </div>
                <div id="battle-video-story" class="video-story"></div>
                <div id="battle-video-credits" class="video-credits"></div>
                <div id="battle-video-progress" style="position: fixed; top: 90px; left: 30px; right: 30px; display: flex; gap: 12px; align-items: center; opacity: 1; transition: opacity 0.3s ease; z-index: 1002;">
                    <input id="video-scrubber" type="range" min="0" max="100" value="0" step="0.1" style="flex: 1; accent-color: #feda4a;" aria-label="Video progress">
                    <div id="video-time" style="min-width: 86px; color: #feda4a; font-family: 'Arial Black', 'Franklin Gothic', sans-serif; font-size: 14px; font-weight: bold; letter-spacing: 1px;">0:00 / 0:00</div>
                </div>
                <div id="battle-video-controls" style="position: fixed; top: 30px; right: 30px; display: flex; gap: 10px; align-items: center; opacity: 0; transition: opacity 0.3s ease; z-index: 1002;">
                    <button id="video-back-btn" class="hud-btn" aria-label="Back 5 seconds" style="padding: 10px 16px; font-size: 14px;">‚è™ -5s</button>
                    <button id="video-play-btn" class="hud-btn" aria-label="Play or pause" style="padding: 10px 16px; font-size: 14px;">‚è∏Ô∏è Pause</button>
                    <button id="video-forward-btn" class="hud-btn" aria-label="Forward 5 seconds" style="padding: 10px 16px; font-size: 14px;">‚è© +5s</button>
                    <button id="video-mute-btn" class="hud-btn" aria-label="Toggle sound" style="padding: 10px 16px; font-size: 14px;">üîä</button>
                </div>
            </div>
            <div id="battle-hud" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #FFD700; font-family: 'Orbitron', serif; text-align: center;">
                <div style="font-size: 24px; margin-bottom: 10px;">REBEL ALLIANCE MISSION</div>
                <div style="font-size: 18px;">Destroy the Legacy System Death Star</div>
                <div style="font-size: 14px; margin-top: 10px; opacity: 0.8;">Use the Force of Business Analysis, Nur...</div>
            </div>
        </div>
        
        <!-- Close Button -->
        <button id="exit-hyperspace-btn" class="hud-btn" style="position: fixed; top: 20px; left: 20px; background: rgba(255,100,100,0.3); border: 2px solid #FF6464; color: #FF6464; padding: 12px 20px; border-radius: 30px; font-family: 'Poppins', sans-serif; font-size: 16px; text-transform: uppercase; letter-spacing: 1px; cursor: pointer; z-index: 1003; display: none; font-weight: 600; pointer-events: auto;">
            ‚èπ EXIT HYPERSPACE
        </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="resume_data.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const RESUME_DATA = window.RESUME_DATA;
        const { jsPDF } = window.jspdf;
        
        // Initialize GLTF Loader for 3D models (supports KHR_materials_pbrSpecularGlossiness natively)
        const gltfLoader = new GLTFLoader();

        // Check if RESUME_DATA is loaded properly
        if (!RESUME_DATA) {
            console.error('RESUME_DATA not loaded properly');
            startFallbackMode('Resume data failed to load. Please refresh the page.');
            throw new Error('RESUME_DATA not available');
        }

        if (!RESUME_DATA.name) {
            console.error('RESUME_DATA.name is undefined');
            startFallbackMode('Resume data is incomplete. Please refresh the page.');
            throw new Error('RESUME_DATA.name not available');
        }


        // === STATE VARIABLES (MUST BE DECLARED FIRST) ===
        const objects = [];
        const clickableObjects = [];
        const labels = [];
        let revealLabelsOnNextFrame = false;
        const orbitPaths = [];
        const moonOrbitPaths = []; // Separate array for moon orbits
        let activeSuctionAnimations = {};
        let stopSuctionAnimation = false; // Flag to stop animation updates // Store animation tweens for cleanup
        let focusedObject = null;
        let isCenterView = false;
        let previousCameraPos = new THREE.Vector3();
        let previousTarget = new THREE.Vector3();
        let timelineActive = false;
        let soundEnabled = false;
        let backgroundAudio = null;
        let orbitsVisible = false;
        const comets = [];
        const cometParticles = [];
        const lasers = [];
        let falconModel = null;
        let falconModelPromise = null;
        let tieFighterModel = null;
        let tieFighterModelPromise = null;
        
        // View history system variables (functions defined after camera creation)
        const viewHistory = [];
        let currentViewIndex = -1;
        
        // Background dimming system
        let backgroundDimming = false;
        const backgroundObjects = []; // Will store all planets/moons for dimming
        
        // Tour mode system
        let tourMode = false;
        let tourIndex = 0;
        let tourSequence = [];
        let tourTimer = null;
        const TOUR_DURATION = 4000; // 4 seconds per stop
        
        // Gravitational visualization system
        let gravityMode = false;
        const gravityLines = [];
        const gravityParticles = [];
        let gravityAnimationFrame = 0;
        let renderMode = 'default'; // 'default' or 'battle'

        // === SETUP THREE.JS (BEFORE ANYTHING ELSE) ===
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        
        function startFallbackMode(errorMessage = null) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('canvas-container').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            
            const container = document.getElementById('mobile-view');
            container.style.display = 'block';
            
            container.addEventListener('scroll', () => {
                const btn = document.getElementById('back-to-top');
                if (btn) {
                    btn.style.display = container.scrollTop > 300 ? 'flex' : 'none';
                }
            });

            window.renderMobileView = (theme) => {
                const isSpace = theme === 'space';
                
                const linkColor = isSpace ? '#38bdf8' : '#2563eb';
                const borderColor = isSpace ? '#1e293b' : '#e2e8f0';
                const headerColor = isSpace ? '#38bdf8' : '#0f172a';
                const subHeaderColor = isSpace ? '#94a3b8' : '#64748b';
                const sectionTitleColor = isSpace ? '#38bdf8' : '#0f172a';
                const itemTitleColor = isSpace ? '#e2e8f0' : '#334155';

                // Theme Styles
                container.style.backgroundColor = isSpace ? '#05050c' : '#ffffff';
                container.style.color = isSpace ? '#f0f0ff' : '#1e293b';
                container.style.fontFamily = isSpace ? "'Courier New', Courier, monospace" : "'Poppins', sans-serif";
                container.style.setProperty('--border-color', borderColor);
                
                // Background effect for space
                if (isSpace) {
                    container.style.backgroundImage = "radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 3px), radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 2px), radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 3px)";
                    container.style.backgroundSize = "550px 550px, 350px 350px, 250px 250px";
                    container.style.backgroundPosition = "0 0, 40px 60px, 130px 270px";
                } else {
                    container.style.backgroundImage = "none";
                }

                const summaryTitle = isSpace ? "MISSION OBJECTIVE & PROFILE" : "SUMMARY";

                const profileImg = isSpace ? (RESUME_DATA.profileImageDark || RESUME_DATA.profileImage) : (RESUME_DATA.profileImageLight || RESUME_DATA.profileImage);

                let html = `
                    ${errorMessage ? `<div style="position: sticky; top: 0; z-index: 3000; background: rgba(220, 38, 38, 0.4); color: white; padding: 8px 10px; text-align: center; font-family: sans-serif; font-size: 11px; margin: 0; border-bottom: 1px solid rgba(255, 100, 100, 0.3); backdrop-filter: blur(12px); line-height: 1.3;">
                        <strong style="display:block; font-size:13px; margin-bottom:2px;">‚ö†Ô∏è 3D View Unavailable</strong>
                        ${errorMessage}
                    </div>` : ''}

                    <div class="resume-container" style="padding-top: ${errorMessage ? '140px' : '80px'}">
                    
                    <!-- Header -->
                    <div class="mobile-header" style="border-bottom: 1px solid ${borderColor}">
                        <div class="header-image-container">
                            <img src="${profileImg}" style="width: 160px; height: 160px; border-radius: 50%; border: 4px solid ${borderColor}; object-fit: cover;">
                        </div>
                        <div class="header-content">
                            <h1 style="color:${headerColor}; font-size: 32px; margin: 0 0 20px 0; line-height: 1.2;">${RESUME_DATA.name.toUpperCase()}</h1>
                            <h2 style="color:${subHeaderColor}; font-size: 20px; margin: 0 0 20px 0;">${RESUME_DATA.role}</h2>
                            <div class="mobile-contact" style="color:${subHeaderColor}">
                                <div class="contact-group">
                                    <span>üìß ${RESUME_DATA.contact.email}</span>
                                    <span class="contact-separator">|</span>
                                    <span>üì± ${RESUME_DATA.contact.phone}</span>
                                </div>
                                <div class="contact-group">
                                    <span>üìç ${RESUME_DATA.contact.location}</span>
                                    <span class="contact-separator">|</span>
                                    <span>üîó <a href="https://${RESUME_DATA.contact.linkedin}" target="_blank" style="color:${linkColor}">LinkedIn</a></span>
                                    <span class="contact-separator">|</span>
                                    <span>üåê <a href="https://${RESUME_DATA.contact.website}" target="_blank" style="color:${linkColor}">Website</a></span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="resume-grid">
                        <!-- Sidebar (Skills, Education) -->
                        <div class="resume-sidebar">
                `;

                // --- DYNAMIC RENDERER ---
                const renderPlanet = (planet) => {
                    const sectionTitle = isSpace ? (planet.spaceTitle || planet.title || planet.name) : (planet.title || planet.name);
                    let html = `<section><h3 style="color:${sectionTitleColor}; border-bottom: 1px solid ${borderColor}">${sectionTitle.toUpperCase()}</h3>`;
                    
                    if (planet.renderType === 'experience') {
                        planet.moons.forEach(moon => {
                            const d = isSpace ? (moon.spaceDetails || moon.pdfDetails || {}) : (moon.pdfDetails || moon.moonDetails || {});
                            html += `<div class="job-block">
                                <h4 style="color:${itemTitleColor}">${d.company || moon.name}</h4>
                                <div class="job-meta" style="color:${subHeaderColor}">${d.role} | ${d.duration}</div>
                                <ul>${(d.achievements || []).map(a => `<li>${a}</li>`).join('')}</ul>
                            </div>`;
                        });
                    } 
                    else if (planet.renderType === 'projects') {
                        planet.moons.forEach(moon => {
                            const d = isSpace ? (moon.spaceDetails || moon.pdfDetails || {}) : (moon.pdfDetails || moon.moonDetails || {});
                            html += `<div class="project-block">
                                <h4 style="color:${itemTitleColor}">${d.title || moon.name}</h4>
                                <p>${d.description || ''}</p>
                                ${d.impact ? `<p><strong>Impact:</strong> ${d.impact.join('. ')}</p>` : ''}
                            </div>`;
                        });
                    }
                    else if (planet.renderType === 'list' || planet.renderType === 'skills') {
                        planet.moons.forEach(moon => {
                            const d = isSpace ? (moon.spaceDetails || moon.pdfDetails || {}) : (moon.pdfDetails || moon.moonDetails || {});
                            const list = d.skills || d.tools || d.outcomes || d.items || [];
                            html += `<div class="skill-block">
                                <h4 style="color:${itemTitleColor}">${d.title || moon.name}</h4>
                                ${list.length ? `<p>${list.join(', ')}</p>` : ''}
                            </div>`;
                        });
                    }
                    else if (planet.renderType === 'text-list') {
                        planet.moons.forEach(moon => {
                            const d = isSpace ? (moon.spaceDetails || moon.pdfDetails || {}) : (moon.pdfDetails || moon.moonDetails || {});
                            const list = d.problems || d.practices || d.stages || d.stakeholders || d.approaches || [];
                            html += `<div class="project-block">
                                <h4 style="color:${itemTitleColor}">${d.title || moon.name}</h4>
                                ${d.description ? `<p>${d.description}</p>` : ''}
                                ${list.length ? `<ul>${list.map(i => `<li>${i}</li>`).join('')}</ul>` : ''}
                            </div>`;
                        });
                    }
                    else if (planet.renderType === 'education') {
                        const pd = isSpace ? (planet.spaceDetails || planet.pdfDetails || {}) : (planet.pdfDetails || {});
                        if (pd.degree) {
                            html += `<div class="edu-block">
                                <h4 style="color:${itemTitleColor}">${pd.degree}</h4>
                                <p>${pd.institution}<br>${pd.university}<br><span style="font-size:0.9em; opacity:0.8">${pd.duration || ''}</span></p>
                            </div>`;
                        }
                        planet.moons.forEach(moon => {
                            const d = isSpace ? (moon.spaceDetails || moon.pdfDetails || {}) : (moon.pdfDetails || moon.moonDetails || {});
                            const list = d.items || d.skills || [];
                            if (list.length) {
                                html += `<div class="edu-block"><h4 style="color:${itemTitleColor}">${d.title || moon.name}</h4><ul>${list.map(i => `<li>${i}</li>`).join('')}</ul></div>`;
                            }
                        });
                    }
                    else if (planet.renderType === 'languages') {
                        const pd = isSpace ? (planet.spaceDetails || planet.pdfDetails || {}) : (planet.pdfDetails || {});
                        if (pd.languages) {
                            html += `<div class="skill-block"><ul style="list-style:none; padding:0;">`;
                            pd.languages.forEach(lang => {
                                html += `<li style="margin-bottom:4px;"><strong>${lang.name}:</strong> ${lang.level}</li>`;
                            });
                            html += `</ul></div>`;
                        }
                    }
                    
                    html += `</section>`;
                    return html;
                };

                // --- SIDEBAR CONTENT ---
                const sidebarPlanets = RESUME_DATA.planets.filter(p => p.section === 'sidebar').sort((a,b) => a.order - b.order);
                sidebarPlanets.forEach(p => {
                    html += renderPlanet(p);
                });

                html += `</div> <!-- End Sidebar -->

                        <!-- Main Content (Summary, Experience, Projects) -->
                        <div class="resume-main">
                `;

                // --- MAIN CONTENT ---
                // Summary
                const summaryText = isSpace ? (RESUME_DATA.spaceSummary || RESUME_DATA.summary) : (RESUME_DATA.pdfSummary || RESUME_DATA.summary);
                html += `<section><h3 style="color:${sectionTitleColor}; border-bottom: 1px solid ${borderColor}">${summaryTitle}</h3><p>${summaryText}</p></section>`;

                const mainPlanets = RESUME_DATA.planets.filter(p => p.section === 'main').sort((a,b) => a.order - b.order);
                mainPlanets.forEach(p => {
                    html += renderPlanet(p);
                });
                
                html += `</div> <!-- End Main -->
                    </div> <!-- End Grid -->
                </div> <!-- End Container -->`;

                // Button Styles
                const commonBtnStyle = "cursor: pointer; font-family: inherit; font-weight: bold; transition: transform 0.2s; backdrop-filter: blur(5px);";
                const spaceBtnStyle = `background: rgba(56, 189, 248, 0.25); border: 1px solid rgba(56, 189, 248, 0.4); color: #e0f2fe; box-shadow: 0 4px 15px rgba(0,0,0,0.3); ${commonBtnStyle}`;
                const profBtnStyle = `background: rgba(241, 245, 249, 0.75); border: 1px solid rgba(226, 232, 240, 0.6); color: #0f172a; box-shadow: 0 2px 5px rgba(0,0,0,0.05); ${commonBtnStyle}`;

                const backToTopStyle = isSpace ? spaceBtnStyle : profBtnStyle;
                const btnTop = errorMessage ? '90px' : '20px';
                const btnRight = isMobile ? '20px' : '180px';
                const themeBtnStyle = isSpace 
                    ? `position: fixed; top: ${btnTop}; right: ${btnRight}; z-index: 2002; padding: 10px 16px; border-radius: 30px; font-size: 12px; ${spaceBtnStyle}`
                    : `position: fixed; top: ${btnTop}; right: ${btnRight}; z-index: 2002; padding: 10px 16px; border-radius: 30px; font-size: 12px; ${profBtnStyle}`;

                const downloadBtnStyle = isSpace 
                    ? spaceBtnStyle 
                    : profBtnStyle;

                // Add Floating Theme Button
                html += `<button onclick="renderMobileView('${isSpace ? 'professional' : 'space'}')" style="${themeBtnStyle}">
                    ${isSpace ? '‚òÄÔ∏è View Professional' : 'ü™ê View Space Theme'}
                </button>`;

                html += `<button id="back-to-top" onclick="document.getElementById('mobile-view').scrollTo({top: 0, behavior: 'smooth'})" style="${backToTopStyle}">‚Üë</button>`;

                html += `<div class="mobile-buttons">
                    ${!isMobile ? `<button onclick="window.print()" style="${downloadBtnStyle}">üñ®Ô∏è Print</button>` : ''}
                    <button onclick="generatePDF('professional')" style="${downloadBtnStyle}">üìÑ Professional PDF</button>
                    <button onclick="generatePDF('space')" style="${downloadBtnStyle}">üöÄ Space PDF</button>
                </div>`;

                container.innerHTML = html;
            };

            // Initial render - Professional (Light) by default
            renderMobileView('professional');
            
        }

        if (isMobile) {
            startFallbackMode();
        } else {

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.0008);
        
        // Container for Sun and Planets to move together
        const solarSystem = new THREE.Group();
        solarSystem.userData.isSucked = false;
        scene.add(solarSystem);

        // Black hole in the far background
        const blackHoleGroup = new THREE.Group();
        blackHoleGroup.userData = { isBlackHole: true, name: 'Black Hole' };
        blackHoleGroup.position.set(900, 260, -250);
        blackHoleGroup.renderOrder = 0;
        scene.add(blackHoleGroup);
        clickableObjects.push(blackHoleGroup);
        objects.push({ mesh: blackHoleGroup, speed: 0.0006, type: 'rotate' });

        blackHoleGroup.rotation.x = 0;

        const blackHoleLight = new THREE.PointLight(0xffffff, 35.0, 3600);
        blackHoleLight.position.set(0, 0, 0);
        blackHoleGroup.add(blackHoleLight);

        const blackHoleHitGeo = new THREE.SphereGeometry(160, 24, 24);
        const blackHoleHitMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.02
        });
        const blackHoleHit = new THREE.Mesh(blackHoleHitGeo, blackHoleHitMat);
        blackHoleHit.frustumCulled = false;
        blackHoleHit.userData = { isBlackHole: true };
        blackHoleGroup.add(blackHoleHit);

        // Add black sphere at center to hide stars
        const blackCenterGeo = new THREE.SphereGeometry(100, 32, 32);
        const blackCenterMat = new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: false
        });
        const blackCenter = new THREE.Mesh(blackCenterGeo, blackCenterMat);
        blackCenter.frustumCulled = false;
        blackCenter.position.z = 0;
        blackHoleGroup.add(blackCenter);

        gltfLoader.load(
            'assets/models/blackhole/scene.gltf',
            (gltf) => {
                const blackHoleModel = gltf.scene;
                blackHoleModel.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                        child.renderOrder = 0;
                        if (child.material) {
                            const mats = Array.isArray(child.material) ? child.material : [child.material];
                            mats.forEach((m) => {
                                if (!m) return;
                                m.depthTest = true;
                                m.depthWrite = true;
                                m.needsUpdate = true;
                            });
                        }
                        const mat = child.material;
                        // Keep materials as-is without emissive boost
                        if (Array.isArray(mat)) {
                            // Materials are arrays
                        } else {
                            // Single material
                        }
                    }
                });
                blackHoleModel.scale.set(140, 140, 140);
                blackHoleGroup.add(blackHoleModel);
            },
            undefined,
            (error) => {
                console.error('Failed to load black hole model', error);
            }
        );

        // UI layer hidden initially (labels, etc)
        const uiLayer = document.getElementById('ui-layer');
        const blackHoleOverlay = document.getElementById('blackhole-overlay');
        document.body.classList.add('labels-hidden');
        document.body.classList.add('loading');

        // Solar system loading state
        let solarModelsToLoad = 0;
        let solarModelsLoaded = 0;
        let solarLoadTimeoutId = null;

        const solarLoadingOverlay = document.getElementById('solar-loading-overlay');

        function updateSolarLoadingOverlay() {
            const progressEl = document.getElementById('solar-loading-progress');
            if (!progressEl) return;
            const percent = solarModelsToLoad === 0 ? 0 : Math.round((solarModelsLoaded / solarModelsToLoad) * 100);
            progressEl.textContent = `${percent}%`;
        }

        function checkSolarModelsReady() {
            updateSolarLoadingOverlay();
            if (solarModelsToLoad > 0 && solarModelsLoaded >= solarModelsToLoad) {
                // Show everything at once
                container.style.display = 'block';
                uiLayer.style.display = 'flex';
                solarLoadingOverlay.style.display = 'none';
                document.body.classList.remove('loading');
                revealLabelsOnNextFrame = true;
                if (solarLoadTimeoutId) {
                    clearTimeout(solarLoadTimeoutId);
                    solarLoadTimeoutId = null;
                }
            }
        }

        // Failsafe: never block the UI forever
        solarLoadTimeoutId = setTimeout(() => {
            container.style.display = 'block';
            uiLayer.style.display = 'flex';
            solarLoadingOverlay.style.display = 'none';
            document.body.classList.remove('loading');
            revealLabelsOnNextFrame = true;
        }, 15000);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 12000);
        camera.position.set(0, 150, 900); // High viewpoint for better perspective
        
        let webGLRenderer;
        try {
            webGLRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        } catch (e) {
            console.warn("WebGL failed, falling back to static view.");
            startFallbackMode("Hardware Acceleration is disabled or not supported. To see the interactive 3D solar system, please enable <strong>'Use graphics acceleration when available'</strong> in your browser settings and reload the page.");
            throw new Error("WebGL Fallback");
        }
        webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        webGLRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        webGLRenderer.shadowMap.enabled = true;
        webGLRenderer.shadowMap.type = THREE.PCFShadowShadowMap;
        if ('outputColorSpace' in webGLRenderer) {
            webGLRenderer.outputColorSpace = THREE.SRGBColorSpace;
        } else if ('outputEncoding' in webGLRenderer) {
            webGLRenderer.outputEncoding = THREE.sRGBEncoding;
        }
        webGLRenderer.toneMapping = THREE.NoToneMapping;
        container.appendChild(webGLRenderer.domElement);

        const controls = new OrbitControls(camera, webGLRenderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 2000;
        if (isMobile) {
            controls.enablePan = false;
            controls.rotateSpeed = 0.5;
        }

        // === VIEW HISTORY SYSTEM (AFTER CAMERA/CONTROLS CREATION) ===
        function saveCurrentView() {
            const currentView = {
                cameraPosition: camera.position.clone(),
                cameraTarget: controls.target.clone(),
                focusedObject: focusedObject,
                isCenterView: isCenterView,
                timestamp: Date.now()
            };
            
            // Remove any views after current index (when going back and then making new selection)
            viewHistory.splice(currentViewIndex + 1);
            
            // Add new view
            viewHistory.push(currentView);
            currentViewIndex = viewHistory.length - 1;
            
            // Limit history to last 10 views
            if (viewHistory.length > 10) {
                viewHistory.shift();
                currentViewIndex--;
            }
            
            // Update back button visibility
            updateBackButton();
        }
        
        function goToPreviousView() {
            if (currentViewIndex > 0) {
                currentViewIndex--;
                const previousView = viewHistory[currentViewIndex];
                
                // Restore previous view
                focusedObject = previousView.focusedObject;
                isCenterView = previousView.isCenterView;
                
                // Update moon orbit visibility for the restored focused object
                updateMoonOrbitVisibility();
                
                // Animate to previous camera position
                gsap.to(camera.position, {
                    x: previousView.cameraPosition.x,
                    y: previousView.cameraPosition.y,
                    z: previousView.cameraPosition.z,
                    duration: 1.0
                });
                
                gsap.to(controls.target, {
                    x: previousView.cameraTarget.x,
                    y: previousView.cameraTarget.y,
                    z: previousView.cameraTarget.z,
                    duration: 1.0
                });
                
                // Close any open modals
                document.getElementById('sky-details').style.display = 'none';
                document.getElementById('overlay-panel').classList.remove('active');
                
                // Update back button visibility
                updateBackButton();
                
                return true; // Successfully went back
            }
            return false; // No previous view available
        }
        
        function updateBackButton() {
            const backBtn = document.getElementById('back-btn');
            if (backBtn) {
                backBtn.style.display = (currentViewIndex > 0) ? 'block' : 'none';
            }
        }
        
        // Make goToPreviousView available globally
        window.goToPreviousView = goToPreviousView;

        // === LIGHTING ===
        // Ambient light now configured with sun setup for better brightness
        
        const sunLight = new THREE.PointLight(0xffffff, 6, 2000);
        sunLight.position.set(0, 0, 0);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096;
        sunLight.shadow.mapSize.height = 4096;
        scene.remove(sunLight);
        solarSystem.add(sunLight);

        // Additional fill lights to make planets visible from all angles
        const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        fillLight1.position.set(500, 300, 500);
        scene.add(fillLight1);

        const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
        fillLight2.position.set(-500, 200, -300);
        scene.add(fillLight2);

        const fillLight3 = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight3.position.set(0, -400, 600);
        scene.add(fillLight3);

        // === MINIMAL GSAP REPLACEMENT ===
        const gsap = {
            to: function(target, config) {
                const startValues = {};
                const endValues = config;
                const duration = (config.duration || 0) * 1000;
                const startTime = Date.now();
                const easeFunc = this.easeInOut;

                Object.keys(endValues).forEach(key => {
                    if (key !== 'duration' && key !== 'ease' && key !== 'onComplete') {
                        startValues[key] = target[key];
                    }
                });

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = easeFunc(progress);

                    Object.keys(startValues).forEach(key => {
                        target[key] = startValues[key] + (endValues[key] - startValues[key]) * eased;
                    });

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else if (config.onComplete) {
                        config.onComplete();
                    }
                };

                animate();
            },
            easeInOut: function(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }
        };

        // === TEXTURE GENERATORS ===
        function createCanvasTexture(width, height, drawFn) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            drawFn(ctx, width, height);
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            // expose the source canvas for UI snapshot fallback
            tex._canvas = canvas;
            return tex;
        }

        // Red Experience planet with Jupiter-like atmosphere - BRIGHTER
        function drawRed(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#8a2a2a'); // Brighter starting color
            grad.addColorStop(0.15, '#d04a4a'); // Much brighter
            grad.addColorStop(0.3, '#ff5a5a'); // Bright red
            grad.addColorStop(0.4, '#ff7777'); // Even brighter
            grad.addColorStop(0.5, '#ff6666');
            grad.addColorStop(0.6, '#ff5555');
            grad.addColorStop(0.7, '#ee4444');
            grad.addColorStop(0.85, '#bb3333');
            grad.addColorStop(1, '#8a2a2a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Atmospheric bands (lighter)
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 18; i++) {
                const y = (i / 18) * h;
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.08 + 0.02})`; // Reduced darkness
                ctx.fillRect(0, y, w, Math.random() * 25 + 12);
            }

            // Large storm/vortex - brighter
            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = 'rgba(220, 60, 60, 0.4)'; // Brighter storm
            ctx.beginPath();
            ctx.ellipse(w * 0.62, h * 0.58, w * 0.2, h * 0.14, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Atmospheric swirls - brighter
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 200; i++) {
                ctx.fillStyle = `rgba(255,220,220,${Math.random() * 0.18})`; // Brighter swirls
                ctx.beginPath();
                ctx.ellipse(Math.random() * w, Math.random() * h, 50 + Math.random() * 130, 12 + Math.random() * 35, Math.random() * Math.PI, 0, Math.PI * 2);
                ctx.fill();
            }

            // Bright highlights for atmospheric reflection
            for(let i = 0; i < 120; i++) {
                ctx.fillStyle = `rgba(255,180,180,${Math.random() * 0.25})`; // Brighter highlights
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, Math.random() * 18 + 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // BRIGHTER TEXTURE GENERATORS
        // Mars - Even lighter red/orange
        function drawMars(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#8b5a3a');
            grad.addColorStop(0.15, '#b8704a');
            grad.addColorStop(0.3, '#e07855');
            grad.addColorStop(0.5, '#ff9966');
            grad.addColorStop(0.7, '#e07855');
            grad.addColorStop(0.85, '#b8704a');
            grad.addColorStop(1, '#8b5a3a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 15; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1 + 0.02})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 60 + Math.random() * 150, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 150; i++) {
                ctx.fillStyle = `rgba(255, 180, 120, ${Math.random() * 0.25})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 30 + Math.random() * 80, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Venus - Brighter golden yellow
        function drawVenus(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#d4b85a'); // Much brighter starting color
            grad.addColorStop(0.15, '#ffeb8f'); // Brighter
            grad.addColorStop(0.3, '#ffffbb'); // Brighter
            grad.addColorStop(0.5, '#ffffbb'); // Brighter
            grad.addColorStop(0.7, '#ffeb99');
            grad.addColorStop(0.85, '#f5d86f');
            grad.addColorStop(1, '#d4b85a'); // Brighter end
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 10; i++) {
                const y = (i / 10) * h;
                ctx.fillStyle = `rgba(200, 160, 80, ${Math.random() * 0.06 + 0.01})`; // Reduced darkness
                ctx.fillRect(0, y, w, Math.random() * 30 + 15);
            }

            ctx.globalCompositeOperation = 'overlay';
            for(let i = 0; i < 150; i++) {
                ctx.fillStyle = `rgba(255, 240, 180, ${Math.random() * 0.3})`; // Brighter overlay
                ctx.beginPath();
                ctx.ellipse(Math.random() * w, Math.random() * h, 70 + Math.random() * 140, 20 + Math.random() * 40, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Jupiter - Even lighter cream/tan
        function drawJupiter(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#6b5a45');
            grad.addColorStop(0.15, '#b39a7a');
            grad.addColorStop(0.3, '#ddb878');
            grad.addColorStop(0.4, '#e8d9a8');
            grad.addColorStop(0.5, '#ddb878');
            grad.addColorStop(0.6, '#d4a574');
            grad.addColorStop(0.7, '#c49c6a');
            grad.addColorStop(0.85, '#a68a67');
            grad.addColorStop(1, '#8b7a57');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 20; i++) {
                const y = (i / 20) * h;
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1 + 0.02})`;
                ctx.fillRect(0, y, w, Math.random() * 20 + 10);
            }

            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = 'rgba(240, 140, 100, 0.2)';
            ctx.beginPath();
            ctx.ellipse(w * 0.65, h * 0.55, w * 0.18, h * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 180; i++) {
                ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, Math.random() * 15 + 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Saturn - Brighter vanilla/cream
        function drawSaturn(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#8b7a5a');
            grad.addColorStop(0.15, '#d9c896');
            grad.addColorStop(0.3, '#f0e8c8');
            grad.addColorStop(0.5, '#fffae6');
            grad.addColorStop(0.7, '#f0e8c8');
            grad.addColorStop(0.85, '#d9c896');
            grad.addColorStop(1, '#8b7a5a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 12; i++) {
                const y = (i / 12) * h;
                ctx.fillStyle = `rgba(140, 120, 80, ${Math.random() * 0.08 + 0.02})`;
                ctx.fillRect(0, y, w, Math.random() * 15 + 8);
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 150; i++) {
                ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.18})`;
                ctx.beginPath();
                ctx.ellipse(Math.random() * w, Math.random() * h, 60 + Math.random() * 120, 10 + Math.random() * 20, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Uranus - Brighter light cyan
        function drawUranus(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#5a7a9a');
            grad.addColorStop(0.2, '#7aaacc');
            grad.addColorStop(0.35, '#99ccff');
            grad.addColorStop(0.5, '#bbddff');
            grad.addColorStop(0.65, '#99ccff');
            grad.addColorStop(0.8, '#7aaacc');
            grad.addColorStop(1, '#5a7a9a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'overlay';
            for(let i = 0; i < 25; i++) {
                ctx.fillStyle = `rgba(180, 220, 255, ${Math.random() * 0.2})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 60 + Math.random() * 120, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Neptune - Brighter light blue
        // Photorealistic Earth texture using advanced canvas techniques like the sun
        function drawEarth(ctx, w, h) {
            // Base ocean with sophisticated depth gradient
            const oceanGradient = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h)/2);
            oceanGradient.addColorStop(0, '#1e40af');
            oceanGradient.addColorStop(0.3, '#1d4ed8');
            oceanGradient.addColorStop(0.6, '#1e3a8a');
            oceanGradient.addColorStop(0.8, '#1e293b');
            oceanGradient.addColorStop(1, '#0f172a');
            ctx.fillStyle = oceanGradient;
            ctx.fillRect(0, 0, w, h);

            // Add thousands of ocean depth particles for realism
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 8000; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 3 + 0.5;
                const intensity = Math.random() * 0.15 + 0.05;
                
                ctx.fillStyle = `rgba(30, 58, 138, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add ocean surface sparkles
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 2000; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 1.5 + 0.2;
                const intensity = Math.random() * 0.3 + 0.1;
                
                ctx.fillStyle = `rgba(100, 150, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'source-over';

            // AFRICA - with advanced gradient and texture
            ctx.save();
            const africaGradient = ctx.createRadialGradient(w * 0.53, h * 0.4, 0, w * 0.53, h * 0.4, w * 0.15);
            africaGradient.addColorStop(0, '#22c55e');
            africaGradient.addColorStop(0.3, '#16a34a');
            africaGradient.addColorStop(0.6, '#15803d');
            africaGradient.addColorStop(0.8, '#166534');
            africaGradient.addColorStop(1, '#14532d');
            ctx.fillStyle = africaGradient;
            
            // Create Africa with bezier curves
            ctx.beginPath();
            ctx.moveTo(w * 0.52, h * 0.22);
            ctx.bezierCurveTo(w * 0.58, h * 0.20, w * 0.62, h * 0.25, w * 0.63, h * 0.30);
            ctx.bezierCurveTo(w * 0.62, h * 0.38, w * 0.60, h * 0.45, w * 0.58, h * 0.52);
            ctx.bezierCurveTo(w * 0.56, h * 0.58, w * 0.52, h * 0.60, w * 0.48, h * 0.58);
            ctx.bezierCurveTo(w * 0.44, h * 0.55, w * 0.43, h * 0.48, w * 0.45, h * 0.40);
            ctx.bezierCurveTo(w * 0.46, h * 0.32, w * 0.48, h * 0.25, w * 0.52, h * 0.22);
            ctx.fill();

            // Add thousands of vegetation particles to Africa
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 3000; i++) {
                const x = w * (0.43 + Math.random() * 0.20);
                const y = h * (0.22 + Math.random() * 0.38);
                if(ctx.isPointInPath(x, y)) {
                    const size = Math.random() * 2 + 0.3;
                    const intensity = Math.random() * 0.4 + 0.1;
                    ctx.fillStyle = `rgba(21, 128, 61, ${intensity})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Add bright vegetation highlights
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 800; i++) {
                const x = w * (0.43 + Math.random() * 0.20);
                const y = h * (0.22 + Math.random() * 0.38);
                const size = Math.random() * 1 + 0.2;
                const intensity = Math.random() * 0.2 + 0.05;
                ctx.fillStyle = `rgba(34, 197, 94, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // ASIA - with sophisticated rendering
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            const asiaGradient = ctx.createRadialGradient(w * 0.73, h * 0.23, 0, w * 0.73, h * 0.23, w * 0.2);
            asiaGradient.addColorStop(0, '#10b981');
            asiaGradient.addColorStop(0.4, '#059669');
            asiaGradient.addColorStop(0.7, '#047857');
            asiaGradient.addColorStop(1, '#065f46');
            ctx.fillStyle = asiaGradient;
            
            ctx.beginPath();
            ctx.moveTo(w * 0.58, h * 0.15);
            ctx.bezierCurveTo(w * 0.75, h * 0.10, w * 0.85, h * 0.15, w * 0.88, h * 0.25);
            ctx.bezierCurveTo(w * 0.87, h * 0.32, w * 0.82, h * 0.36, w * 0.75, h * 0.35);
            ctx.bezierCurveTo(w * 0.68, h * 0.33, w * 0.62, h * 0.28, w * 0.60, h * 0.22);
            ctx.bezierCurveTo(w * 0.58, h * 0.18, w * 0.58, h * 0.15, w * 0.58, h * 0.15);
            ctx.fill();

            // Add detailed terrain to Asia
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 4000; i++) {
                const x = w * (0.58 + Math.random() * 0.30);
                const y = h * (0.15 + Math.random() * 0.20);
                const size = Math.random() * 2.5 + 0.4;
                const intensity = Math.random() * 0.3 + 0.1;
                ctx.fillStyle = `rgba(4, 120, 87, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // NORTH AMERICA - with advanced texturing
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            const naGradient = ctx.createRadialGradient(w * 0.22, h * 0.23, 0, w * 0.22, h * 0.23, w * 0.15);
            naGradient.addColorStop(0, '#6ee7b7');
            naGradient.addColorStop(0.3, '#10b981');
            naGradient.addColorStop(0.7, '#059669');
            naGradient.addColorStop(1, '#047857');
            ctx.fillStyle = naGradient;
            
            ctx.beginPath();
            ctx.moveTo(w * 0.15, h * 0.10);
            ctx.bezierCurveTo(w * 0.28, h * 0.06, w * 0.33, h * 0.12, w * 0.32, h * 0.20);
            ctx.bezierCurveTo(w * 0.31, h * 0.28, w * 0.28, h * 0.33, w * 0.22, h * 0.36);
            ctx.bezierCurveTo(w * 0.18, h * 0.35, w * 0.14, h * 0.30, w * 0.12, h * 0.22);
            ctx.bezierCurveTo(w * 0.13, h * 0.15, w * 0.15, h * 0.10, w * 0.15, h * 0.10);
            ctx.fill();

            // Add forest detail to North America
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 2500; i++) {
                const x = w * (0.12 + Math.random() * 0.21);
                const y = h * (0.10 + Math.random() * 0.26);
                const size = Math.random() * 2 + 0.3;
                const intensity = Math.random() * 0.35 + 0.1;
                ctx.fillStyle = `rgba(5, 150, 105, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // SOUTH AMERICA - with rainforest detail
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            const saGradient = ctx.createRadialGradient(w * 0.23, h * 0.53, 0, w * 0.23, h * 0.53, w * 0.12);
            saGradient.addColorStop(0, '#34d399');
            saGradient.addColorStop(0.4, '#10b981');
            saGradient.addColorStop(0.8, '#059669');
            saGradient.addColorStop(1, '#047857');
            ctx.fillStyle = saGradient;
            
            ctx.beginPath();
            ctx.moveTo(w * 0.22, h * 0.38);
            ctx.bezierCurveTo(w * 0.28, h * 0.40, w * 0.29, h * 0.48, w * 0.27, h * 0.56);
            ctx.bezierCurveTo(w * 0.25, h * 0.64, w * 0.22, h * 0.68, w * 0.20, h * 0.66);
            ctx.bezierCurveTo(w * 0.18, h * 0.60, w * 0.19, h * 0.50, w * 0.20, h * 0.42);
            ctx.bezierCurveTo(w * 0.21, h * 0.38, w * 0.22, h * 0.38, w * 0.22, h * 0.38);
            ctx.fill();

            // Add Amazon rainforest particles
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 1500; i++) {
                const x = w * (0.18 + Math.random() * 0.11);
                const y = h * (0.38 + Math.random() * 0.30);
                const size = Math.random() * 1.5 + 0.2;
                const intensity = Math.random() * 0.4 + 0.1;
                ctx.fillStyle = `rgba(16, 185, 129, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // AUSTRALIA - with desert and coastal detail
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            const ausGradient = ctx.createRadialGradient(w * 0.82, h * 0.68, 0, w * 0.82, h * 0.68, w * 0.06);
            ausGradient.addColorStop(0, '#fbbf24');
            ausGradient.addColorStop(0.5, '#f59e0b');
            ausGradient.addColorStop(0.8, '#d97706');
            ausGradient.addColorStop(1, '#16a34a');
            ctx.fillStyle = ausGradient;
            ctx.beginPath();
            ctx.ellipse(w * 0.82, h * 0.68, w * 0.055, h * 0.035, 0, 0, Math.PI * 2);
            ctx.fill();

            // Add desert texture to Australia
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 800; i++) {
                const x = w * (0.77 + Math.random() * 0.10);
                const y = h * (0.65 + Math.random() * 0.06);
                const size = Math.random() * 1.5 + 0.2;
                const intensity = Math.random() * 0.3 + 0.1;
                ctx.fillStyle = `rgba(217, 119, 6, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Add sophisticated cloud system like the sun's particle system
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            // Thousands of cloud particles for realism
            for(let i = 0; i < 5000; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 4 + 0.5;
                const intensity = Math.random() * 0.15 + 0.05;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Larger cloud formations
            ctx.globalCompositeOperation = 'lighter';
            for(let i = 0; i < 800; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 15 + 5;
                const intensity = Math.random() * 0.2 + 0.05;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Hurricane spiral systems with mathematical precision
            const drawAdvancedSpiral = (centerX, centerY, radius, intensity, arms = 3) => {
                ctx.globalCompositeOperation = 'screen';
                for(let arm = 0; arm < arms; arm++) {
                    ctx.beginPath();
                    for(let angle = 0; angle < Math.PI * 8; angle += 0.05) {
                        const r = (angle / (Math.PI * 8)) * radius;
                        const spiralAngle = angle + (arm * Math.PI * 2 / arms);
                        const x = centerX + Math.cos(spiralAngle) * r;
                        const y = centerY + Math.sin(spiralAngle) * r;
                        
                        if(angle === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.strokeStyle = `rgba(255, 255, 255, ${intensity})`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            };
            
            drawAdvancedSpiral(w * 0.35, h * 0.35, w * 0.04, 0.3, 4); // Atlantic hurricane
            drawAdvancedSpiral(w * 0.85, h * 0.40, w * 0.035, 0.25, 3); // Pacific typhoon
            ctx.restore();

            // Professional polar ice caps with advanced layering
            ctx.save();
            
            // Arctic ice cap with multiple layers like the sun
            ctx.globalCompositeOperation = 'source-over';
            const arcticGradient = ctx.createRadialGradient(w * 0.5, h * 0.05, 0, w * 0.5, h * 0.05, w * 0.3);
            arcticGradient.addColorStop(0, '#ffffff');
            arcticGradient.addColorStop(0.3, '#f8fafc');
            arcticGradient.addColorStop(0.6, '#f1f5f9');
            arcticGradient.addColorStop(0.8, '#e2e8f0');
            arcticGradient.addColorStop(1, '#cbd5e1');
            ctx.fillStyle = arcticGradient;
            
            ctx.beginPath();
            ctx.moveTo(w * 0.25, 0);
            ctx.bezierCurveTo(w * 0.4, h * 0.02, w * 0.6, h * 0.02, w * 0.75, 0);
            ctx.bezierCurveTo(w * 0.8, h * 0.04, w * 0.78, h * 0.08, w * 0.72, h * 0.10);
            ctx.bezierCurveTo(w * 0.5, h * 0.12, w * 0.3, h * 0.10, w * 0.22, h * 0.08);
            ctx.bezierCurveTo(w * 0.2, h * 0.04, w * 0.25, 0, w * 0.25, 0);
            ctx.fill();

            // Add thousands of ice crystals
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 3000; i++) {
                const x = w * (0.2 + Math.random() * 0.6);
                const y = h * (0 + Math.random() * 0.12);
                const size = Math.random() * 2 + 0.2;
                const intensity = Math.random() * 0.4 + 0.1;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Antarctic ice cap with similar advanced treatment
            ctx.globalCompositeOperation = 'source-over';
            const antarcticGradient = ctx.createRadialGradient(w * 0.5, h * 0.9, 0, w * 0.5, h * 0.9, w * 0.35);
            antarcticGradient.addColorStop(0, '#ffffff');
            antarcticGradient.addColorStop(0.4, '#f8fafc');
            antarcticGradient.addColorStop(0.7, '#f1f5f9');
            antarcticGradient.addColorStop(0.9, '#e2e8f0');
            antarcticGradient.addColorStop(1, '#cbd5e1');
            ctx.fillStyle = antarcticGradient;
            
            ctx.beginPath();
            ctx.moveTo(w * 0.15, h);
            ctx.bezierCurveTo(w * 0.3, h * 0.95, w * 0.7, h * 0.95, w * 0.85, h);
            ctx.bezierCurveTo(w * 0.88, h * 0.88, w * 0.82, h * 0.84, w * 0.75, h * 0.83);
            ctx.bezierCurveTo(w * 0.5, h * 0.82, w * 0.25, h * 0.83, w * 0.18, h * 0.84);
            ctx.bezierCurveTo(w * 0.12, h * 0.88, w * 0.15, h, w * 0.15, h);
            ctx.fill();

            // Add Antarctic ice crystals
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 4000; i++) {
                const x = w * (0.15 + Math.random() * 0.7);
                const y = h * (0.82 + Math.random() * 0.18);
                const size = Math.random() * 2.5 + 0.3;
                const intensity = Math.random() * 0.5 + 0.1;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();

            // Add atmospheric glow effect like the sun's outer glow
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            const atmosphereGradient = ctx.createRadialGradient(w/2, h/2, Math.min(w, h) * 0.35, w/2, h/2, Math.min(w, h) * 0.5);
            atmosphereGradient.addColorStop(0, 'rgba(135, 206, 235, 0)');
            atmosphereGradient.addColorStop(0.7, 'rgba(135, 206, 235, 0.1)');
            atmosphereGradient.addColorStop(0.9, 'rgba(135, 206, 235, 0.2)');
            atmosphereGradient.addColorStop(1, 'rgba(135, 206, 235, 0.4)');
            ctx.fillStyle = atmosphereGradient;
            ctx.fillRect(0, 0, w, h);
            ctx.restore();
        }

        // Moon/Rocky texture
        function drawRocky(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#5a5a5a');
            grad.addColorStop(0.5, '#a8a8a8');
            grad.addColorStop(1, '#6a6a6a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for (let i = 0; i < 250; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const r = Math.random() * 10 + 2;
                
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 0, 0, ${0.2 + Math.random() * 0.35})`;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(x - r/3, y - r/3, r / 2.2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 200, 200, ${0.15 + Math.random() * 0.25})`;
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(230, 230, 230, ${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 40 + Math.random() * 120, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Green planet texture (for Education)
        function drawGreen(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#0d3a1a');
            grad.addColorStop(0.15, '#1d6b2f');
            grad.addColorStop(0.3, '#2d8c42');
            grad.addColorStop(0.5, '#4db85a');
            grad.addColorStop(0.7, '#2d8c42');
            grad.addColorStop(0.85, '#1d6b2f');
            grad.addColorStop(1, '#0d3a1a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Vegetation/forest patterns
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.2 + 0.05})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 50 + Math.random() * 150, 0, Math.PI * 2);
                ctx.fill();
            }

            // Lighter vegetation highlights
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(100, 200, 100, ${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 20 + Math.random() * 60, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Light Green Yellow planet texture
        function drawLightGreenYellow(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#eaff80');
            grad.addColorStop(0.5, '#f7ffcc');
            grad.addColorStop(1, '#eaff80');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 15; i++) {
                const y = (i / 15) * h;
                ctx.fillStyle = `rgba(180, 200, 100, ${Math.random() * 0.1 + 0.02})`;
                ctx.fillRect(0, y, w, Math.random() * 20 + 10);
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(255, 255, 220, ${Math.random() * 0.2})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, Math.random() * 20 + 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Yellow moon texture - Brighter
        function drawYellow(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#7a5a2a');
            grad.addColorStop(0.15, '#c4a850');
            grad.addColorStop(0.3, '#e8d966');
            grad.addColorStop(0.5, '#ffeb99');
            grad.addColorStop(0.7, '#e8d966');
            grad.addColorStop(0.85, '#c4a850');
            grad.addColorStop(1, '#7a5a2a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for (let i = 0; i < 80; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const r = Math.random() * 8 + 2;
                
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 0, 0, ${0.1 + Math.random() * 0.15})`;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(x - r/3, y - r/3, r / 2.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 200, ${0.15 + Math.random() * 0.2})`;
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 60; i++) {
                ctx.fillStyle = `rgba(255, 255, 220, ${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 30 + Math.random() * 80, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Teal moon texture - Brighter
        function drawTeal(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#3a5a7a');
            grad.addColorStop(0.15, '#5a8aaa');
            grad.addColorStop(0.3, '#7abacc');
            grad.addColorStop(0.5, '#99ddff');
            grad.addColorStop(0.7, '#7abacc');
            grad.addColorStop(0.85, '#5a8aaa');
            grad.addColorStop(1, '#3a5a7a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(0, 0, 0, ${0.15 + Math.random() * 0.2})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 60 + Math.random() * 120, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 70; i++) {
                ctx.fillStyle = `rgba(220, 255, 255, ${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 25 + Math.random() * 100, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Blue Education planet texture - BRIGHTER
        function drawBlue(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#2a4a8a'); // Much brighter starting blue
            grad.addColorStop(0.15, '#4a7acc'); // Brighter
            grad.addColorStop(0.3, '#5a9aff'); // Bright blue
            grad.addColorStop(0.5, '#6abaff'); // Even brighter
            grad.addColorStop(0.7, '#5a9aff');
            grad.addColorStop(0.85, '#4a7acc');
            grad.addColorStop(1, '#2a4a8a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Water/ocean patterns - lighter
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1 + 0.02})`; // Reduced darkness
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 50 + Math.random() * 150, 0, Math.PI * 2);
                ctx.fill();
            }

            // Cloud highlights - brighter
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(180, 220, 255, ${Math.random() * 0.25})`; // Brighter clouds
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 20 + Math.random() * 60, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Moon surface textures - showing what each moon represents
        function drawEmailSurface(ctx, w, h) {
            // Email represented as an envelope/message surface
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#2a2a3a');
            grad.addColorStop(0.5, '#4a5a7a');
            grad.addColorStop(1, '#2a2a3a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Envelope pattern
            ctx.globalCompositeOperation = 'overlay';
            ctx.strokeStyle = 'rgba(255, 200, 100, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(w, 0);
            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.lineTo(0, 0);
            ctx.stroke();

            // Email lines
            for(let i = 1; i < 6; i++) {
                ctx.strokeStyle = `rgba(200, 200, 255, ${0.3 - i*0.05})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(10, h * (i / 6));
                ctx.lineTo(w - 10, h * (i / 6));
                ctx.stroke();
            }

            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 200, 0.2)';
            ctx.fillRect(w * 0.2, h * 0.2, w * 0.6, h * 0.3);
        }

        function drawPhoneSurface(ctx, w, h) {
            // Phone represented as a display/screen surface
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#1a1a2a');
            grad.addColorStop(0.5, '#3a4a5a');
            grad.addColorStop(1, '#1a1a2a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Phone screen with grid pattern
            ctx.globalCompositeOperation = 'overlay';
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
            ctx.lineWidth = 1;
            for(let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.moveTo((w / 10) * i, 0);
                ctx.lineTo((w / 10) * i, h);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, (h / 10) * i);
                ctx.lineTo(w, (h / 10) * i);
                ctx.stroke();
            }

            // Glowing dots
            ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
            for(let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * w * 0.8 + w * 0.1, Math.random() * h * 0.8 + h * 0.1, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawLocationSurface(ctx, w, h) {
            // Location represented as a map/coordinates surface
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#1a3a2a');
            grad.addColorStop(0.5, '#3a6a5a');
            grad.addColorStop(1, '#1a3a2a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Map grid
            ctx.globalCompositeOperation = 'overlay';
            ctx.strokeStyle = 'rgba(100, 255, 150, 0.3)';
            ctx.lineWidth = 1;
            for(let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo((w / 8) * i, 0);
                ctx.lineTo((w / 8) * i, h);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, (h / 8) * i);
                ctx.lineTo(w, (h / 8) * i);
                ctx.stroke();
            }

            // Location pin
            ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.4, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(255, 200, 100, 0.8)';
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.4, 8, 0, Math.PI * 2);
            ctx.fill();

            // Coordinate lines
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, h * 0.4);
            ctx.lineTo(w, h * 0.4);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(w * 0.5, 0);
            ctx.lineTo(w * 0.5, h);
            ctx.stroke();
            ctx.setLineDash([]);
        }


        // Texture map for dynamic loading
        const textureMap = {
            "drawRed": drawRed,
            "drawVenus": drawVenus,
            "drawJupiter": drawJupiter,
            "drawBlue": drawBlue,
            "drawLightGreenYellow": drawLightGreenYellow,
            "drawEarth": drawEarth,
            "drawGreen": drawGreen,
            "drawTeal": drawTeal,
            "drawYellow": drawYellow,
            "drawUranus": drawUranus,
            "drawSaturn": drawSaturn,
            "drawMars": drawMars
        };

        // === HELPER FUNCTIONS (MUST BE BEFORE USE) ===
        function createLabel(text, object, isMajor = false) {
            const div = document.createElement('div');
            div.className = isMajor ? 'label major' : 'label';
            div.innerHTML = text;
            div.onclick = (e) => {
                e.stopPropagation();
                focusOnObject(object);
            };
            document.getElementById('ui-layer').appendChild(div);
            labels.push({ div, object });
        }

        // === AUDIO SETUP ===
        function playSound(type) {
            if (!soundEnabled) return;
            const ctx = backgroundAudio ? backgroundAudio.audioContext : new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);

            if (type === 'laser') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.start();
                osc.stop(ctx.currentTime + 0.1);
            } else if (type === 'comet') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.05, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
                osc.start();
                osc.stop(ctx.currentTime + 0.5);
            }
        }

        function initAudio() {
            // tear down any previous audio nodes safely
            if (backgroundAudio) {
                try { backgroundAudio.oscillator.stop(); } catch(e){}
                try { backgroundAudio.oscillator.disconnect(); } catch(e){}
                try { backgroundAudio.gainNode.disconnect(); } catch(e){}
            }

            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // vary tone a little for texture, start muted
            oscillator.frequency.setValueAtTime(220 + Math.random() * 220, audioContext.currentTime);
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);

            try { oscillator.start(); } catch(e){ /* already started */ }

            backgroundAudio = { oscillator, gainNode, audioContext };
        }

        window.toggleSound = () => {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('sound-btn');
            const movieBtn = document.getElementById('nur-wars-sound-btn');
            const battleVideo = document.getElementById('battle-video');
            if (battleVideo) {
                battleVideo.muted = !soundEnabled;
            }

            if (soundEnabled) {
                btn.textContent = 'üîä Sound On';
                if (movieBtn) movieBtn.textContent = 'üîä';
                // Only resume background audio if NOT in NUR WARS movie
                if (!nurWarsActive && backgroundAudio) {
                    if (!backgroundAudio) initAudio();
                    // must resume audio context on user gesture and ramp gain
                    const ctx = backgroundAudio.audioContext;
                    ctx.resume().then(() => {
                        const now = ctx.currentTime;
                        try {
                            backgroundAudio.gainNode.gain.cancelScheduledValues(now);
                            backgroundAudio.gainNode.gain.setValueAtTime(backgroundAudio.gainNode.gain.value || 0, now);
                            backgroundAudio.gainNode.gain.linearRampToValueAtTime(0.01, now + 0.5);
                        } catch(e) { backgroundAudio.gainNode.gain.value = 0.01; }
                    }).catch(()=>{ /* ignore resume errors */ });
                }
                // Resume movie audio if playing
                if (currentAudio && currentAudio.paused && nurWarsActive && !moviePaused) {
                    currentAudio.play().catch(() => {});
                }
            } else {
                btn.textContent = 'üîá Sound Off';
                if (movieBtn) movieBtn.textContent = 'üîá';
                if (backgroundAudio) {
                    const now = backgroundAudio.audioContext.currentTime;
                    try {
                        backgroundAudio.gainNode.gain.cancelScheduledValues(now);
                        backgroundAudio.gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
                    } catch(e) { backgroundAudio.gainNode.gain.value = 0; }
                }
                // Pause movie audio if playing
                if (currentAudio && !currentAudio.paused) {
                    currentAudio.pause();
                }
            }
        };

        function updatePlayPauseButton() {
            const btn = document.getElementById('audio-play-btn');
            if (!btn) return;
            if (!currentAudio) {
                btn.textContent = '‚èØÔ∏è Play';
                return;
            }
            btn.textContent = currentAudio.paused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pause';
        }

        window.togglePlayPause = () => {
            if (!currentAudio) {
                updatePlayPauseButton();
                return;
            }

            if (currentAudio.paused) {
                if (!soundEnabled) {
                    window.toggleSound();
                }
                currentAudio.play().then(() => {
                    updatePlayPauseButton();
                }).catch(() => {
                    updatePlayPauseButton();
                });
            } else {
                currentAudio.pause();
                updatePlayPauseButton();
            }
        };

        window.skipAudio = (seconds) => {
            if (!currentAudio || Number.isNaN(currentAudio.currentTime)) return;
            const duration = Number.isFinite(currentAudio.duration) ? currentAudio.duration : null;
            const newTime = currentAudio.currentTime + seconds;
            if (duration !== null && duration > 0) {
                currentAudio.currentTime = Math.min(Math.max(newTime, 0), Math.max(duration - 0.1, 0));
            } else {
                currentAudio.currentTime = Math.max(newTime, 0);
            }
        };

        // Function to update moon orbit visibility based on focused planet
        function updateMoonOrbitVisibility() {
            moonOrbitPaths.forEach(moonOrbitData => {
                const shouldShowMoonOrbit = orbitsVisible && focusedObject && 
                    focusedObject.userData.isPlanet && 
                    moonOrbitData.parentPlanet === focusedObject;
                moonOrbitData.path.visible = shouldShowMoonOrbit;
            });
        }

        window.toggleOrbits = () => {
            orbitsVisible = !orbitsVisible;
            const btn = document.getElementById('orbits-btn');
            btn.textContent = orbitsVisible ? 'ü™ê Hide Orbits' : 'ü™ê Show Orbits';
            
            // Toggle planet orbits (always visible when orbits are on)
            orbitPaths.forEach(path => {
                path.visible = orbitsVisible;
            });
            
            // Toggle moon orbits (only visible when orbits are on AND a planet is focused)
            moonOrbitPaths.forEach(moonOrbitData => {
                const shouldShowMoonOrbit = orbitsVisible && focusedObject && 
                    focusedObject.userData.isPlanet && 
                    moonOrbitData.parentPlanet === focusedObject;
                moonOrbitData.path.visible = shouldShowMoonOrbit;
            });
        };

        // === PDF GENERATION ===
        window.generatePDF = async (theme) => {
            const modal = document.getElementById('pdf-modal');
            const originalText = modal.innerHTML;
            modal.innerHTML = '<div style="color:white;text-align:center">Generating PDF...<br>Please wait.</div>';
            
            // Allow UI to update
            await new Promise(r => setTimeout(r, 100));
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const PAGE_WIDTH = doc.internal.pageSize.getWidth();
            const PAGE_HEIGHT = doc.internal.pageSize.getHeight();
            const margin = 25;
            const contentWidth = PAGE_WIDTH - (margin * 2);
            
            // Helper to strip emojis and non-standard chars to prevent junk characters
            const safeText = (text) => {
                if (!text) return "";
                // Remove common emoji ranges and symbols that might break standard PDF fonts
                return text.replace(/[\u{1F600}-\u{1F6FF}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F900}-\u{1F9FF}\u{1F004}\u{1F0CF}\u{1F170}-\u{1F251}\u{1F000}-\u{1F02F}]/gu, '')
                           .replace(/[^\x00-\x7F\u0080-\u00FF\u2010-\u2015\u2022]/g, " ") // Keep basic latin, accents, dashes, bullets
                           .replace(/\s+/g, ' ')
                           .trim();
            };

            // Load Profile Image safely
            let profileImg = null;
            try {
                profileImg = await new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => resolve(img);
                    img.onerror = () => {
                        console.warn("Profile image failed to load (likely CORS). Continuing without it.");
                        resolve(null);
                    };
                    img.src = 'assets/images/Profile.jpg';
                });
            } catch (e) {
                console.warn("Image load error", e);
            }

            // Theme Config
            const isSpace = theme === 'space';
            const colors = isSpace ? {
                bg: [5, 5, 12], // Deep Space
                text: [240, 240, 255],
                accent: [56, 189, 248], // Cyan
                secondary: [148, 163, 184],
                line: [30, 41, 59]
            } : {
                bg: [255, 255, 255],
                text: [40, 40, 40],
                accent: [41, 128, 185], // Professional Blue
                secondary: [80, 80, 80],
                line: [200, 200, 200]
            };

            const titles = isSpace ? {
                summary: "MISSION OBJECTIVE & PROFILE",
                experience: "FLIGHT LOG & MISSION HISTORY",
                skills: "OPERATIONAL SUBSYSTEMS",
                projects: "DEPLOYED MISSION PAYLOADS",
                education: "ACADEMIC & TRAINING DATA"
            } : {
                summary: "SUMMARY",
                experience: "PROFESSIONAL EXPERIENCE",
                skills: "SKILLS & COMPETENCIES",
                projects: "KEY PROJECTS",
                education: "EDUCATION"
            };

            // Helper to draw background
            const drawBackground = () => {
                doc.setFillColor(...colors.bg);
                doc.rect(0, 0, PAGE_WIDTH, PAGE_HEIGHT, 'F');

                // Page Border
                doc.setDrawColor(...colors.line);
                doc.setLineWidth(0.5);
                doc.rect(15, 15, PAGE_WIDTH - 30, PAGE_HEIGHT - 30, 'S');

                if (isSpace) {
                    // Stars
                    for (let i = 0; i < 150; i++) {
                        const x = Math.random() * PAGE_WIDTH;
                        const y = Math.random() * PAGE_HEIGHT;
                        const r = Math.random() * 0.3 + 0.1;
                        const brightness = Math.floor(Math.random() * 100) + 155;
                        doc.setFillColor(brightness, brightness, brightness);
                        doc.circle(x, y, r, 'F');
                    }

                    // Webb Spikes (Bright Stars)
                    for (let i = 0; i < 6; i++) {
                        const x = Math.random() * PAGE_WIDTH;
                        const y = Math.random() * PAGE_HEIGHT;
                        doc.setDrawColor(255, 255, 255);
                        doc.setLineWidth(0.1);
                        const size = 2 + Math.random() * 2;
                        doc.line(x - size, y, x + size, y);
                        doc.line(x, y - size, x, y + size);
                        doc.line(x - size*0.7, y - size*0.7, x + size*0.7, y + size*0.7);
                        doc.line(x - size*0.7, y + size*0.7, x + size*0.7, y - size*0.7);
                    }
                    
                    // Nebulae
                    const nebulaColors = [[255, 100, 100], [100, 200, 255], [200, 100, 255]];
                    for (let n = 0; n < 3; n++) {
                        const cx = Math.random() * PAGE_WIDTH;
                        const cy = Math.random() * PAGE_HEIGHT;
                        const color = nebulaColors[Math.floor(Math.random() * nebulaColors.length)];
                        doc.setFillColor(...color);
                        for (let p = 0; p < 40; p++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * 30 * Math.random();
                            const px = cx + Math.cos(angle) * dist;
                            const py = cy + Math.sin(angle) * dist;
                            if (px > 0 && px < PAGE_WIDTH && py > 0 && py < PAGE_HEIGHT) {
                                doc.circle(px, py, Math.random() * 0.5, 'F');
                            }
                        }
                    }
                }
            };

            // Initial Background
            drawBackground();

            let y = margin;

            // === HEADER ===
            // Image
            let headerTextWidth = contentWidth;
            if (profileImg) {
                const imgSize = 30;
                const imgX = PAGE_WIDTH - margin - imgSize;
                headerTextWidth = contentWidth - imgSize - 5;
                try {
                    doc.addImage(profileImg, 'JPEG', imgX, y, imgSize, imgSize);
                    doc.setDrawColor(...colors.accent);
                    doc.setLineWidth(0.5);
                    doc.rect(imgX, y, imgSize, imgSize);
                } catch (e) {
                    console.warn("Could not add image to PDF (likely tainted canvas)", e);
                }
            }

            // Name & Role
            doc.setFont(isSpace ? "courier" : "helvetica", "bold");
            doc.setFontSize(24);
            doc.setTextColor(...colors.accent);
            
            const nameLines = doc.splitTextToSize(safeText(RESUME_DATA.name).toUpperCase(), headerTextWidth);
            doc.text(nameLines, margin, y + 8);
            const nameHeight = nameLines.length * 8;
            
            doc.setFont(isSpace ? "courier" : "helvetica", "normal");
            doc.setFontSize(12);
            doc.setTextColor(...colors.text);
            const roleLines = doc.splitTextToSize(safeText(RESUME_DATA.role), headerTextWidth);
            doc.text(roleLines, margin, y + 8 + nameHeight);

            // Contact Info
            y += 25;
            doc.setFontSize(9);
            doc.setTextColor(...colors.secondary);
            
            const c = RESUME_DATA.contact;
            const contactItems = [
                c.email ? `EMAIL: ${c.email}` : null,
                c.phone ? `PHONE: ${c.phone}` : null,
                c.location ? `LOC: ${c.location}` : null,
                c.website ? `WEB: ${c.website}` : null,
                c.linkedin ? `IN: ${c.linkedin.replace(/^https?:\/\//, '')}` : null
            ].filter(Boolean);

            doc.text(contactItems.join("   |   "), margin, y);

            y += 5;
            doc.setDrawColor(...colors.line);
            doc.setLineWidth(0.5);
            doc.line(margin, y, PAGE_WIDTH - margin, y);
            y += 8;

            // === SUMMARY ===
            if (RESUME_DATA.pdfSummary || RESUME_DATA.summary) {
                doc.setFont(isSpace ? "courier" : "helvetica", "bold");
                doc.setFontSize(11);
                doc.setTextColor(...colors.accent);
                doc.text(titles.summary, margin, y);
                y += 5;
                
                doc.setFont(isSpace ? "courier" : "helvetica", "normal");
                doc.setFontSize(10);
                doc.setTextColor(...colors.text);
                const summaryText = safeText(isSpace ? (RESUME_DATA.spaceSummary || RESUME_DATA.pdfSummary) : (RESUME_DATA.pdfSummary || RESUME_DATA.summary));
                const splitSummary = doc.splitTextToSize(summaryText, contentWidth);
                doc.text(splitSummary, margin, y);
                y += splitSummary.length * 4.5 + 5;
            }

            // === SECTIONS ===
            const checkPageBreak = (currentY, needed) => {
                if (currentY + needed > PAGE_HEIGHT - margin) {
                    doc.addPage();
                    drawBackground();
                    return margin;
                }
                return currentY;
            };

            const renderSectionTitle = (title, currentY) => {
                currentY = checkPageBreak(currentY, 15);
                doc.setFont(isSpace ? "courier" : "helvetica", "bold");
                doc.setFontSize(12);
                doc.setTextColor(...colors.accent);
                
                if (!isSpace) {
                    doc.setFillColor(240, 240, 240);
                    doc.rect(margin, currentY - 4, contentWidth, 6, 'F');
                }
                
                doc.text(title.toUpperCase(), margin, currentY);
                return currentY + 8;
            };
            
            // EXPERIENCE
            const expPlanet = RESUME_DATA.planets.find(p => p.name === "Experience");
            if (expPlanet && expPlanet.moons) {
                y = renderSectionTitle(titles.experience, y);
                
                expPlanet.moons.forEach(job => {
                    const details = isSpace ? (job.spaceDetails || job.pdfDetails || job.moonDetails || {}) : (job.pdfDetails || job.moonDetails || {});
                    const company = safeText(details.company || job.name);
                    const role = safeText(details.role || "");
                    const duration = safeText(details.duration || "");
                    const location = safeText(details.location || "");

                    y = checkPageBreak(y, 15);

                    // Line 1: Company (Left) | Location (Right)
                    doc.setFont(isSpace ? "courier" : "helvetica", "bold");
                    doc.setFontSize(11);
                    doc.setTextColor(...colors.text);
                    doc.text(company, margin, y);
                    
                    doc.setFontSize(9);
                    doc.setTextColor(...colors.secondary);
                    doc.text(location, PAGE_WIDTH - margin, y, { align: "right" });
                    
                    y += 5;

                    // Line 2: Role (Left) | Duration (Right)
                    doc.setFont(isSpace ? "courier" : "helvetica", "italic");
                    doc.setFontSize(10);
                    doc.setTextColor(...colors.text);
                    doc.text(role, margin, y);

                    doc.setFont(isSpace ? "courier" : "helvetica", "normal");
                    doc.setFontSize(9);
                    doc.setTextColor(...colors.secondary);
                    doc.text(duration, PAGE_WIDTH - margin, y, { align: "right" });
                    
                    y += 6;

                    // Achievements / Responsibilities
                    doc.setFontSize(10);
                    doc.setTextColor(...colors.text);
                    
                    const items = [...(details.achievements || []), ...(details.responsibilities || [])];
                    if (items.length === 0 && job.details) {
                        items.push(...job.details.split('\n').slice(1));
                    } else if (items.length === 0 && details.description) {
                        items.push(details.description);
                    }

                    items.forEach(item => {
                        if (!item) return;
                        const cleanItem = safeText(item.replace(/^‚Ä¢\s*/, ''));
                        if (!cleanItem) return;
                        
                        const bullet = "‚Ä¢";
                        const indent = 5;
                        const textWidth = contentWidth - indent;
                        const splitText = doc.splitTextToSize(cleanItem, textWidth);
                        const blockHeight = splitText.length * 4.5;
                        
                        y = checkPageBreak(y, blockHeight);
                        doc.text(bullet, margin, y);
                        doc.text(splitText, margin + indent, y);
                        y += blockHeight + 1;
                    });
                    y += 4;
                });
            }

            // SKILLS
            const skillsPlanet = RESUME_DATA.planets.find(p => p.name === "Skills");
            if (skillsPlanet) {
                y += 2;
                y = renderSectionTitle(titles.skills, y);
                
                doc.setFontSize(10);
                doc.setTextColor(...colors.text);
                
                if (skillsPlanet.moons) {
                    skillsPlanet.moons.forEach(cat => {
                        const details = isSpace ? (cat.spaceDetails || cat.pdfDetails || cat.moonDetails || {}) : (cat.pdfDetails || cat.moonDetails || {});
                        const catTitle = safeText(details.title || cat.name);
                        
                        y = checkPageBreak(y, 10);
                        doc.setFont(undefined, "bold");
                        doc.text(catTitle, margin, y);
                        y += 5;
                        
                        doc.setFont(undefined, "normal");
                        const skills = details.skills || [];
                        skills.forEach(skill => {
                            const cleanSkill = safeText(skill);
                            const splitSkill = doc.splitTextToSize(cleanSkill, contentWidth - 10);
                            y = checkPageBreak(y, splitSkill.length * 4.5);
                            doc.text("‚Ä¢", margin + 3, y);
                            doc.text(splitSkill, margin + 8, y);
                            y += splitSkill.length * 4.5 + 1;
                        });
                        y += 3;
                    });
                }
                y += 5;
            }

            // PROJECTS
            const projPlanet = RESUME_DATA.planets.find(p => p.name === "Projects");
            if (projPlanet && projPlanet.moons) {
                y = renderSectionTitle(titles.projects, y);
                
                projPlanet.moons.forEach(proj => {
                    const details = isSpace ? (proj.spaceDetails || proj.pdfDetails || proj.moonDetails || {}) : (proj.pdfDetails || proj.moonDetails || {});
                    const title = safeText(details.title || proj.name);
                    const desc = safeText(details.description || "");
                    const impact = details.impact ? details.impact.map(i => safeText(i)).join(". ") : "";
                    
                    y = checkPageBreak(y, 15);
                    doc.setFont(undefined, "bold");
                    doc.text(title, margin, y);
                    
                    doc.setFont(undefined, "normal");
                    const fullText = `${desc} Impact: ${impact}`;
                    const split = doc.splitTextToSize(fullText, contentWidth);
                    
                    y += 4;
                    doc.text(split, margin, y);
                    y += split.length * 4 + 3;
                });
                y += 5;
            }

            // EDUCATION
            const eduPlanet = RESUME_DATA.planets.find(p => p.name === "Education");
            if (eduPlanet) {
                y = renderSectionTitle(titles.education, y);
                const d = isSpace ? (eduPlanet.spaceDetails || eduPlanet.pdfDetails || eduPlanet.details || {}) : (eduPlanet.pdfDetails || eduPlanet.details || {});
                
                y = checkPageBreak(y, 10);
                doc.setFont(undefined, "bold");
                
                const degreeLines = doc.splitTextToSize(safeText(d.degree || ""), contentWidth);
                doc.text(degreeLines, margin, y);
                y += degreeLines.length * 5;
                
                doc.setFont(undefined, "normal");
                const eduInfo = `${safeText(d.institution || "")}, ${safeText(d.location || "")} | ${safeText(d.duration || "")}`;
                const eduLines = doc.splitTextToSize(eduInfo, contentWidth);
                doc.text(eduLines, margin, y);
            }

            // Save
            doc.save(`Nur_Dawoodani_Resume_${theme}.pdf`);
            
            // Reset Modal
            modal.innerHTML = originalText;
            modal.style.display = 'none';
        };

        // Update the sky-details panel to parse structured data
        function landOnMoon(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            const data = moon.userData.moonDetails || moon.userData.details;

            titleEl.textContent = moon.userData.name;
            let html = '';

            if (typeof data === 'object' && data !== null) {
                // Handle different data structures
                if (data.company) {
                    // Experience data
                    html = `<h3>${data.company}</h3>`;
                    html += `<p><em>${data.role} | ${data.duration}</em></p>`;
                    if (data.industry) html += `<p><strong>Industry:</strong> ${data.industry}</p>`;
                    
                    if (data.achievements) {
                        html += `<p><strong>Major Achievements:</strong></p><ul>`;
                        data.achievements.forEach(achievement => {
                            html += `<li>${achievement}</li>`;
                        });
                        html += `</ul>`;
                    }
                    
                    if (data.responsibilities) {
                        html += `<p><strong>Core Responsibilities:</strong></p><ul>`;
                        data.responsibilities.forEach(resp => {
                            html += `<li>${resp}</li>`;
                        });
                        html += `</ul>`;
                    }
                    
                    if (data.products) {
                        html += `<p><strong>Shipped Products:</strong></p><ul>`;
                        data.products.forEach(product => {
                            html += `<li>${product}</li>`;
                        });
                        html += `</ul>`;
                    }
                    
                    if (data.techStack) {
                        html += `<p><strong>Tech Stack:</strong></p><ul>`;
                        data.techStack.forEach(tech => {
                            html += `<li>${tech}</li>`;
                        });
                        html += `</ul>`;
                    }
                } else if (data.title && data.skills) {
                    // Skills data
                    html = `<h3>${data.title}</h3><ul>`;
                    data.skills.forEach(skill => {
                        html += `<li>${skill}</li>`;
                    });
                    html += `</ul>`;
                } else if (data.title && data.impact) {
                    // Project data
                    html = `<h3>${data.title}</h3>`;
                    if (data.subtitle) html += `<p><strong>${data.subtitle}</strong></p>`;
                    if (data.description) html += `<p>${data.description}</p>`;
                    html += `<p><strong>Impact:</strong></p><ul>`;
                    data.impact.forEach(item => {
                        html += `<li>${item}</li>`;
                    });
                    html += `</ul>`;
                } else if (data.degree) {
                    // Education data
                    html = `<h3>EDUCATION</h3>`;
                    html += `<p><strong>${data.degree}</strong><br>${data.field}</p>`;
                    html += `<p><strong>${data.institution}</strong><br>${data.duration}</p>`;
                } else if (data.method) {
                    // Contact data
                    html = `<h3>${data.method}</h3>`;
                    if (data.link) {
                        html += `<p><a href="${data.link}" style="color:#38bdf8">${data.value}</a></p>`;
                    } else {
                        html += `<p>${data.value}</p>`;
                    }
                }
            } else {
                // Fallback for string data
                html = `<p>${data || "No details available."}</p>`;
            }

            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        function scaleModelToRadius(model, targetRadius) {
            const initialBox = new THREE.Box3().setFromObject(model);
            const initialSize = new THREE.Vector3();
            initialBox.getSize(initialSize);
            const maxDim = Math.max(initialSize.x, initialSize.y, initialSize.z) || 1;
            const scale = (targetRadius * 2) / maxDim;
            model.scale.setScalar(scale);

            const scaledBox = new THREE.Box3().setFromObject(model);
            const scaledCenter = new THREE.Vector3();
            scaledBox.getCenter(scaledCenter);
            model.position.sub(scaledCenter);
        }

        function applyModelColorSpace(model) {
            // Do nothing - use models as-is
        }

        // === BRIGHT GLOWING SUN LIKE A FIREBALL ===
        const sunGeo = new THREE.SphereGeometry(85, 256, 256);
        
        // Create a bright, glowing sun texture
        const sunTexture = createCanvasTexture(2048, 2048, (ctx, w, h) => {
            // Bright radial gradient base - much brighter colors
            const centerGrad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w/2);
            centerGrad.addColorStop(0, '#ffffff');    // Pure white center (hottest)
            centerGrad.addColorStop(0.1, '#ffffcc'); // Very bright yellow
            centerGrad.addColorStop(0.3, '#ffff66'); // Bright yellow
            centerGrad.addColorStop(0.5, '#ffcc33'); // Golden yellow
            centerGrad.addColorStop(0.7, '#ff9933'); // Orange
            centerGrad.addColorStop(0.9, '#ff6600'); // Deep orange
            centerGrad.addColorStop(1, '#ff3300');   // Red edge
            ctx.fillStyle = centerGrad;
            ctx.fillRect(0, 0, w, h);
            
            // Add bright plasma effects
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 12000; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 6 + 1;
                const intensity = Math.random() * 0.8 + 0.2;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add bright flares and hot spots
            ctx.globalCompositeOperation = 'lighter';
            for(let i = 0; i < 300; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 30 + 10;
                const intensity = Math.random() * 0.6 + 0.2;
                
                ctx.fillStyle = `rgba(255, 255, 200, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Add some darker spots for contrast (but still bright)
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 15; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 25 + 10;
                
                ctx.fillStyle = `rgba(200, 150, 100, ${Math.random() * 0.3 + 0.1})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add super bright core flares
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 80; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 15 + 3;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.9 + 0.1})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        
        // Bright emissive material that glows like a light bulb
        const sunMat = new THREE.MeshStandardMaterial({ 
            map: sunTexture,
            toneMapped: false,
            fog: false,
            transparent: false,
            emissive: 0xffffff,
            emissiveIntensity: 4.0,
            emissiveMap: sunTexture,
            metalness: 0,
            roughness: 1
        });
        
        const sun = new THREE.Group();
        sun.userData = {
            name: RESUME_DATA.name,
            role: RESUME_DATA.role,
            summary: RESUME_DATA.summary,
            isSun: true
        };
        solarSystem.add(sun);

        const sunPlaceholder = new THREE.Mesh(sunGeo, sunMat);
        sunPlaceholder.castShadow = false;
        sunPlaceholder.receiveShadow = false;
        sun.add(sunPlaceholder);

        solarModelsToLoad++;
        updateSolarLoadingOverlay();
        gltfLoader.load(
            'assets/models/the_star_sun/scene.gltf',
            (gltf) => {
                const sunModel = gltf.scene;
                applyModelColorSpace(sunModel);
                sunModel.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                scaleModelToRadius(sunModel, 85);
                sun.add(sunModel);
                sun.remove(sunPlaceholder);
                solarModelsLoaded++;
                checkSolarModelsReady();
            },
            undefined,
            (error) => {
                console.error('Error loading sun model:', error);
                solarModelsLoaded++;
                checkSolarModelsReady();
            }
        );
        
        // Add realistic sun glow effect
        const sunGlowGeo = new THREE.SphereGeometry(120, 64, 64); // Larger than sun
        const sunGlowMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                glowColor: { value: new THREE.Color(0xffaa33) }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 glowColor;
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                    intensity += sin(time * 2.0) * 0.1; // Pulsing effect
                    gl_FragColor = vec4(glowColor, intensity * 0.4);
                }
            `,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        
        const sunGlow = new THREE.Mesh(sunGlowGeo, sunGlowMat);
        sun.add(sunGlow);
        
        // Store glow material for animation
        sun.userData.glowMaterial = sunGlowMat;
        
        // Make Sun clickable
        clickableObjects.push(sun);

        // Clean bright sun without corona layers - no banding
        // Just the sun itself with enhanced brightness and glow

        // Intense sun lighting like a bright bulb
        const sunCoreLight = new THREE.PointLight(0xffffff, 60, 3500);
        sunCoreLight.position.set(0, 0, 0);
        solarSystem.add(sunCoreLight);

        const sunBrightLight = new THREE.PointLight(0xffffff, 48, 3000);
        sunBrightLight.position.set(0, 0, 0);
        solarSystem.add(sunBrightLight);

        const sunWarmLight = new THREE.PointLight(0xffffff, 36, 2500);
        sunWarmLight.position.set(0, 0, 0);
        solarSystem.add(sunWarmLight);

        const sunAmbientLight = new THREE.PointLight(0xffffff, 18, 2000);
        sunAmbientLight.position.set(0, 0, 0);
        solarSystem.add(sunAmbientLight);

        // Add ambient light for overall scene brightness
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        createLabel("NUR<br><span style='font-size:0.6em; opacity:0.8; color: #38bdf8;'>Business Analyst</span>", sun, true);

        // === IMPROVED STARFIELD WITH CIRCULAR STARS ===
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 10000;
        const starPositions = new Float32Array(starsCount * 3);
        const starColors = new Float32Array(starsCount * 3);
        const starSizes = new Float32Array(starsCount);

        const starColorChoices = [
            new THREE.Color(0xffffff),   // white
            new THREE.Color(0xffffcc),   // yellow
            new THREE.Color(0xccccff),   // blue
            new THREE.Color(0xffcccc),   // red
            new THREE.Color(0xccffcc),   // green
            new THREE.Color(0xffccdd),   // pink
            new THREE.Color(0xccffff),   // cyan
            new THREE.Color(0xffffaa)    // pale yellow
        ];

        for(let i = 0; i < starsCount; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 4000;
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 4000;
            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 4000;

            const col = starColorChoices[Math.floor(Math.random() * starColorChoices.length)];
            starColors[i * 3] = col.r;
            starColors[i * 3 + 1] = col.g;
            starColors[i * 3 + 2] = col.b;

            starSizes[i] = Math.random() * 2.5 + 0.8;
        }

        starsGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starsGeo.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        starsGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

        const starsMat = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.9,
            fog: false,
            alphaTest: 0.5
        });

        const starTexture = new THREE.CanvasTexture((() => {
            const cvs = document.createElement('canvas');
            cvs.width = 64;
            cvs.height = 64;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(32, 32, 20, 0, Math.PI * 2);
            ctx.fill();
            return cvs;
        })());

        starsMat.map = starTexture;
        const starMesh = new THREE.Points(starsGeo, starsMat);
        starMesh.layers.set(0);
        scene.add(starMesh);

        // === ADDITIONAL STARFIELD FOR NUR WARS CRAWL AREA ===
        // Create stars in upper region where camera pans for opening crawl
        const upperStarsGeo = new THREE.BufferGeometry();
        const upperStarsCount = 8000;
        const upperStarPositions = new Float32Array(upperStarsCount * 3);
        const upperStarColors = new Float32Array(upperStarsCount * 3);
        const upperStarSizes = new Float32Array(upperStarsCount);

        for(let i = 0; i < upperStarsCount; i++) {
            // Position stars in upper region (Y: 10000 to 20000)
            upperStarPositions[i * 3] = (Math.random() - 0.5) * 8000;
            upperStarPositions[i * 3 + 1] = Math.random() * 10000 + 10000; // Y between 10000-20000
            upperStarPositions[i * 3 + 2] = (Math.random() - 0.5) * 8000;

            const col = starColorChoices[Math.floor(Math.random() * starColorChoices.length)];
            upperStarColors[i * 3] = col.r;
            upperStarColors[i * 3 + 1] = col.g;
            upperStarColors[i * 3 + 2] = col.b;

            upperStarSizes[i] = Math.random() * 2.5 + 0.8;
        }

        upperStarsGeo.setAttribute('position', new THREE.BufferAttribute(upperStarPositions, 3));
        upperStarsGeo.setAttribute('color', new THREE.BufferAttribute(upperStarColors, 3));
        upperStarsGeo.setAttribute('size', new THREE.BufferAttribute(upperStarSizes, 1));

        const upperStarsMat = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.9,
            fog: false,
            alphaTest: 0.5,
            map: starTexture
        });

        const upperStarMesh = new THREE.Points(upperStarsGeo, upperStarsMat);
        upperStarMesh.layers.set(0);
        scene.add(upperStarMesh);
        window.upperStarMesh = upperStarMesh; // Make accessible globally for animation

        function getPlanetModelPath(planetName) {
            const name = (planetName || '').toLowerCase();
            
            // Map resume planet names to GLTF model folders
            if (name.includes('skills')) return 'assets/models/planet_of_phoenix/scene.gltf';      // Jupiter-like for Skills
            if (name.includes('experience')) return 'assets/models/lava_planet/scene.gltf';        // Mars-like for Experience
            if (name.includes('expertise')) return 'assets/models/saturn_planet/scene.gltf';       // Saturn for Expertise
            if (name.includes('projects')) return 'assets/models/dathomir/scene.gltf';             // Dathomir for Projects
            if (name.includes('education')) return 'assets/models/jupiter/scene.gltf';             // Jupiter for Education
            if (name.includes('certifications')) return 'assets/models/neptune/scene.gltf';        // Neptune for Certifications
            if (name.includes('contact')) return 'assets/models/uranus/scene.gltf';               // Uranus for Contact
            
            // Fallback for old mappings
            if (name.includes('earth')) return 'assets/models/planet_earth/scene.gltf';
            if (name.includes('saturn')) return 'assets/models/saturn_planet/scene.gltf';
            if (name.includes('uranus')) return 'assets/models/uranus/scene.gltf';
            if (name.includes('neptune')) return 'assets/models/neptune/scene.gltf';
            if (name.includes('mars')) return 'assets/models/lava_planet/scene.gltf';
            if (name.includes('venus')) return 'assets/models/planet_afroditi/scene.gltf';
            if (name.includes('jupiter')) return 'assets/models/jupiter/scene.gltf';
            
            return 'assets/models/planet/scene.gltf';
        }

        // Moon models removed - use simple procedural spheres for performance

        // === CREATE PLANETS ===
        RESUME_DATA.planets.forEach((data, idx) => {
            const config = {
                ...data,
                texture: textureMap[data.texture] || drawRed,
                inclination: data.inclination !== undefined ? data.inclination : (Math.random() * 0.4 - 0.2),
                node: data.node !== undefined ? data.node : Math.random() * Math.PI * 2,
                hasRings: data.hasRings !== undefined ? data.hasRings : false,
                eccentricity: data.eccentricity !== undefined ? data.eccentricity : 0,
                tilt: data.tilt !== undefined ? data.tilt : 0
            };

            // Orbital Plane Orientation (Node)
            const planeGroup = new THREE.Group();
            planeGroup.rotation.y = config.node;
            solarSystem.add(planeGroup);

            // Inclination Group
            const orbitGroup = new THREE.Group();
            orbitGroup.rotation.x = config.inclination;
            planeGroup.add(orbitGroup);

            // Orbit path visualization - MORE VISIBLE
            const pathGeo = new THREE.BufferGeometry();
            const pathPoints = [];
            for(let i = 0; i <= 256; i++) {
                const angle = (i / 256) * Math.PI * 2;
                const r = (config.distance * (1 - config.eccentricity * config.eccentricity)) / (1 + config.eccentricity * Math.cos(angle));
                pathPoints.push(
                    Math.cos(angle) * r,
                    0,
                    Math.sin(angle) * r
                );
            }
            pathGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pathPoints), 3));
            const pathMat = new THREE.LineBasicMaterial({ 
                color: 0xaabbff, 
                transparent: true, 
                opacity: 0.5,
                linewidth: 2
            });
            const path = new THREE.Line(pathGeo, pathMat);
            path.visible = orbitsVisible;
            orbitGroup.add(path);
            orbitPaths.push(path);

            const planetGroup = new THREE.Group();
            planetGroup.userData = { ...data, isPlanet: true };

            // Planet Pivot handles the angle (theta)
            const planetPivot = new THREE.Group();
            const initialTheta = Math.random() * Math.PI * 2;
            planetPivot.rotation.y = initialTheta;
            orbitGroup.add(planetPivot);

            // Radial Group handles the distance from sun (r)
            const radialGroup = new THREE.Group();
            planetPivot.add(radialGroup);
            
            // Axial Tilt Group
            const tiltGroup = new THREE.Group();
            tiltGroup.rotation.z = config.tilt;
            radialGroup.add(tiltGroup);

            // Planet is at 0,0,0 inside tiltGroup
            tiltGroup.add(planetGroup);
            planetGroup.position.set(0, 0, 0);

            // Calculate initial radius
            const initialR = (config.distance * (1 - config.eccentricity * config.eccentricity)) / (1 + config.eccentricity * Math.cos(initialTheta));
            radialGroup.position.x = initialR;

            // Push elliptical orbit object
            objects.push({ type: 'ellipticalOrbit', pivot: planetPivot, radial: radialGroup, a: config.distance, e: config.eccentricity, speed: config.speed, theta: initialTheta });
            objects.push({ mesh: planetGroup, speed: 0.003, type: 'rotate' });
            clickableObjects.push(planetGroup);
            backgroundObjects.push(planetGroup); // Add planet to background objects for dimming
            createLabel(data.name, planetGroup);

            // Planet model rings are included in GLTF - don't add old canvas ring

            const planetModelPath = getPlanetModelPath(data.name);
            
            solarModelsToLoad++;
            updateSolarLoadingOverlay();
            gltfLoader.load(
                planetModelPath,
                (gltf) => {
                    const planetModel = gltf.scene;
                    const isContactPlanet = data.name === 'Contact';
                    const boostContactEmissive = (material) => {
                        if (!material || !('emissive' in material)) return;
                        material.emissive.set(0x7fffd4);
                        material.emissiveIntensity = Math.max(material.emissiveIntensity || 0, 1.6);
                        material.needsUpdate = true;
                    };
                    
                    planetModel.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            if (isContactPlanet) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(boostContactEmissive);
                                } else {
                                    boostContactEmissive(child.material);
                                }
                            }
                        }
                    });
                    
                    scaleModelToRadius(planetModel, config.size);
                    planetGroup.add(planetModel);
                    solarModelsLoaded++;
                    checkSolarModelsReady();
                },
                undefined,
                (error) => {
                    console.error(`‚úó FAILED to load ${data.name}: ${planetModelPath}`, error);
                    solarModelsLoaded++;
                    checkSolarModelsReady();
                }
            );

            // Moons
            if (data.moons) {
                data.moons.forEach((moonData, moonIdx) => {
                    // Use specific texture if defined, otherwise fallback logic
                    const texName = moonData.texture;
                    const specificTex = texName && textureMap[texName] ? createCanvasTexture(512, 512, textureMap[texName]) : null;

                    const moonGeo = new THREE.SphereGeometry(moonData.size, 64, 64);
                    const moonTexture = specificTex || createCanvasTexture(1024, 1024, drawRocky);
                    const moonMat = new THREE.MeshPhongMaterial({
                        map: moonTexture,
                        shininess: 25,
                        side: THREE.FrontSide,
                        emissive: moonData.color ? new THREE.Color(moonData.color) : new THREE.Color(0x222222),
                        emissiveIntensity: 0.15
                    });
                    const moon = new THREE.Mesh(moonGeo, moonMat);
                    moon.castShadow = true;
                    moon.receiveShadow = true;
                    moon.userData = { 
                        ...moonData, 
                        isMoon: true, 
                        parentPlanet: planetGroup,
                        name: moonData.name,
                        moonDetails: moonData.moonDetails || "",
                        renderType: moonData.renderType // Ensure renderType is preserved
                    };
                    const moonGroup = moon;

                    // Create moon pivot centered on the planet
                    const moonPivot = new THREE.Group();
                    moonPivot.position.set(0, 0, 0); // Centered on planet (inside radialGroup)
                    
                    // Create moon orbit path with different inclination and orientation
                    const moonOrbitInclination = moonData.inclination !== undefined ? moonData.inclination : (Math.random() - 0.5) * 0.6; // Use custom or random inclination
                    const moonOrbitNode = moonData.node !== undefined ? moonData.node : Math.random() * Math.PI * 2; // Use custom or random node
                    
                    // Moon orbit plane group (for inclination)
                    const moonOrbitPlaneGroup = new THREE.Group();
                    moonOrbitPlaneGroup.rotation.y = moonOrbitNode;
                    moonPivot.add(moonOrbitPlaneGroup);
                    
                    // Moon orbit inclination group
                    const moonOrbitInclinationGroup = new THREE.Group();
                    moonOrbitInclinationGroup.rotation.x = moonOrbitInclination;
                    moonOrbitPlaneGroup.add(moonOrbitInclinationGroup);
                    
                    // Create moon orbit path visualization
                    const moonPathGeo = new THREE.BufferGeometry();
                    const moonPathPoints = [];
                    const planetRadius = data.size || 10;
                    const moonRadius = moonData.size || 1;
                    const baseMoonDistance = moonData.distance || (planetRadius * 2.6);
                    const minMoonDistance = planetRadius + moonRadius + 8;
                    const separation = (moonRadius * 2.2) + 8;
                    const moonOrbitRadius = Math.max(baseMoonDistance, minMoonDistance) + (moonIdx * separation);
                    
                    // Use circular orbit so moons stay on their path
                    const moonEccentricity = 0;
                    
                    for(let i = 0; i <= 128; i++) {
                        const angle = (i / 128) * Math.PI * 2;
                        const r = moonOrbitRadius;
                        moonPathPoints.push(
                            Math.cos(angle) * r,
                            0,
                            Math.sin(angle) * r
                        );
                    }
                    
                    moonPathGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(moonPathPoints), 3));
                    
                    // Moon orbit material - different color and style from planet orbits
                    const moonPathMat = new THREE.LineBasicMaterial({ 
                        color: moonData.color || 0x88ccff, // Use moon's color or default blue
                        transparent: true, 
                        opacity: 0.4, // Slightly more transparent than planet orbits
                        linewidth: 1
                    });
                    
                    const moonOrbitPath = new THREE.Line(moonPathGeo, moonPathMat);
                    moonOrbitPath.visible = false; // Initially hidden, will be shown when planet is focused
                    moonOrbitInclinationGroup.add(moonOrbitPath);
                    
                    // Store moon orbit data for visibility control
                    moonOrbitPaths.push({
                        path: moonOrbitPath,
                        parentPlanet: planetGroup,
                        moon: moon
                    });
                    
                    radialGroup.add(moonPivot); 
                    
                    // Add moon to the inclination group instead of directly to moonPivot for proper orbital mechanics
                    moonOrbitInclinationGroup.add(moon);
                    moon.position.x = moonOrbitRadius;

                    // SLOWER MOON SPEEDS - proper orbiting
                    objects.push({ 
                        mesh: moonOrbitPlaneGroup, // Use the plane group for rotation instead of moonPivot
                        speed: moonData.speed || 0.0025, 
                        type: 'orbit',
                        isExperienceMoon: data.name === 'Experience'
                    });
                    objects.push({ mesh: moon, speed: 0.005, type: 'rotate' });
                    clickableObjects.push(moon);
                    backgroundObjects.push(moon); // Add moon to background objects for dimming
                    createLabel(moonData.name, moon);
                });
            }

            // === ADD SPACESHIP TO SKILLS PLANET ===
            if (data.name === "Skills") {
                const shipGroup = new THREE.Group();
                
                // Body
                const bodyGeo = new THREE.ConeGeometry(1.5, 6, 8);
                bodyGeo.rotateX(Math.PI / 2);
                const bodyMat = new THREE.MeshPhongMaterial({ color: 0xeeeeee, shininess: 100 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                shipGroup.add(body);

                // Wings
                const wingGeo = new THREE.BoxGeometry(4, 0.2, 2);
                const wingMat = new THREE.MeshPhongMaterial({ color: 0xff3333 });
                const wings = new THREE.Mesh(wingGeo, wingMat);
                wings.position.set(0, 0, 1);
                shipGroup.add(wings);

                // Engine glow
                const engineGeo = new THREE.SphereGeometry(0.6, 8, 8);
                const engineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const engine = new THREE.Mesh(engineGeo, engineMat);
                engine.position.set(0, 0, 3);
                shipGroup.add(engine);

                // Position relative to planet center
                shipGroup.position.set(config.size + 8, 0, 0); 
                shipGroup.rotation.y = Math.PI; // Face forward
                shipGroup.userData = { isSpaceship: true, name: "Spaceship" };
                clickableObjects.push(shipGroup);
                
                // Add to radialGroup so it moves with the planet
                radialGroup.add(shipGroup);
                
                // Animate spaceship separately if needed, but adding to planetPivot makes it orbit the planet
                // To make it orbit independently around the planet:
                const shipOrbit = new THREE.Group();
                shipOrbit.add(shipGroup);
                radialGroup.add(shipOrbit); // Add to radialGroup so it orbits the planet center independently
                objects.push({ mesh: shipOrbit, speed: 0.02, type: 'rotate' });
            }
        });

        // === INTERACTION ===
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let mouseDownPos = { x: 0, y: 0 };
        let lastWheelTime = 0;

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            if (mouseDownPos) {
                const dx = event.clientX - mouseDownPos.x;
                const dy = event.clientY - mouseDownPos.y;
                if (Math.hypot(dx, dy) > 6) {
                    isDragging = true;
                }
            }

            // Hover-target the black hole so scroll zoom moves toward it
            if (!solarSystem.userData.isSucked && !isDragging) {
                raycaster.setFromCamera(mouse, camera);
                const hoverHits = raycaster.intersectObjects([blackHoleGroup], true);
                if (hoverHits.length > 0) {
                    const targetPos = new THREE.Vector3();
                    blackHoleGroup.getWorldPosition(targetPos);
                    controls.target.copy(targetPos);
                }
            }
        });

        window.addEventListener('mousedown', (event) => {
            mouseDownPos = { x: event.clientX, y: event.clientY };
            isDragging = false;
        });

        window.addEventListener('mouseup', () => {
            setTimeout(() => {
                isDragging = false;
            }, 0);
        });

        window.addEventListener('click', (event) => onMouseClick(event));

        function onMouseClick(event) {
            if (isDragging) {
                isDragging = false;
                return;
            }
            isDragging = false;

            const skyDetails = document.getElementById('sky-details');
            if (skyDetails && skyDetails.style.display === 'block') {
                if (!skyDetails.contains(event.target)) {
                    closeSkyModal();
                    return;
                }
            }
            raycaster.setFromCamera(mouse, camera);
            // Recursive true to hit parts of the spaceship group
            const intersects = raycaster.intersectObjects(clickableObjects, true);
            
            if (intersects.length > 0) {
                // Traverse up to find the object with userData (like the spaceship group)
                let target = intersects[0].object;
                while(target.parent && !target.userData.isSpaceship && !target.userData.isPlanet && !target.userData.isMoon && !target.userData.isSun && !target.userData.isBlackHole) { 
                    target = target.parent; 
                }
                
                if (target.userData.isSun && (Date.now() - lastWheelTime) < 250) {
                    return;
                }

                if (target.userData.isBlackHole) {
                    triggerBlackHoleSuction();
                } else if (target.userData.isSpaceship) {
                    fireLasers(target);
                } else {
                    focusOnObject(target);
                }
            } else {
                // Clicked on empty space - try to go back to previous view
                const overlayPanel = document.getElementById('overlay-panel');
                
                // If modals are open, close them first
                if (skyDetails.style.display === 'block') {
                    closeSkyModal();
                } else if (overlayPanel.classList.contains('active')) {
                    closeOverlay();
                    // For overlay panel (standard moons), return to planet if we were on a moon
                    if (focusedObject && focusedObject.userData.isMoon) {
                        const parentPlanet = focusedObject.userData.parentPlanet;
                        if (parentPlanet) {
                            setTimeout(() => focusOnObject(parentPlanet), 100);
                        }
                    }
                } else {
                    // No modals open, try to go back to previous view
                    const wentBack = goToPreviousView();
                    if (!wentBack) {
                        // No previous view available, just unselect current object
                        focusedObject = null;
                        undimBackground(); // Undim background when unselecting
                        updateMoonOrbitVisibility(); // Update moon orbit visibility
                        // Don't reset view completely, just stop following
                    }
                }
            }
        }

        function triggerBlackHoleSuction() {
            // Safety check - prevent animation from starting if already sucked in
            if (solarSystem.userData.isSucked) {
                console.log('Animation already in progress, ignoring click');
                return;
            }
            solarSystem.userData.isSucked = true;

            const blackHoleWorldPos = new THREE.Vector3();
            blackHoleGroup.getWorldPosition(blackHoleWorldPos);

            const uiLayer = document.getElementById('ui-layer');
            uiLayer.style.display = 'none';
            
            // Hide all buttons during animation
            const buttons = document.querySelectorAll('.hud-btn');
            buttons.forEach(btn => btn.style.display = 'none');

            // Disable controls during animation
            controls.enabled = false;

            // Stop current audio and play blackhole audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
            }
            
            // Show controls container and mute button for blackhole audio control
            const controlsContainer = document.getElementById('battle-video-controls');
            if (controlsContainer) {
                controlsContainer.style.display = 'flex';
                controlsContainer.style.opacity = '1';
            }
            const muteBtn = document.getElementById('video-mute-btn');
            if (muteBtn) {
                muteBtn.style.display = 'block';
                muteBtn.textContent = 'üîä'; // Start with sound on
            }
            
            // Create and play blackhole audio
            const blackholeAudio = new Audio('assets/audio/black%20hole%20sound.mp3');
            blackholeAudio.loop = true;
            blackholeAudio.volume = 0.4;
            // Set currentAudio so mute controls work with blackhole audio
            currentAudio = blackholeAudio;
            
            // Attempt to play with gesture-based resume if needed
            blackholeAudio.play().catch(err => {
                console.log('Blackhole audio auto-play blocked, waiting for user gesture');
                // Will play on next user interaction
            });
            
            // Store reference for cleanup if needed
            window.currentBlackholeAudio = blackholeAudio;

            blackHoleGroup.scale.set(1, 1, 1);

            // Get initial sun position (relative to solar system)
            const initialSunWorldPos = new THREE.Vector3();
            sun.getWorldPosition(initialSunWorldPos);

            // Calculate direction from sun to black hole
            const directionToHole = blackHoleWorldPos.clone().sub(initialSunWorldPos).normalize();

            // Position camera to see both sun (fully visible) and black hole centered on screen
            // Camera positioned perpendicular to the sun-to-black-hole line for best view
            const distanceBehind = 500;
            const verticalOffset = 70; // Center camera at midpoint height between sun and black hole
            const targetCameraPos = initialSunWorldPos.clone().add(directionToHole.clone().multiplyScalar(-distanceBehind)).add(new THREE.Vector3(0, verticalOffset, 0));

            // Smooth transition to camera position behind the sun
            const transitionDuration = 2.0;
            gsap.to(camera.position, {
                x: targetCameraPos.x,
                y: targetCameraPos.y,
                z: targetCameraPos.z,
                duration: transitionDuration,
                ease: 'sine.inOut'
            });

            // Look at midpoint between sun and black hole to keep both centered on screen
            const lookAtPoint = initialSunWorldPos.clone().add(blackHoleWorldPos).multiplyScalar(0.5);
            gsap.to(controls.target, {
                x: lookAtPoint.x,
                y: lookAtPoint.y,
                z: lookAtPoint.z,
                duration: transitionDuration,
                ease: 'sine.inOut'
            });

            const totalDuration = 107.822; // Main animation starts after transition (10% slower from 98.02)

            // After transition, start the suction animation
            setTimeout(() => {
                // Animate solar system moving towards black hole
                activeSuctionAnimations.position = gsap.to(solarSystem.position, {
                    x: blackHoleWorldPos.x,
                    y: blackHoleWorldPos.y,
                    z: blackHoleWorldPos.z,
                    duration: totalDuration,
                    ease: 'sine.inOut',
                    onUpdate: () => {
                        // Check if reset was called
                        if (stopSuctionAnimation) {
                            this.kill();
                            return;
                        }
                        
                        // Every frame, keep camera positioned to see both sun and black hole centered
                        const sunWorldPos = new THREE.Vector3();
                        sun.getWorldPosition(sunWorldPos);
                        
                        // Calculate current direction to black hole
                        const currentDirToHole = blackHoleWorldPos.clone().sub(sunWorldPos).normalize();
                        
                        // Keep camera at constant distance behind sun, at same height as midpoint for alignment
                        const distanceBehind = 500;
                        const verticalOffset = 70; // Align camera with midpoint height
                        const newCameraPos = sunWorldPos.clone().add(currentDirToHole.clone().multiplyScalar(-distanceBehind)).add(new THREE.Vector3(0, verticalOffset, 0));
                        camera.position.copy(newCameraPos);
                        
                        // Look at midpoint between sun and black hole to keep both centered on screen
                        const midpoint = sunWorldPos.clone().add(blackHoleWorldPos).multiplyScalar(0.5);
                        controls.target.copy(midpoint);
                    },
                    onComplete: () => {
                        controls.enabled = true;
                        stopSuctionAnimation = false;
                    }
                });

                // Black hole grows at 10% faster rate - 33.745 seconds (37.12 / 1.1)
                activeSuctionAnimations.scale = gsap.to(blackHoleGroup.scale, {
                    x: 26.0,
                    y: 26.0,
                    z: 26.0,
                    duration: 33.745,
                    ease: 'sine.inOut',
                    onUpdate: () => {
                        // Check if reset was called
                        if (stopSuctionAnimation) {
                            this.kill();
                        }
                    }
                });

                // Solar system spins as it's pulled in
                activeSuctionAnimations.rotation = gsap.to(solarSystem.rotation, {
                    y: solarSystem.rotation.y + Math.PI * 8,
                    duration: totalDuration,
                    ease: 'sine.inOut'
                });

                // Shrink and fade at the very end
                gsap.to(solarSystem.scale, {
                    x: 0.001,
                    y: 0.001,
                    z: 0.001,
                    duration: totalDuration * 0.15,
                    delay: totalDuration * 0.85,
                    ease: 'sine.inOut',
                    onComplete: () => {
                        solarSystem.visible = false;
                        blackHoleOverlay.style.display = 'block';
                        document.body.classList.add('labels-hidden');
                        // Reload page immediately when screen goes all black
                        window.location.reload();
                    }
                });
            }, transitionDuration * 1000);
        }

        // Double Click to Zoom
        window.addEventListener('dblclick', () => {
            if (isMobile) return;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects, true);
            
            if (intersects.length > 0) {
                let target = intersects[0].object;
                while(target.parent && !target.userData.isSpaceship && !target.userData.isPlanet && !target.userData.isMoon && !target.userData.isSun) { 
                    target = target.parent; 
                }
                focusOnObject(target);
            } else {
                // Zoom into empty space (move forward)
                const direction = new THREE.Vector3();
                raycaster.ray.direction.clone(direction);
                const moveDistance = 50;
                const newPos = camera.position.clone().add(direction.multiplyScalar(moveDistance));
                const newTarget = controls.target.clone().add(direction); // Keep target relative
                
                gsap.to(camera.position, { x: newPos.x, y: newPos.y, z: newPos.z, duration: 1.2 });
                gsap.to(controls.target, { x: newTarget.x, y: newTarget.y, z: newTarget.z, duration: 1.2 });
            }
        });

        // === BACKGROUND DIMMING SYSTEM ===
        function getDimmableMeshes(obj) {
            const meshes = [];
            if (!obj) return meshes;
            obj.traverse(child => {
                if (child.isMesh && child.material) {
                    meshes.push(child);
                }
            });
            return meshes;
        }

        function dimBackground(focusedPlanet) {
            if (backgroundDimming) return; // Already dimmed
            
            backgroundDimming = true;
            
            // Dim all objects except the focused planet and its moons
            backgroundObjects.forEach(obj => {
                if (obj === focusedPlanet) return; // Don't dim the focused planet
                
                // Don't dim moons of the focused planet
                if (obj.userData.isMoon && obj.userData.parentPlanet === focusedPlanet) return;
                
                const meshes = getDimmableMeshes(obj);
                if (meshes.length === 0) return;
                
                // Different dimming levels: planets vs moons of other planets
                let dimFactor, opacityFactor;
                if (obj.userData.isMoon) {
                    // Moons of other planets: make them nearly invisible (like real space)
                    dimFactor = 0.02; // Very dim
                    opacityFactor = 0.05; // Nearly transparent
                } else {
                    // Other planets: dim but still visible (no transparency)
                    dimFactor = 0.08; // Dim but visible
                    opacityFactor = 1.0; // Keep opaque
                }

                meshes.forEach(mesh => {
                    const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];

                    if (!mesh.userData.originalMaterial) {
                        mesh.userData.originalMaterial = materials.map(mat => ({
                            emissive: mat.emissive ? mat.emissive.clone() : null,
                            emissiveIntensity: typeof mat.emissiveIntensity === 'number' ? mat.emissiveIntensity : null,
                            opacity: typeof mat.opacity === 'number' ? mat.opacity : 1.0,
                            transparent: !!mat.transparent
                        }));
                    }

                    materials.forEach((mat, idx) => {
                        const original = mesh.userData.originalMaterial[idx];
                        if (mat.emissive && original && original.emissive) {
                            gsap.to(mat.emissive, {
                                r: original.emissive.r * dimFactor,
                                g: original.emissive.g * dimFactor,
                                b: original.emissive.b * dimFactor,
                                duration: 1.0
                            });
                        }

                        if (typeof mat.emissiveIntensity === 'number' && original && original.emissiveIntensity !== null) {
                            gsap.to(mat, {
                                emissiveIntensity: original.emissiveIntensity * dimFactor,
                                duration: 1.0
                            });
                        }

                        if (obj.userData.isMoon) {
                            if (!mat.transparent) {
                                mat.transparent = true;
                            }
                            gsap.to(mat, {
                                opacity: (original ? original.opacity : 1.0) * opacityFactor,
                                duration: 1.0
                            });
                        } else {
                            if (mat.transparent) {
                                mat.transparent = false;
                            }
                            gsap.to(mat, {
                                opacity: 1.0,
                                duration: 0.5
                            });
                        }
                    });
                });
            });
            
            // Also dim labels of background objects
            labels.forEach(labelItem => {
                const obj = labelItem.object;
                if (obj === focusedPlanet) return; // Don't dim focused planet label
                if (obj.userData.isMoon && obj.userData.parentPlanet === focusedPlanet) return; // Don't dim focused planet's moon labels
                
                // Store original label opacity if not stored
                if (!labelItem.originalOpacity) {
                    labelItem.originalOpacity = parseFloat(window.getComputedStyle(labelItem.div).opacity) || 1.0;
                }
                
                // Dim labels of background objects
                let labelOpacity;
                if (obj.userData.isMoon) {
                    labelOpacity = 0.1; // Very dim for background moons
                } else {
                    labelOpacity = 0.3; // Dim for background planets
                }
                
                gsap.to(labelItem.div, {
                    opacity: labelOpacity,
                    duration: 1.0
                });
            });
        }
        
        function undimBackground() {
            if (!backgroundDimming) return; // Not dimmed
            
            backgroundDimming = false;
            
            // Restore all objects to their original brightness
            backgroundObjects.forEach(obj => {
                const meshes = getDimmableMeshes(obj);
                if (meshes.length === 0) return;

                meshes.forEach(mesh => {
                    if (!mesh.userData.originalMaterial) return;
                    const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];

                    materials.forEach((mat, idx) => {
                        const original = mesh.userData.originalMaterial[idx];
                        if (!original) return;

                        if (mat.emissive && original.emissive) {
                            gsap.to(mat.emissive, {
                                r: original.emissive.r,
                                g: original.emissive.g,
                                b: original.emissive.b,
                                duration: 1.0
                            });
                        }

                        gsap.to(mat, {
                            emissiveIntensity: original.emissiveIntensity !== null ? original.emissiveIntensity : mat.emissiveIntensity,
                            opacity: original.opacity,
                            duration: 1.0
                        });
                    });
                });
            });
            
            // Restore all labels to their original opacity
            labels.forEach(labelItem => {
                if (labelItem.originalOpacity !== undefined) {
                    gsap.to(labelItem.div, {
                        opacity: labelItem.originalOpacity,
                        duration: 1.0
                    });
                }
            });
        }

        // === INTERACTION HELPERS & OVERLAY ===
        // add focus / overlay functions (show moon surface + details)
        function focusOnObject(object) {
            // Save current view before changing (unless it's the same object)
            if (object !== focusedObject) {
                saveCurrentView();
            }
            
        	if (object && object.userData && (object.userData.isSun || object.userData.viewType === 'center')) {
                focusedObject = null; // Disable auto-tracking for Center view
                undimBackground(); // Undim background when focusing on sun
                updateMoonOrbitVisibility(); // Update moon orbit visibility

                if (!isCenterView) {
                    previousCameraPos.copy(camera.position);
                    previousTarget.copy(controls.target);
                }
                
                const title = object.userData.isSun ? RESUME_DATA.name : object.userData.name;
                const content = object.userData.isSun ? RESUME_DATA.summary : object.userData.details;
                const subTitle = object.userData.isSun ? RESUME_DATA.role : "";

                showCenterProfile(title, subTitle, content, object.userData.isSun);
                
                isCenterView = true;
                controls.enableZoom = false;
                controls.maxDistance = 20; 
                controls.minDistance = 0.1;

                // Move camera to object center
                const targetPos = new THREE.Vector3();
                object.getWorldPosition(targetPos);
                
                gsap.to(camera.position, { x: targetPos.x, y: targetPos.y, z: targetPos.z + 1, duration: 1.5 });
                gsap.to(controls.target, { x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 1.5 });
                return;
            }

        	focusedObject = object;
        	updateMoonOrbitVisibility(); // Update moon orbit visibility when focusing on any object
        	
        	if (object && object.userData && (object.userData.isMoon || object.userData.isPlanet)) {
        		showMoonDetails(object);
        	} else {
                // Hide sky details if not a moon
                document.getElementById('sky-details').style.display = 'none';
                // Show side panel for planets
                if (object && object.userData && object.userData.isPlanet) {
                    showMoonDetails(object); // Reuse this for planets too if needed, or keep existing behavior
                }
        	}

        	// Ensure controls target will follow the object continuously
        	if (object) {
        		// Get world position for initial targeting
        		const targetPos = new THREE.Vector3();
        		object.getWorldPosition(targetPos);
        		
                // If it's a moon, zoom in close and don't dim background
                if (object.userData.isMoon) {
                    undimBackground(); // Undim when focusing on moon
                    const offset = new THREE.Vector3(object.geometry.parameters.radius * 4, 2, 2);
                    const camPos = targetPos.clone().add(offset);
                    gsap.to(camera.position, { x: camPos.x, y: camPos.y, z: camPos.z, duration: 1.5 });
                }
                // If it's a planet, zoom in comfortably to see moons and dim background
                else if (object.userData.isPlanet) {
                    dimBackground(object); // Dim background when focusing on planet
                    const dist = (object.userData.size || 5) * 3 + 15;
                    const currentDir = camera.position.clone().sub(targetPos).normalize();
                    const newPos = targetPos.clone().add(currentDir.multiplyScalar(dist));
                    
                    gsap.to(camera.position, { x: newPos.x, y: newPos.y, z: newPos.z, duration: 1.5 });
                }
                
                // Set initial target but don't animate it - let the animation loop handle continuous following
                controls.target.copy(targetPos);
        	}
        }

        function showCenterProfile(title, subTitle, content, isSun) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            titleEl.textContent = title;
            
            let html = `
                <div style="display: flex; flex-direction: column; height: 100%; max-height: 100%;">
                    ${isSun ? `
                    <!-- Profile Header -->
                    <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 15px; flex-shrink: 0;">
                        <img src="${RESUME_DATA.profileImage}" style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid #38bdf8; object-fit: cover; animation: pulseGlow 3s ease-in-out infinite; margin-right: 15px;">
                        <div style="text-align: left;">
                            <h3 style="color: #38bdf8; margin: 0 0 3px 0; font-size: 20px;">${subTitle}</h3>
                            <div style="color: #94a3b8; font-size: 12px;">Business Analyst</div>
                        </div>
                    </div>
                    
                    <!-- Contact Info Grid -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 8px; margin-bottom: 15px; flex-shrink: 0;">
                        <div style="background: rgba(255,255,255,0.05); padding: 6px 10px; border-radius: 6px; font-size: 11px;">
                            <strong>üìß</strong> <a href="mailto:${RESUME_DATA.contact.email}" style="color: #38bdf8; text-decoration: none;">${RESUME_DATA.contact.email}</a>
                        </div>
                        <div style="background: rgba(255,255,255,0.05); padding: 6px 10px; border-radius: 6px; font-size: 11px;">
                            <strong>üì±</strong> ${RESUME_DATA.contact.phone}
                        </div>
                        <div style="background: rgba(255,255,255,0.05); padding: 6px 10px; border-radius: 6px; font-size: 11px;">
                            <strong>üìç</strong> ${RESUME_DATA.contact.location}
                        </div>
                        <div style="background: rgba(255,255,255,0.05); padding: 6px 10px; border-radius: 6px; font-size: 11px;">
                            <strong>üîó</strong> <a href="https://${RESUME_DATA.contact.linkedin}" target="_blank" style="color: #38bdf8; text-decoration: none;">LinkedIn</a>
                        </div>
                    </div>
                    ` : ''}
                    
                    <!-- Summary Content -->
                    <div style="flex: 1; background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px; overflow: hidden; min-height: 0;">
                        ${isSun ? '<h4 style="color: #e2e8f0; margin: 0 0 12px 0; text-align: center; font-size: 16px;">Professional Summary</h4>' : ''}
                        <p style="line-height: 1.5; color: #cbd5e1; text-align: ${isSun ? 'left' : 'center'}; font-size: ${isSun ? '13px' : '16px'}; margin: 0; overflow: hidden; display: -webkit-box; -webkit-line-clamp: ${isSun ? '8' : '6'}; -webkit-box-orient: vertical;">${content}</p>
                    </div>
                    
                    ${isSun ? `
                    <!-- Quick Stats -->
                    <div style="display: flex; justify-content: space-around; margin-top: 12px; flex-shrink: 0;">
                        <div style="text-align: center;">
                            <div style="color: #38bdf8; font-size: 16px; font-weight: bold;">18+</div>
                            <div style="color: #94a3b8; font-size: 9px;">Years Experience</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #38bdf8; font-size: 16px; font-weight: bold;">4</div>
                            <div style="color: #94a3b8; font-size: 9px;">Languages</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #38bdf8; font-size: 16px; font-weight: bold;">10+</div>
                            <div style="color: #94a3b8; font-size: 9px;">Major Projects</div>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Enhanced modal system for all planets
        function showMoonDetails(moon) {
            const parentPlanet = moon.userData.parentPlanet;
            const parentName = parentPlanet && parentPlanet.userData ? parentPlanet.userData.name : '';
            const moonName = moon.userData.name || 'Moon';
            
            // Check if this is a special moon that needs enhanced modal
            const isLanguagesMoon = moon.userData.renderType === 'languages' || moonName === 'Languages';
            const isEducationMoon = parentName === 'Education';
            const isSkillsMoon = parentName === 'Skills & Tools';
            const isExperienceMoon = parentName === 'Experience';
            const isExpertiseMoon = parentName === 'Expertise & Impact';
            const isProjectsMoon = parentName === 'Projects';
            const isCertificationsMoon = parentName === 'Certifications';
            const isContactMoon = parentName === 'Contact';
            
            if (isLanguagesMoon || isEducationMoon) {
                showEnhancedModal(moon, parentName);
            } else if (isSkillsMoon || isCertificationsMoon) {
                showSkillsModal(moon);
            } else if (isExperienceMoon) {
                showExperienceModal(moon);
            } else if (isExpertiseMoon) {
                showExpertiseModal(moon);
            } else if (isProjectsMoon) {
                showProjectsModal(moon);
            } else if (isContactMoon) {
                showContactModal(moon);
            } else {
                showStandardModal(moon);
            }
        }

        // Enhanced modal for Languages and Education with 3D characters and maps
        function showEnhancedModal(moon, planetType) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            titleEl.textContent = moonName;
            
            let html = '';
            
            // Check if this is a Languages moon by its renderType or name
            const isLanguagesMoon = moon.userData.renderType === 'languages' || moonName === 'Languages';
            
            if (isLanguagesMoon) {
                // Check if this is the comprehensive Languages moon or individual language
                if (moon.userData.pdfDetails && moon.userData.pdfDetails.languages) {
                    // Comprehensive Languages modal showing all languages
                    const languagesData = moon.userData.pdfDetails.languages;
                    
                    html = `
                        <div style="display: flex; flex-direction: column; height: 100%; padding: 15px; overflow: hidden;">
                            <!-- Header -->
                            <div style="text-align: center; margin-bottom: 15px; flex-shrink: 0;">
                                <h2 style="color: #38bdf8; margin: 0; font-size: 20px;">üåç Languages</h2>
                                <div style="color: #94a3b8; font-size: 12px; margin-top: 3px;">Communication Capabilities</div>
                            </div>
                            
                            <!-- Languages Grid -->
                            <div class="language-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; flex: 1; overflow-y: auto; padding-right: 5px;">
                                ${languagesData.map(lang => {
                                    const heroData = createHeroFace(lang.hero || 'Einstein');
                                    return `
                                    <div style="background: rgba(56, 189, 248, 0.05); border: 1px solid rgba(56, 189, 248, 0.2); border-radius: 10px; padding: 12px; transition: all 0.3s ease; cursor: pointer; height: fit-content;" 
                                         onmouseover="this.style.transform='scale(1.02)'; this.style.background='rgba(56, 189, 248, 0.1)'; this.style.animation='languageCardGlow 2s ease-in-out infinite';" 
                                         onmouseout="this.style.transform='scale(1)'; this.style.background='rgba(56, 189, 248, 0.05)'; this.style.animation='none'; this.style.boxShadow='none';">
                                        <!-- Language Header -->
                                        <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                            <div style="margin-right: 8px; animation: ${heroData.animation}; flex-shrink: 0;">
                                                ${heroData.face}
                                            </div>
                                            <div style="flex: 1; min-width: 0;">
                                                <h3 style="color: #38bdf8; margin: 0; font-size: 14px; line-height: 1.2;">${lang.name}</h3>
                                                <div style="color: #94a3b8; font-size: 10px; margin-top: 1px;">${lang.proficiency}</div>
                                                <div style="color: #64748b; font-size: 8px; margin-top: 1px; font-style: italic; line-height: 1.1;">${heroData.description}</div>
                                            </div>
                                            <div style="background: linear-gradient(45deg, #38bdf8, #818cf8); border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 10px; color: white; font-weight: bold; flex-shrink: 0;">
                                                ${getProficiencyBadge(lang.proficiency)}
                                            </div>
                                        </div>
                                        
                                        <!-- Skills Assessment -->
                                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px;">
                                            ${['speaking', 'reading', 'writing', 'comprehension'].map((skill, index) => {
                                                const icons = ['üó£Ô∏è', 'üìñ', '‚úçÔ∏è', 'üëÇ'];
                                                const labels = ['Speaking', 'Reading', 'Writing', 'Listening'];
                                                const score = lang.skills[skill] || 5;
                                                const percentage = score * 10;
                                                
                                                return `
                                                <div style="background: rgba(255,255,255,0.05); border-radius: 4px; padding: 6px; text-align: center; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(255,255,255,0.1)'; this.style.transform='scale(1.05)';" onmouseout="this.style.background='rgba(255,255,255,0.05)'; this.style.transform='scale(1)';">
                                                    <div style="font-size: 10px; margin-bottom: 2px;">${icons[index]}</div>
                                                    <div style="font-size: 7px; color: #94a3b8; margin-bottom: 2px; font-weight: 600;">${labels[index].toUpperCase()}</div>
                                                    <div style="color: #38bdf8; font-weight: bold; font-size: 9px; margin-bottom: 2px;">${score}/10</div>
                                                    <div style="background: rgba(56, 189, 248, 0.2); height: 2px; border-radius: 1px; overflow: hidden;">
                                                        <div style="background: linear-gradient(90deg, #38bdf8, #818cf8); height: 100%; width: ${percentage}%; border-radius: 1px; transition: width 1s ease-in-out;"></div>
                                                    </div>
                                                </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                } else {
                    // Individual language modal (if we had individual language moons)
                    const proficiencyLevel = moon.userData.proficiencyLevel || getProficiencyLevel(moon.userData.details);
                    const heroName = moon.userData.hero || getHeroForLanguage(moonName);
                    const heroData = createHeroFace(heroName);
                    const skills = moon.userData.skills || {};
                    
                    // Extract key details from the description
                    const details = moon.userData.details || '';
                    const keyPoints = details.split('\n').filter(line => line.trim() && !line.includes('Proficiency')).slice(1, 3);
                    
                    html = `
                        <div style="display: flex; flex-direction: column; height: 100%; padding: 12px;">
                            <!-- Header with Language Name -->
                            <div style="text-align: center; margin-bottom: 12px;">
                                <h2 style="color: #38bdf8; margin: 0; font-size: 18px;">${moonName}</h2>
                                <div style="color: #94a3b8; font-size: 12px; margin-top: 2px;">${proficiencyLevel} Proficiency</div>
                            </div>
                            
                            <!-- Character and Level Section -->
                            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 15px; background: rgba(56, 189, 248, 0.05); border-radius: 10px; padding: 12px;">
                                <div style="text-align: center; margin-right: 15px; flex-shrink: 0;">
                                    <div style="animation: ${heroData.animation}; margin-bottom: 6px;">
                                        ${heroData.face}
                                    </div>
                                    <div style="color: #38bdf8; font-weight: bold; font-size: 10px;">${heroData.description}</div>
                                </div>
                                <div style="flex: 1; padding-left: 10px;">
                                    <div style="background: rgba(255,255,255,0.08); border-radius: 8px; padding: 10px; font-size: 11px; color: #e2e8f0; line-height: 1.3; border: 1px solid rgba(56, 189, 248, 0.2);">
                                        ${keyPoints.join(' ')}
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Compact Skills Assessment - Single Row -->
                            <div style="background: rgba(255,255,255,0.03); border-radius: 10px; padding: 12px; border: 1px solid rgba(56, 189, 248, 0.1);">
                                <h3 style="color: #38bdf8; margin: 0 0 10px 0; font-size: 14px; text-align: center;">Language Skills Assessment</h3>
                                <div style="display: flex; gap: 10px; justify-content: space-between;">
                                    ${['speaking', 'reading', 'writing', 'comprehension'].map((skill, index) => {
                                        const icons = ['üó£Ô∏è', 'üìñ', '‚úçÔ∏è', 'üëÇ'];
                                        const labels = ['Speaking', 'Reading', 'Writing', 'Listening'];
                                        const score = skills[skill] || parseInt(getProficiencyScore(proficiencyLevel, skill));
                                        const percentage = score * 10;
                                        
                                        return `
                                        <div style="background: rgba(56, 189, 248, 0.08); border-radius: 8px; padding: 10px; text-align: center; border: 1px solid rgba(56, 189, 248, 0.2); transition: transform 0.3s ease; flex: 1; min-width: 0;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                            <div style="font-size: 16px; margin-bottom: 4px;">${icons[index]}</div>
                                            <div style="font-size: 9px; color: #94a3b8; margin-bottom: 4px; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${labels[index].toUpperCase()}</div>
                                            <div style="color: #38bdf8; font-weight: bold; font-size: 14px; margin-bottom: 4px;">${score}/10</div>
                                            <div style="background: rgba(56, 189, 248, 0.2); height: 3px; border-radius: 2px; overflow: hidden;">
                                                <div style="background: linear-gradient(90deg, #38bdf8, #818cf8); height: 100%; width: 0%; border-radius: 2px; transition: width 1s ease-in-out 0.${index * 2}s; animation: fillBar${index} 1s ease-in-out 0.${index * 2}s forwards;"></div>
                                            </div>
                                        </div>
                                        <style>
                                            @keyframes fillBar${index} {
                                                from { width: 0%; }
                                                to { width: ${percentage}%; }
                                            }
                                        </style>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                }
            } else if (planetType === 'Education') {
                // Compact Education Modal with side-by-side layout
                const institution = moon.userData.institution || '';
                const degree = moon.userData.degree || '';
                const field = moon.userData.field || '';
                const duration = moon.userData.duration || '';
                const location = moon.userData.location || '';
                const achievements = moon.userData.achievements || [];
                
                html = `
                    <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                        <!-- Header with Icon and Basic Info -->
                        <div style="display: flex; align-items: center; margin-bottom: 15px;">
                            <div style="font-size: 50px; margin-right: 15px; animation: charHover 3s infinite ease-in-out;">üéì</div>
                            <div style="flex: 1;">
                                <h3 style="color: #38bdf8; margin: 0 0 5px 0; font-size: 20px;">${degree}</h3>
                                <p style="color: #e2e8f0; margin: 0 0 3px 0; font-size: 16px;">${field}</p>
                                <p style="color: #94a3b8; margin: 0; font-size: 14px;">${duration} ‚Ä¢ ${location}</p>
                            </div>
                        </div>
                        
                        <!-- Main Content: Two Columns -->
                        <div style="display: flex; gap: 15px; flex: 1; min-height: 0;">
                            <!-- Left Column: Institution & Achievements -->
                            <div style="flex: 1; display: flex; flex-direction: column;">
                                <div style="background: rgba(56, 189, 248, 0.1); border: 1px solid rgba(56, 189, 248, 0.3); border-radius: 10px; padding: 12px; margin-bottom: 12px;">
                                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                        <span style="font-size: 16px; margin-right: 8px;">üèõÔ∏è</span>
                                        <span style="color: #38bdf8; font-weight: bold; font-size: 15px;">${institution}</span>
                                    </div>
                                </div>
                                
                                ${achievements.length > 0 ? `
                                <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 12px; flex: 1; overflow: hidden;">
                                    <h4 style="color: #38bdf8; margin: 0 0 10px 0; font-size: 15px; display: flex; align-items: center;">
                                        <span style="margin-right: 6px;">üèÜ</span>
                                        Highlights
                                    </h4>
                                    <div style="color: #e2e8f0; font-size: 12px; line-height: 1.4; text-align: left; max-height: 200px; overflow: hidden;">
                                        ${achievements.slice(0, 4).map(achievement => `
                                            <div style="display: flex; align-items: flex-start; margin-bottom: 6px; padding: 4px 0; text-align: left;">
                                                <span style="color: #38bdf8; margin-right: 6px; margin-top: 1px; flex-shrink: 0;">‚Ä¢</span>
                                                <span style="flex: 1; text-align: left;">${achievement}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                            
                            <!-- Right Column: Map or Details -->
                            ${moon.userData.mapQuery ? `
                            <div style="flex: 1; display: flex; flex-direction: column;">
                                <div style="background: rgba(56, 189, 248, 0.1); border: 1px solid rgba(56, 189, 248, 0.3); border-radius: 10px; overflow: hidden; flex: 1;">
                                    <div style="background: rgba(56, 189, 248, 0.2); padding: 10px; text-align: center; color: #38bdf8; font-weight: bold; font-size: 14px;">
                                        üìç Location
                                    </div>
                                    <iframe width="100%" height="100%" frameborder="0" style="border:0; filter: hue-rotate(200deg) saturate(0.8); min-height: 180px;" 
                                        src="https://maps.google.com/maps?q=${encodeURIComponent(moon.userData.mapQuery)}&t=&z=15&ie=UTF8&iwloc=&output=embed">
                                    </iframe>
                                </div>
                            </div>
                            ` : `
                            <div style="flex: 1; background: rgba(255,255,255,0.05); border-radius: 10px; padding: 12px; overflow: hidden;">
                                <div style="color: #e2e8f0; font-size: 12px; line-height: 1.4; max-height: 200px; overflow: hidden;">
                                    ${moon.userData.details ? moon.userData.details.split('\n').slice(2).join('\n') : ''}
                                </div>
                            </div>
                            `}
                        </div>
                    </div>
                `;
            }
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Skills modal for Skills & Tools planet moons
        function showSkillsModal(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            const pdfDetails = moon.userData.pdfDetails || {};
            
            titleEl.textContent = moonName;
            
            let html = '';
            
            if (pdfDetails.skills) {
                // Enhanced Skills Moon Modal
                html = `
                    <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                        <div style="background: rgba(56, 189, 248, 0.1); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <h3 style="color: #38bdf8; margin: 0 0 10px 0; font-size: 22px;">${pdfDetails.title}</h3>
                            <p style="color: #94a3b8; margin: 0 0 15px 0; font-size: 16px;">${pdfDetails.description}</p>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; flex: 1;">
                            <h4 style="color: #38bdf8; margin: 0 0 15px 0; font-size: 18px; display: flex; align-items: center;">
                                <span style="margin-right: 8px;">üõ†Ô∏è</span>
                                Skills & Tools
                            </h4>
                            <div style="display: grid; gap: 8px; max-height: 400px; overflow-y: auto;">
                                ${pdfDetails.skills.map(skill => `
                                    <div style="display: flex; align-items: center; padding: 10px 15px; background: rgba(56, 189, 248, 0.08); border-radius: 8px; border: 1px solid rgba(56, 189, 248, 0.2); transition: transform 0.2s ease;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                                        <span style="color: #38bdf8; margin-right: 10px; font-size: 16px;">‚Ä¢</span>
                                        <span style="color: #e2e8f0; font-size: 15px; line-height: 1.4;">${skill}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Fallback for skills moons without detailed data
                html = `
                    <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                        <div style="background: rgba(56, 189, 248, 0.1); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <h3 style="color: #38bdf8; margin: 0 0 10px 0; font-size: 22px;">${moonName}</h3>
                            <p style="color: #94a3b8; margin: 0; font-size: 16px;">Skills and capabilities in this area</p>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; flex: 1;">
                            <div style="color: #e2e8f0; font-size: 16px; line-height: 1.6;">
                                ${moon.userData.details || moon.userData.moonDetails || 'Detailed information about this skill area.'}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Projects modal for Projects planet moons
        function showProjectsModal(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            const pdfDetails = moon.userData.pdfDetails || {};
            
            titleEl.textContent = moonName;
            
            let html = `
                <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                    <div style="background: rgba(231, 76, 60, 0.1); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <h3 style="color: #e74c3c; margin: 0 0 10px 0; font-size: 22px;">${pdfDetails.title || moonName}</h3>
                        <p style="color: #94a3b8; margin: 0 0 15px 0; font-size: 16px;">${pdfDetails.subtitle || 'Project Initiative'}</p>
                        <p style="color: #e2e8f0; margin: 0; font-size: 15px; line-height: 1.5;">${pdfDetails.description || 'Major project initiative with significant business impact.'}</p>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; flex: 1;">
                        <h4 style="color: #e74c3c; margin: 0 0 15px 0; font-size: 18px; display: flex; align-items: center;">
                            <span style="margin-right: 8px;">üéØ</span>
                            Impact & Results
                        </h4>
                        <div style="display: grid; gap: 8px; max-height: 300px; overflow-y: auto;">
                            ${(pdfDetails.impact || []).map(impact => `
                                <div style="display: flex; align-items: center; padding: 10px 15px; background: rgba(231, 76, 60, 0.08); border-radius: 8px; border: 1px solid rgba(231, 76, 60, 0.2); transition: transform 0.2s ease;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                                    <span style="color: #e74c3c; margin-right: 10px; font-size: 16px;">‚Ä¢</span>
                                    <span style="color: #e2e8f0; font-size: 15px; line-height: 1.4;">${impact}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Contact modal for Contact planet moons
        function showContactModal(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            const pdfDetails = moon.userData.pdfDetails || {};
            const contactInfo = pdfDetails.contact || {};
            
            titleEl.textContent = moonName;
            
            let html = `
                <div style="display: flex; flex-direction: column; height: 100%; padding: 20px; align-items: center; justify-content: center;">
                    <div style="background: rgba(26, 188, 156, 0.1); border-radius: 20px; padding: 40px; text-align: center; max-width: 500px;">
                        <div style="font-size: 80px; margin-bottom: 20px; animation: pulseGlow 2s infinite;">${contactInfo.icon || 'üìû'}</div>
                        <h3 style="color: #1abc9c; margin: 0 0 15px 0; font-size: 24px;">${pdfDetails.title || moonName}</h3>
                        <p style="color: #94a3b8; margin: 0 0 25px 0; font-size: 16px;">${pdfDetails.description || 'Contact information'}</p>
                        
                        <div style="background: rgba(255,255,255,0.05); border-radius: 15px; padding: 25px; margin-bottom: 20px;">
                            ${contactInfo.link ? `
                                <a href="${contactInfo.link}" style="color: #1abc9c; text-decoration: none; font-size: 18px; font-weight: bold; display: block; padding: 15px; background: rgba(26, 188, 156, 0.1); border-radius: 10px; border: 2px solid rgba(26, 188, 156, 0.3); transition: all 0.3s ease;" onmouseover="this.style.background='rgba(26, 188, 156, 0.2)'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='rgba(26, 188, 156, 0.1)'; this.style.transform='scale(1)'">
                                    ${contactInfo.value}
                                </a>
                            ` : `
                                <div style="color: #e2e8f0; font-size: 18px; font-weight: bold; padding: 15px; background: rgba(26, 188, 156, 0.1); border-radius: 10px; border: 2px solid rgba(26, 188, 156, 0.3);">
                                    ${contactInfo.value}
                                </div>
                            `}
                        </div>
                        
                        <p style="color: #94a3b8; font-size: 14px; margin: 0;">
                            ${contactInfo.method === 'Email' ? 'Click to send email' : 
                              contactInfo.method === 'Phone' ? 'Click to call' : 
                              contactInfo.method === 'LinkedIn' ? 'Click to view profile' : 
                              'Professional contact information'}
                        </p>
                    </div>
                </div>
            `;
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Experience modal for Experience planet moons
        function showExperienceModal(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            const pdfDetails = moon.userData.pdfDetails || {};
            
            titleEl.textContent = moonName;
            
            let html = `
                <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                    <!-- Company Header -->
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h2 style="color: #38bdf8; margin: 0; font-size: 24px;">${pdfDetails.company || moonName}</h2>
                        <div style="color: #94a3b8; font-size: 16px; margin-top: 5px;">${pdfDetails.role || 'Professional Role'}</div>
                        <div style="color: #64748b; font-size: 14px; margin-top: 3px;">${pdfDetails.duration || ''} | ${pdfDetails.location || ''}</div>
                    </div>
                    
                    <!-- Industry Badge -->
                    ${pdfDetails.industry ? `
                        <div style="text-align: center; margin-bottom: 20px;">
                            <span style="background: linear-gradient(45deg, #38bdf8, #818cf8); color: white; padding: 8px 16px; border-radius: 20px; font-size: 12px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;">
                                ${pdfDetails.industry}
                            </span>
                        </div>
                    ` : ''}
                    
                    <!-- Achievements -->
                    <div style="flex: 1; overflow-y: auto;">
                        <h3 style="color: #38bdf8; margin: 0 0 15px 0; font-size: 18px; text-align: center;">Key Achievements</h3>
                        <div style="background: rgba(255,255,255,0.03); border-radius: 12px; padding: 15px;">
                            ${(pdfDetails.achievements || []).map(achievement => `
                                <div style="background: rgba(56, 189, 248, 0.05); border-left: 3px solid #38bdf8; padding: 12px; margin-bottom: 10px; border-radius: 0 8px 8px 0;">
                                    <p style="margin: 0; color: #e2e8f0; font-size: 14px; line-height: 1.5;">${achievement}</p>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Expertise modal for Expertise & Impact planet moons
        function showExpertiseModal(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            const pdfDetails = moon.userData.pdfDetails || {};
            
            titleEl.textContent = moonName;
            
            let html = `
                <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                    <!-- Header -->
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h2 style="color: #f39c12; margin: 0; font-size: 24px;">${pdfDetails.title || moonName}</h2>
                        <div style="color: #94a3b8; font-size: 14px; margin-top: 5px;">${pdfDetails.subtitle || 'Domain Expertise'}</div>
                    </div>
                    
                    <!-- Description -->
                    ${pdfDetails.description ? `
                        <div style="background: rgba(243, 156, 18, 0.1); border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                            <p style="color: #e2e8f0; margin: 0; font-size: 14px; line-height: 1.5; text-align: center;">${pdfDetails.description}</p>
                        </div>
                    ` : ''}
                    
                    <!-- Content Sections -->
                    <div style="flex: 1; overflow-y: auto; display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <!-- Impact Column -->
                        ${pdfDetails.impact ? `
                            <div style="background: rgba(255,255,255,0.03); border-radius: 10px; padding: 15px;">
                                <h4 style="color: #f39c12; margin: 0 0 12px 0; font-size: 16px; text-align: center;">üìä Measurable Impact</h4>
                                ${pdfDetails.impact.map(item => `
                                    <div style="background: rgba(243, 156, 18, 0.1); padding: 8px; margin-bottom: 8px; border-radius: 6px; border-left: 3px solid #f39c12;">
                                        <p style="margin: 0; color: #e2e8f0; font-size: 12px; line-height: 1.4;">${item}</p>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        <!-- Problems/Approaches Column -->
                        ${(pdfDetails.problems || pdfDetails.approaches || pdfDetails.capabilities) ? `
                            <div style="background: rgba(255,255,255,0.03); border-radius: 10px; padding: 15px;">
                                <h4 style="color: #f39c12; margin: 0 0 12px 0; font-size: 16px; text-align: center;">
                                    ${pdfDetails.problems ? 'üéØ Problem Domains' : pdfDetails.approaches ? 'üöÄ Approaches' : '‚ö° Capabilities'}
                                </h4>
                                ${(pdfDetails.problems || pdfDetails.approaches || pdfDetails.capabilities || []).map(item => `
                                    <div style="background: rgba(243, 156, 18, 0.05); padding: 8px; margin-bottom: 8px; border-radius: 6px;">
                                        <p style="margin: 0; color: #cbd5e1; font-size: 12px; line-height: 1.4;">${item}</p>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Standard modal for other planets/moons
        function showStandardModal(moon) {
            const panel = document.getElementById('overlay-panel');
            const title = document.getElementById('panel-title');
            const subtitle = document.getElementById('panel-subtitle');
            const content = document.getElementById('panel-content');

            const moonName = (moon.userData && moon.userData.name) || moon.name || 'Moon';
            const parentName = (moon.userData && moon.userData.parentPlanet && moon.userData.parentPlanet.userData && moon.userData.parentPlanet.userData.name) || '';

            title.textContent = moonName;
            subtitle.textContent = parentName;
            
            // Check if this is a Skills moon and format accordingly
            const pdfDetails = moon.userData.pdfDetails || {};
            if (parentName === 'Skills & Tools' && pdfDetails.skills) {
                // Enhanced Skills Moon Modal
                content.innerHTML = `
                    <div style="padding: 15px;">
                        <div style="background: rgba(56, 189, 248, 0.1); border-radius: 12px; padding: 15px; margin-bottom: 15px;">
                            <h3 style="color: #38bdf8; margin: 0 0 8px 0; font-size: 18px;">${pdfDetails.title}</h3>
                            <p style="color: #94a3b8; margin: 0 0 12px 0; font-size: 14px;">${pdfDetails.description}</p>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 15px;">
                            <h4 style="color: #38bdf8; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center;">
                                <span style="margin-right: 6px;">üõ†Ô∏è</span>
                                Skills & Tools
                            </h4>
                            <div style="display: grid; gap: 6px; max-height: 300px; overflow: hidden;">
                                ${pdfDetails.skills.slice(0, 8).map(skill => `
                                    <div style="display: flex; align-items: center; padding: 6px 10px; background: rgba(56, 189, 248, 0.08); border-radius: 6px; border: 1px solid rgba(56, 189, 248, 0.2);">
                                        <span style="color: #38bdf8; margin-right: 6px; font-size: 12px;">‚Ä¢</span>
                                        <span style="color: #e2e8f0; font-size: 13px; line-height: 1.3;">${skill}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Default modal content
                // robustly obtain a snapshot from the moon texture (canvas or image)
                let imgSrc = '';
                const tex = moon.material && moon.material.map;
                const sourceCanvas = tex && (tex._canvas || tex.image);
                if (sourceCanvas && sourceCanvas.toDataURL) {
                    try { imgSrc = sourceCanvas.toDataURL(); } catch(e) { imgSrc = ''; }
                } else if (tex && tex.image && tex.image.src) {
                    imgSrc = tex.image.src;
                }
                
                const detailsText = moon.userData.moonDetails || moon.userData.details || moon.userData.description || '';
                const imgHtml = imgSrc ? `<img src="${imgSrc}" style="width:100%;border-radius:8px;margin-bottom:12px;display:block">` : '';
                content.innerHTML = `${imgHtml}<div style="white-space:pre-wrap;margin:0;font-family:inherit;color:#dbeafe;font-size:16px;line-height:1.6;">${detailsText}</div>`;
            }

            panel.classList.add('active');
        }

        // Helper functions for language proficiency
        function getProficiencyLevel(details) {
            if (!details) return 'Basic';
            const text = details.toLowerCase();
            if (text.includes('native')) return 'Native';
            if (text.includes('professional') || text.includes('fluent')) return 'Professional';
            if (text.includes('intermediate')) return 'Intermediate';
            return 'Basic';
        }

        // Create 3D Hero Faces
        function createHeroFace(heroName) {
            const heroes = {
                'Einstein': {
                    face: `
                        <div style="position: relative; width: 50px; height: 50px; transform-style: preserve-3d; perspective: 200px;">
                            <!-- Main 3D Container -->
                            <div style="position: relative; width: 100%; height: 100%; border-radius: 50%; transform: rotateX(10deg) rotateY(-5deg); box-shadow: 0 8px 25px rgba(0,0,0,0.4), 0 4px 10px rgba(0,0,0,0.3); transition: transform 0.3s ease;">
                                <!-- Image Layer -->
                                <img src="assets/images/einstien.jpg" alt="Einstein" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%; filter: contrast(1.2) brightness(1.1) saturate(1.2);">
                                
                                <!-- 3D Depth Layers -->
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 50%; background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, transparent 25%, transparent 75%, rgba(0,0,0,0.2) 100%); transform: translateZ(2px);"></div>
                                <div style="position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px; border-radius: 50%; background: linear-gradient(45deg, rgba(255,255,255,0.1) 0%, transparent 50%); transform: translateZ(3px);"></div>
                                
                                <!-- Rim Light Effect -->
                                <div style="position: absolute; top: -3px; left: -3px; right: -3px; bottom: -3px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, rgba(56, 189, 248, 0.4), transparent 70%); transform: translateZ(-1px); filter: blur(2px);"></div>
                            </div>
                        </div>
                    `,
                    animation: '',
                    description: 'Genius of Relativity'
                },
                'Newton': {
                    face: `
                        <div style="position: relative; width: 50px; height: 50px; transform-style: preserve-3d; perspective: 200px;">
                            <!-- Main 3D Container -->
                            <div style="position: relative; width: 100%; height: 100%; border-radius: 50%; transform: rotateX(8deg) rotateY(3deg); box-shadow: 0 8px 25px rgba(0,0,0,0.4), 0 4px 10px rgba(0,0,0,0.3); transition: transform 0.3s ease;">
                                <!-- Image Layer -->
                                <img src="assets/images/newton.jpg" alt="Newton" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%; filter: contrast(1.15) brightness(1.05) saturate(1.1) sepia(0.1);">
                                
                                <!-- 3D Depth Layers -->
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 50%; background: linear-gradient(120deg, rgba(255,255,255,0.25) 0%, transparent 30%, transparent 70%, rgba(0,0,0,0.15) 100%); transform: translateZ(2px);"></div>
                                <div style="position: absolute; top: 1px; left: 1px; right: 1px; bottom: 1px; border-radius: 50%; background: linear-gradient(60deg, rgba(255,255,255,0.15) 0%, transparent 40%); transform: translateZ(3px);"></div>
                                
                                <!-- Rim Light Effect -->
                                <div style="position: absolute; top: -3px; left: -3px; right: -3px; bottom: -3px; border-radius: 50%; background: radial-gradient(circle at 25% 25%, rgba(139, 69, 19, 0.3), transparent 70%); transform: translateZ(-1px); filter: blur(2px);"></div>
                                
                                <!-- Apple Element -->
                                <div style="position: absolute; top: -8px; right: -6px; width: 8px; height: 8px; background: radial-gradient(circle at 30% 30%, #ff4444, #cc2222); border-radius: 50%; transform: translateZ(5px); box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                                    <div style="position: absolute; top: -1px; right: 1px; width: 2px; height: 3px; background: #228B22; border-radius: 50% 50% 50% 0; transform: rotate(45deg);"></div>
                                </div>
                            </div>
                        </div>
                    `,
                    animation: '',
                    description: 'Master of Physics'
                },
                'Gandhi': {
                    face: `
                        <div style="position: relative; width: 50px; height: 50px; transform-style: preserve-3d; perspective: 200px;">
                            <!-- Main 3D Container -->
                            <div style="position: relative; width: 100%; height: 100%; border-radius: 50%; transform: rotateX(5deg) rotateY(-8deg); box-shadow: 0 8px 25px rgba(0,0,0,0.4), 0 4px 10px rgba(0,0,0,0.3); transition: transform 0.3s ease;">
                                <!-- Image Layer -->
                                <img src="assets/images/gandhi.avif" alt="Gandhi" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%; filter: contrast(1.1) brightness(1.08) saturate(1.15) sepia(0.05);">
                                
                                <!-- 3D Depth Layers -->
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 50%; background: linear-gradient(150deg, rgba(255,255,255,0.2) 0%, transparent 35%, transparent 65%, rgba(0,0,0,0.1) 100%); transform: translateZ(2px);"></div>
                                <div style="position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px; border-radius: 50%; background: linear-gradient(30deg, rgba(255,255,255,0.12) 0%, transparent 45%); transform: translateZ(3px);"></div>
                                
                                <!-- Rim Light Effect -->
                                <div style="position: absolute; top: -3px; left: -3px; right: -3px; bottom: -3px; border-radius: 50%; background: radial-gradient(circle at 35% 35%, rgba(212, 175, 55, 0.35), transparent 70%); transform: translateZ(-1px); filter: blur(2px);"></div>
                                
                                <!-- Glasses Reflection -->
                                <div style="position: absolute; top: 15px; left: 8px; width: 12px; height: 8px; background: linear-gradient(45deg, rgba(255,255,255,0.4), transparent 60%); border-radius: 50%; transform: translateZ(4px);"></div>
                                <div style="position: absolute; top: 15px; right: 8px; width: 12px; height: 8px; background: linear-gradient(135deg, rgba(255,255,255,0.4), transparent 60%); border-radius: 50%; transform: translateZ(4px);"></div>
                            </div>
                        </div>
                    `,
                    animation: '',
                    description: 'Apostle of Peace'
                },
                'Buddha': {
                    face: `
                        <div style="position: relative; width: 50px; height: 50px; transform-style: preserve-3d; perspective: 200px;">
                            <!-- Main 3D Container -->
                            <div style="position: relative; width: 100%; height: 100%; border-radius: 50%; transform: rotateX(12deg) rotateY(0deg); box-shadow: 0 10px 30px rgba(255,215,0,0.3), 0 6px 15px rgba(0,0,0,0.4); transition: transform 0.3s ease;">
                                <!-- Image Layer -->
                                <img src="assets/images/buddha.png" alt="Buddha" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%; filter: contrast(1.1) brightness(1.1) saturate(1.3) hue-rotate(10deg);">
                                
                                <!-- 3D Depth Layers -->
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 50%; background: linear-gradient(135deg, rgba(255,215,0,0.2) 0%, transparent 30%, transparent 70%, rgba(255,140,0,0.15) 100%); transform: translateZ(2px);"></div>
                                <div style="position: absolute; top: 1px; left: 1px; right: 1px; bottom: 1px; border-radius: 50%; background: linear-gradient(45deg, rgba(255,255,255,0.2) 0%, transparent 50%); transform: translateZ(3px);"></div>
                                
                                <!-- Divine Aura -->
                                <div style="position: absolute; top: -4px; left: -4px; right: -4px; bottom: -4px; border-radius: 50%; background: radial-gradient(circle, rgba(255,215,0,0.4) 0%, rgba(255,165,0,0.2) 50%, transparent 80%); transform: translateZ(-1px); filter: blur(3px); animation: pulse 3s ease-in-out infinite;"></div>
                                
                                <!-- Third Eye Glow -->
                                <div style="position: absolute; top: 8px; left: 22px; width: 6px; height: 6px; background: radial-gradient(circle, rgba(255,69,0,0.8), rgba(255,140,0,0.4)); border-radius: 50%; transform: translateZ(5px); box-shadow: 0 0 8px rgba(255,69,0,0.6); filter: blur(0.5px);"></div>
                            </div>
                        </div>
                    `,
                    animation: '',
                    description: 'Enlightened One'
                }
            };
            
            return heroes[heroName] || heroes['Einstein'];
        }

        function getCharacterForProficiency(level, language) {
            const characters = {
                'Native': {
                    'Hindi': 'üßô‚Äç‚ôÇÔ∏è', // Wise sage for native Hindi
                    'English': 'üë®‚Äçüî¨', // Albert Einstein-like scientist for native English
                    'default': 'üë®‚Äçüî¨' // Albert Einstein for native level
                },
                'Professional': {
                    'Hindi': 'üë®‚Äçüíº', // Business person
                    'English': 'üï¥Ô∏è', // Professional figure
                    'default': 'üë®‚Äçüíª' // Professional worker
                },
                'Intermediate': {
                    'default': 'üë®‚Äçüéì' // Graduate student
                },
                'Basic': {
                    'default': 'üë∂' // Learning/beginner
                }
            };
            
            return characters[level]?.[language] || characters[level]?.['default'] || 'üë®‚Äçüéì';
        }

        function getAnimationForProficiency(level) {
            const animations = {
                'Native': 'expertGlow 4s ease-in-out',
                'Professional': 'professionalFloat 3s ease-in-out',
                'Intermediate': 'charHover 2s ease-in-out',
                'Basic': 'beginnerWobble 1.5s ease-in-out'
            };
            return animations[level] || 'charBounce 1.5s ease-in-out';
        }

        function getProficiencyBadge(level) {
            const badges = {
                'Native': '‚≠ê',
                'Professional': 'üíº',
                'Intermediate': 'üìö',
                'Basic': 'üå±'
            };
            return badges[level] || 'üìñ';
        }

        function getProficiencyScore(level, skill) {
            const scores = {
                'Native': { speaking: '10', reading: '10', writing: '10', comprehension: '10' },
                'Professional': { speaking: '9', reading: '9', writing: '8', comprehension: '10' },
                'Intermediate': { speaking: '7', reading: '7', writing: '6', comprehension: '8' },
                'Basic': { speaking: '5', reading: '6', writing: '4', comprehension: '6' }
            };
            return scores[level]?.[skill] || '5';
        }

        function getCharacterDescription(level, language) {
            const descriptions = {
                'Native': {
                    'Hindi': 'Master Linguist',
                    'English': 'Einstein-level Expert',
                    'default': 'Einstein-level Expert'
                },
                'Professional': {
                    'Hindi': 'Business Communicator',
                    'English': 'Professional Speaker',
                    'default': 'Fluent Speaker'
                },
                'Intermediate': {
                    'default': 'Learning Scholar'
                },
                'Basic': {
                    'default': 'Language Learner'
                }
            };
            return descriptions[level]?.[language] || descriptions[level]?.['default'] || 'Speaker';
        }

        // Get hero for individual language modals
        function getHeroForLanguage(languageName) {
            const heroMapping = {
                'Hindi': 'Buddha',
                'English': 'Einstein', 
                'Gujarati': 'Gandhi',
                'Marathi': 'Newton'
            };
            return heroMapping[languageName] || 'Einstein';
        }

        // close overlay
        function closeOverlay() {
        	const panel = document.getElementById('overlay-panel');
        	panel.classList.remove('active');
        }

        // === NUR WARS EXPERIENCE ===
        let nurWarsActive = false;
        let battleScene = null;
        let nurWarsCamera = null;
        let nurWarsScene = null;
        let nurWarsObjects = [];
        let nurWarsTimeouts = [];
        let movieTimeoutsPaused = [];
        let moviePaused = false;
        let movieStartTime = 0;
        let moviePauseTime = 0;
        let modelsToLoad = 0;
        let modelsLoaded = 0;
        let battleReady = false;
        let battleVideoMode = true;
        let battleVideoIdleTimer = null;
        let showingBattleVideoCredits = false;
        let currentBattleVideoMeta = null;
        const battleVideoSources = [
            'assets/videos/Episode 1 battle.mp4',
            'assets/videos/Episode 2 battle.mp4',
            'assets/videos/Episode 3 battle.mp4',
            'assets/videos/Episode 4 battle.mp4',
            'assets/videos/Episode 5 battle.mp4',
            'assets/videos/Episode 6 battle.mp4',
            'assets/videos/Rogue 1 Battle.mp4',
            'assets/videos/SOLO battle.mp4'
        ];
        
        function setNurWarsTimeout(callback, delay) {
            const id = setTimeout(callback, delay);
            nurWarsTimeouts.push(id);
            return id;
        }
        
        function clearNurWarsTimeouts() {
            nurWarsTimeouts.forEach(clearTimeout);
            nurWarsTimeouts = [];
        }

        window.toggleMoviePlayPause = () => {
            moviePaused = !moviePaused;
            const btn = document.getElementById('movie-play-btn');
            if (moviePaused) {
                btn.textContent = '‚ñ∂Ô∏è Play';
                moviePauseTime = Date.now() - movieStartTime;
                // Pause ALL audio during pause
                if (currentAudio && !currentAudio.paused) {
                    currentAudio.pause();
                }
                // Also pause any synth sounds
                if (audioContext && audioContext.state === 'running') {
                    audioContext.suspend().catch(() => {});
                }
            } else {
                btn.textContent = '‚è∏Ô∏è Pause';
                movieStartTime = Date.now() - moviePauseTime;
                // Resume audio
                if (currentAudio && currentAudio.paused) {
                    currentAudio.play().catch(() => {});
                }
                // Resume synth sounds
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().catch(() => {});
                }
            }
        };

        window.skipMovie = (seconds) => {
            const skipMs = seconds * 1000;
            if (moviePaused) {
                moviePauseTime = Math.max(0, moviePauseTime + skipMs);
            } else {
                movieStartTime -= skipMs; // Move start time back to jump forward/back
            }
            // Skip audio too
            if (currentAudio && !Number.isNaN(currentAudio.currentTime)) {
                const newTime = currentAudio.currentTime + seconds;
                const duration = Number.isFinite(currentAudio.duration) ? currentAudio.duration : null;
                if (duration !== null && duration > 0) {
                    currentAudio.currentTime = Math.min(Math.max(newTime, 0), Math.max(duration - 0.1, 0));
                } else {
                    currentAudio.currentTime = Math.max(newTime, 0);
                }
            }
        };

        function startNurWars() {
            if (nurWarsActive) return;
            
            nurWarsActive = true;
            moviePaused = false;
            movieStartTime = Date.now();
            moviePauseTime = 0;
            renderMode = 'default'; // Start in default mode (solar system view)
            
            // Pre-load battle video metadata if in video mode
            if (battleVideoMode && !currentBattleVideoMeta) {
                const videoSrc = getRandomBattleVideoSrc();
                currentBattleVideoMeta = getBattleVideoMeta(videoSrc);
            }
            
            // Show video controls immediately (for the entire experience: story + video + credits)
            if (battleVideoMode) {
                const videoLayer = document.getElementById('battle-video-layer');
                const videoControls = document.getElementById('battle-video-controls');
                const videoProgress = document.getElementById('battle-video-progress');
                
                if (videoLayer) videoLayer.style.display = 'block';
                if (videoControls) videoControls.style.opacity = '1';
                // Hide progress bar (scrubber removed)
                if (videoProgress) videoProgress.style.display = 'none';
            }
            
            // Enable sound automatically for NUR WARS
            if (!soundEnabled) {
                soundEnabled = true;
                document.getElementById('sound-btn').textContent = 'üîä Sound On';
            }
            
            // Update sound button in movie controls
            const nurWarsSoundBtn = document.getElementById('nur-wars-sound-btn');
            if (nurWarsSoundBtn) {
                nurWarsSoundBtn.textContent = soundEnabled ? 'üîä' : 'üîá';
            }
            
            // Reset movie play button
            const moviePlayBtn = document.getElementById('movie-play-btn');
            if (moviePlayBtn) {
                moviePlayBtn.textContent = '‚è∏Ô∏è Pause';
            }
            
            // Stop default solar system sounds and hide UI
            stopCurrentAudio();
            stopCometSounds(); // Stop comet sounds
            // Pause background audio completely during NUR WARS
            if (backgroundAudio) {
                const now = backgroundAudio.audioContext.currentTime;
                try {
                    backgroundAudio.gainNode.gain.cancelScheduledValues(now);
                    backgroundAudio.gainNode.gain.setValueAtTime(0, now);
                } catch(e) { backgroundAudio.gainNode.gain.value = 0; }
            }
            document.body.classList.add('nur-wars-active');
            
            // Show audio controls and exit button for NUR WARS
            const audioControls = document.getElementById('audio-controls');
            if (audioControls) {
                audioControls.style.opacity = '1';
                audioControls.style.pointerEvents = 'auto';
            }
            
            const exitBtn = document.getElementById('exit-hyperspace-btn');
            if (exitBtn) {
                exitBtn.style.display = 'block';
                exitBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    closeNurWars();
                };
            }
            
            // Save current camera state
            const originalCameraPos = camera.position.clone();
            const originalTarget = controls.target.clone();
            
            // Disable main controls during NUR WARS
            controls.enabled = false;
            
            // SILENT PAN: Pan up to see a different area in space, avoiding solar system
            // Move camera upward and shift target away from solar system center
            const panTarget = originalCameraPos.clone().add(new THREE.Vector3(0, 15000, 0));
            const targetShift = originalTarget.clone().add(new THREE.Vector3(0, 15000, 0));
            const panStart = Date.now();
            const panDuration = 2000; // 2 second quick pan
            
            function animatePanToCrawl() {
                const elapsed = Date.now() - panStart;
                const progress = Math.min(elapsed / panDuration, 1);
                const eased = easeInOut(progress);
                
                camera.position.lerpVectors(originalCameraPos, panTarget, eased);
                controls.target.lerpVectors(originalTarget, targetShift, eased);
                
                if (progress < 1) {
                    requestAnimationFrame(animatePanToCrawl);
                } else {
                    // Pan complete, now start the crawl sequence
                    showCrawlSequence(panTarget);
                }
            }
            
            animatePanToCrawl();
        }
        
        function stopCometSounds() {
            // Stop any comet-related audio if it exists
            if (window.cometAudio) {
                window.cometAudio.pause();
                window.cometAudio = null;
            }
        }
        
        function easeInOut(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        function getRandomBattleVideoSrc() {
            const pick = battleVideoSources[Math.floor(Math.random() * battleVideoSources.length)];
            return encodeURI(pick);
        }

        function getBattleVideoMeta(src) {
            const name = decodeURI(src).split('/').pop() || '';
            const key = name.replace('.mp4', '').trim();
            const base = {
                overlayTitle: 'REBEL ALLIANCE MISSION',
                overlaySubtitle: 'Destroy the Legacy System Death Star',
                overlayTagline: 'Use the Force of Business Analysis, Nur...',
                storyDuration: 22
            };
                        const metaMap = {
                'Episode 1 battle': {
                    movie: 'Episode I ‚Äî The Phantom Menace',
                    overlayTitle: 'THE PHANTOM MENACE ENGAGEMENT',
                    overlaySubtitle: 'Battle of Naboo ‚Äî Droid Control Ship Assault',
                    overlayTagline: 'Navigate chaos. Deliver precision. Transform outcomes.',
                    story: [
                        'Episode I: The Phantom Menace',
                        '',
                        'As Republic forces engage the Trade Federation blockade over Naboo, young Anakin Skywalker pilots a starfighter into the heart of the Droid Control Ship.',
                        '',
                        'The battle is chaotic‚Äîsquadrons swarm, fighters weave through heavy fire, and the mission teeters on a knife\'s edge.',
                        '',
                        'NUR DAWOODANI excels in high-velocity transformations where agility and rapid stakeholder alignment are essential. Leading multi-phase system overhauls at Lululemon and HSBC, Nur orchestrated complex technical migrations while maintaining operational stability.',
                        '',
                        'Like Anakin\'s improbable strike that neutralizes the droid army, Nur delivers decisive results through precise planning and adaptive execution.',
                        '',
                        'When systems must evolve under pressure, Nur charts the path forward.'
                    ],
                    storyDuration: 32,
                    credits: [
                        '',
                        '',
                        'MISSION IMPACT',
                        '',
                        'Episode I: The Phantom Menace',
                        'Battle of Naboo ‚Äî Droid Control Ship Assault',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'NUR DAWOODANI',
                        'Senior Business Analyst',
                        '',
                        'Demonstrated Impact:',
                        '',
                        '‚Ä¢ Led complex system migrations maintaining 100% uptime',
                        '‚Ä¢ Delivered $2M+ revenue through AI-driven product features',
                        '‚Ä¢ Orchestrated cross-functional teams across retail & banking domains',
                        '‚Ä¢ Achieved 40% efficiency gains through process optimization',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'Core Competencies:',
                        'SAFe Agile ‚Ä¢ Stakeholder Management',
                        'Technical Architecture ‚Ä¢ Risk Mitigation',
                        'Digital Transformation ‚Ä¢ Process Excellence',
                        '',
                        '18+ Years Driving Strategic Outcomes',
                        'Across Retail & Financial Services',
                        '',
                        '',
                        'END TRANSMISSION'
                    ]
                },
                'Episode 2 battle': {
                    movie: 'Episode II ‚Äî Attack of the Clones',
                    overlayTitle: 'ATTACK OF THE CLONES ‚Äî GEONOSIS ARENA',
                    overlaySubtitle: 'Battle of Geonosis ‚Äî Republic Clone Army Debut',
                    overlayTagline: 'Coordinate. Execute. Overcome impossible odds.',
                    story: [
                        'Episode II: Attack of the Clones',
                        '',
                        'The Battle of Geonosis erupts as the newly formed Clone Army makes its first appearance. Jedi forces are surrounded in the execution arena while Separatist droid armies mass on all sides.',
                        '',
                        'Republic gunships swoop in, extracting survivors and deploying clone battalions across multiple fronts. Success depends on split-second coordination across dozens of moving pieces.',
                        '',
                        'NUR DAWOODANI specializes in complex, multi-stakeholder initiatives where coordination is mission-critical. At Lululemon, Nur orchestrated parallel workstreams across technology, operations, and business teams during the Inventory Transformation initiative.',
                        '',
                        'At HSBC, Nur managed intricate dependencies across regional banking systems, ensuring seamless integration of new credit workflows.',
                        '',
                        'Like the Republic\'s synchronized rescue operation, Nur delivers cohesive results from fragmented starting points.'
                    ],
                    storyDuration: 32,
                    credits: [
                        '',
                        '',
                        'MISSION IMPACT',
                        '',
                        'Episode II: Attack of the Clones',
                        'Battle of Geonosis ‚Äî Republic Clone Army Debut',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'NUR DAWOODANI',
                        'Senior Business Analyst',
                        '',
                        'Multi-Stakeholder Leadership:',
                        '',
                        '‚Ä¢ Coordinated 12+ cross-functional teams simultaneously',
                        '‚Ä¢ Managed technical dependencies across 5 regional systems',
                        '‚Ä¢ Delivered ¬£1.5M annual savings through process redesign',
                        '‚Ä¢ Eliminated 2M+ paper documents via digital transformation',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'Transformation Portfolio:',
                        'Inventory Management Overhaul (Lululemon)',
                        'Credit Workflow Modernization (HSBC)',
                        'Paperless Operations Initiative',
                        '',
                        'Proven ability to orchestrate complex change',
                        'across distributed teams and competing priorities',
                        '',
                        '',
                        'END TRANSMISSION'
                    ]
                },
                'Episode 3 battle': {
                    movie: 'Episode III ‚Äî Revenge of the Sith',
                    overlayTitle: 'REVENGE OF THE SITH ‚Äî CORUSCANT SIEGE',
                    overlaySubtitle: 'Battle Over Coruscant ‚Äî Rescue Mission',
                    overlayTagline: 'Navigate complexity. Deliver under pressure.',
                    story: [
                        'Episode III: Revenge of the Sith',
                        '',
                        'The opening space battle over Coruscant represents one of the war\'s most intense engagements. Obi-Wan and Anakin weave through a massive fleet clash to rescue Chancellor Palpatine from General Grievous\'s flagship.',
                        '',
                        'Capital ships exchange fire while hundreds of fighters dogfight in close quarters. Every maneuver carries risk; every decision matters.',
                        '',
                        'NUR DAWOODANI thrives in high-stakes environments where technical precision meets business urgency. During Lululemon\'s Great Revamp project, Nur guided architectural decisions that prevented scalability collapse while maintaining aggressive delivery timelines.',
                        '',
                        'At HSBC, Nur navigated regulatory constraints and legacy system dependencies to deliver critical mortgage servicing enhancements on schedule.',
                        '',
                        'Where others see obstacles, Nur identifies pathways to success.'
                    ],
                    storyDuration: 32,
                    credits: [
                        '',
                        '',
                        'MISSION IMPACT',
                        '',
                        'Episode III: Revenge of the Sith',
                        'Battle Over Coruscant ‚Äî Rescue Mission',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'NUR DAWOODANI',
                        'Senior Business Analyst',
                        '',
                        'High-Stakes Delivery:',
                        '',
                        '‚Ä¢ Prevented system scalability collapse (Lululemon Great Revamp)',
                        '‚Ä¢ Delivered mortgage servicing under strict regulatory timelines',
                        '‚Ä¢ Managed ¬£3M+ budget allocation across technical initiatives',
                        '‚Ä¢ Zero critical defects in production releases',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'Technical Leadership:',
                        'Enterprise Architecture Decision-Making',
                        'Legacy System Integration & Modernization',
                        'Regulatory Compliance & Risk Management',
                        '',
                        'Trusted advisor for mission-critical initiatives',
                        'where technical excellence meets business impact',
                        '',
                        '',
                        'END TRANSMISSION'
                    ]
                },
                'Episode 4 battle': {
                    movie: 'Episode IV ‚Äî A New Hope',
                    overlayTitle: 'A NEW HOPE ‚Äî DEATH STAR ASSAULT',
                    overlaySubtitle: 'Battle of Yavin ‚Äî Trench Run',
                    overlayTagline: 'One shot. Total focus. Mission success.',
                    story: [
                        'Episode IV: A New Hope',
                        '',
                        'The Rebel Alliance launches a desperate assault on the Death Star above Yavin. X-wing squadrons face overwhelming odds, navigating surface trenches while TIE fighters and turbolasers exact a heavy toll.',
                        '',
                        'Luke Skywalker\'s final approach to the thermal exhaust port represents the mission\'s critical moment‚Äîa narrow window where precision determines survival.',
                        '',
                        'NUR DAWOODANI excels at identifying and executing high-impact interventions. At Lululemon, Nur\'s AI-driven Product Highlights feature generated $2M+ in annual revenue by enhancing the customer discovery experience at a critical conversion point.',
                        '',
                        'At HSBC, Nur\'s process optimization reduced credit application turnaround by 35%, directly improving customer satisfaction scores.',
                        '',
                        'Like Luke\'s shot that saves the Rebellion, Nur delivers transformative results through focused, data-driven execution.'
                    ],
                    storyDuration: 32,
                    credits: [
                        '',
                        '',
                        'MISSION IMPACT',
                        '',
                        'Episode IV: A New Hope',
                        'Battle of Yavin ‚Äî Death Star Trench Run',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'NUR DAWOODANI',
                        'Senior Business Analyst',
                        '',
                        'Revenue & Efficiency Impact:',
                        '',
                        '‚Ä¢ Generated $2M+ annual revenue (AI Product Highlights)',
                        '‚Ä¢ Reduced credit turnaround time by 35%',
                        '‚Ä¢ Improved customer satisfaction scores by 28%',
                        '‚Ä¢ Delivered 40% operational efficiency gains',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'Innovation Leadership:',
                        'AI/ML Feature Development',
                        'Customer Experience Optimization',
                        'Data-Driven Process Enhancement',
                        '',
                        'Combines technical depth with commercial insight',
                        'to deliver measurable business outcomes',
                        '',
                        '',
                        'END TRANSMISSION'
                    ]
                },
                'Episode 5 battle': {
                    movie: 'Episode V ‚Äî The Empire Strikes Back',
                    overlayTitle: 'THE EMPIRE STRIKES BACK ‚Äî HOTH DEFENSE',
                    overlaySubtitle: 'Battle of Hoth ‚Äî Evacuation Under Fire',
                    overlayTagline: 'Adapt. Protect. Execute under duress.',
                    story: [
                        'Episode V: The Empire Strikes Back',
                        '',
                        'The Rebel base on Hoth faces an overwhelming Imperial assault. AT-AT walkers advance across the ice plains while Star Destroyers blockade orbital escape routes.',
                        '',
                        'Rebel forces execute a phased evacuation‚Äîsnowspeeders buy time, ion cannon creates windows for transports, and every moment counts. Survival depends on disciplined execution under extreme pressure.',
                        '',
                        'NUR DAWOODANI has repeatedly delivered under adverse conditions where traditional approaches fail. During HSBC\'s legacy system migration, Nur maintained operational continuity while replacing critical mortgage servicing infrastructure.',
                        '',
                        'At Lululemon, Nur guided the team through production incidents during peak holiday traffic, implementing real-time mitigations that preserved revenue streams.',
                        '',
                        'When systems are under fire, Nur keeps the mission on track.'
                    ],
                    storyDuration: 32,
                    credits: [
                        '',
                        '',
                        'MISSION IMPACT',
                        '',
                        'Episode V: The Empire Strikes Back',
                        'Battle of Hoth ‚Äî Evacuation Under Fire',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'NUR DAWOODANI',
                        'Senior Business Analyst',
                        '',
                        'Crisis Management & Resilience:',
                        '',
                        '‚Ä¢ Maintained 100% uptime during legacy system migration',
                        '‚Ä¢ Protected $5M+ holiday revenue during critical incidents',
                        '‚Ä¢ Delivered seamless mortgage infrastructure replacement',
                        '‚Ä¢ Zero customer-facing disruption across major changes',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'Operational Excellence:',
                        'Business Continuity Planning',
                        'Incident Response & Resolution',
                        'Risk Mitigation Strategy',
                        '',
                        'Proven track record protecting operations',
                        'during high-risk transformation initiatives',
                        '',
                        '',
                        'END TRANSMISSION'
                    ]
                },
                'Episode 6 battle': {
                    movie: 'Episode VI ‚Äî Return of the Jedi',
                    overlayTitle: 'RETURN OF THE JEDI ‚Äî ENDOR ASSAULT',
                    overlaySubtitle: 'Battle of Endor ‚Äî Multi-Front Victory',
                    overlayTagline: 'Synchronize. Strike. Achieve total victory.',
                    story: [
                        'Episode VI: Return of the Jedi',
                        '',
                        'The Battle of Endor unfolds on three fronts: ground forces disable the shield generator, space fighters engage Star Destroyers, and the Millennium Falcon penetrates the second Death Star\'s superstructure.',
                        '',
                        'Success requires perfect synchronization‚Äîeach element depends on the others, and timing is everything. When the shield drops, the fleet must be in position.',
                        '',
                        'NUR DAWOODANI orchestrates complex, interdependent initiatives where alignment determines success. The Lululemon Inventory Transformation required parallel changes across warehouse operations, e-commerce systems, and physical stores‚Äîall synchronized to a single cutover window.',
                        '',
                        'At HSBC, Nur coordinated regulatory compliance updates across credit, mortgage, and lending systems while maintaining existing service levels.',
                        '',
                        'Like the Alliance\'s multi-front strategy, Nur delivers cohesive victories from complex engagements.'
                    ],
                    storyDuration: 32,
                    credits: [
                        '',
                        '',
                        'MISSION IMPACT',
                        '',
                        'Episode VI: Return of the Jedi',
                        'Battle of Endor ‚Äî Multi-Front Victory',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'NUR DAWOODANI',
                        'Senior Business Analyst',
                        '',
                        'Enterprise Transformation:',
                        '',
                        '‚Ä¢ Synchronized warehouse, e-commerce, retail systems cutover',
                        '‚Ä¢ Coordinated regulatory updates across 5 product lines',
                        '‚Ä¢ Delivered $4M+ transformation portfolio on schedule',
                        '‚Ä¢ Achieved seamless multi-system integration',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'Strategic Delivery:',
                        'End-to-End Program Management',
                        'Multi-Domain System Integration',
                        'Enterprise-Wide Change Orchestration',
                        '',
                        'Expert at aligning technology, process, and people',
                        'to deliver transformative business outcomes',
                        '',
                        '',
                        'END TRANSMISSION'
                    ]
                },
                'Rogue 1 Battle': {
                    movie: 'Rogue One',
                    overlayTitle: 'ROGUE ONE ‚Äî SCARIF INFILTRATION',
                    overlaySubtitle: 'Battle of Scarif ‚Äî Data Heist',
                    overlayTagline: 'High risk. High reward. Mission accomplished.',
                    story: [
                        'Rogue One: A Star Wars Story',
                        '',
                        'The Battle of Scarif is a desperate gambit‚ÄîRogue One infiltrates an Imperial archive facility to steal Death Star plans while a space battle rages overhead.',
                        '',
                        'The mission is unauthorized, the odds are impossible, and every second counts. Success requires bold execution, technical precision, and unwavering focus.',
                        '',
                        'NUR DAWOODANI embraces calculated risks that deliver disproportionate value. The Paperless Initiative at HSBC eliminated 2M+ documents annually‚Äîa bold process overhaul requiring stakeholder buy-in across conservative banking operations.',
                        '',
                        'At Lululemon, Nur championed AI-driven merchandising features when machine learning was still emerging in retail, ultimately generating $2M+ in revenue.',
                        '',
                        'Like Rogue One\'s mission, Nur identifies opportunities others miss and executes with discipline.'
                    ],
                    storyDuration: 32,
                    credits: [
                        '',
                        '',
                        'MISSION IMPACT',
                        '',
                        'Rogue One: A Star Wars Story',
                        'Battle of Scarif ‚Äî Data Heist',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'NUR DAWOODANI',
                        'Senior Business Analyst',
                        '',
                        'Innovation & Bold Execution:',
                        '',
                        '‚Ä¢ Eliminated 2M+ paper documents annually (Paperless Initiative)',
                        '‚Ä¢ Pioneered AI-driven merchandising ($2M+ revenue impact)',
                        '‚Ä¢ Delivered first-to-market features ahead of competition',
                        '‚Ä¢ Achieved ¬£1.5M annual operational savings',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'Change Leadership:',
                        'Digital Transformation Strategy',
                        'Innovation Pipeline Development',
                        'Stakeholder Advocacy & Buy-In',
                        '',
                        'Identifies high-value opportunities and builds',
                        'the coalitions necessary to deliver them',
                        '',
                        '',
                        'END TRANSMISSION'
                    ]
                },
                'SOLO battle': {
                    movie: 'Solo',
                    overlayTitle: 'SOLO ‚Äî KESSEL RUN ESCAPE',
                    overlaySubtitle: 'The Kessel Run ‚Äî 12 Parsecs',
                    overlayTagline: 'Think fast. Fly faster. Deliver impossible results.',
                    story: [
                        'Solo: A Star Wars Story',
                        '',
                        'Han Solo\'s legendary Kessel Run pushes the Millennium Falcon to its limits. The route requires navigating unstable gravity wells, Imperial patrols, and a collapsing star cluster‚Äîall while racing against time.',
                        '',
                        'Success demands improvisation, technical mastery, and absolute confidence under pressure. The mission should be impossible, but Han finds the angle others miss.',
                        '',
                        'NUR DAWOODANI consistently delivers "impossible" results through creative problem-solving and technical innovation. During Lululemon\'s platform migration, Nur identified an architectural approach that reduced risk by 60% while accelerating the timeline.',
                        '',
                        'At HSBC, Nur\'s process redesign compressed a 6-month initiative into 3 months without sacrificing quality or compliance.',
                        '',
                        'Like Han\'s run, Nur finds the shorter path and executes flawlessly.'
                    ],
                    storyDuration: 32,
                    credits: [
                        '',
                        '',
                        'MISSION IMPACT',
                        '',
                        'Solo: A Star Wars Story',
                        'The Kessel Run ‚Äî Record Time Delivery',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'NUR DAWOODANI',
                        'Senior Business Analyst',
                        '',
                        'Speed & Innovation:',
                        '',
                        '‚Ä¢ Reduced project risk by 60% through architectural innovation',
                        '‚Ä¢ Compressed 6-month initiatives to 3 months',
                        '‚Ä¢ Delivered 40% efficiency improvements via creative solutions',
                        '‚Ä¢ Maintained quality while accelerating timelines',
                        '',
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                        '',
                        'Problem-Solving Excellence:',
                        'Creative Technical Solutions',
                        'Rapid Prototyping & Validation',
                        'Fast-Track Delivery Methods',
                        '',
                        'Combines strategic thinking with tactical execution',
                        'to deliver exceptional results under tight constraints',
                        '',
                        '',
                        'END TRANSMISSION'
                    ]
                }
            };
            return { ...base, ...(metaMap[key] || {}) };
        }

        function formatTime(seconds) {
            if (!Number.isFinite(seconds)) return '0:00';
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function updateBattleVideoControls() {
            const video = document.getElementById('battle-video');
            const playBtn = document.getElementById('video-play-btn');
            const muteBtn = document.getElementById('video-mute-btn');
            if (!video || !playBtn || !muteBtn) return;
            playBtn.textContent = video.paused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pause';
            muteBtn.textContent = video.muted ? 'üîá' : 'üîä';
        }

        function updateBattleVideoProgress() {
            const video = document.getElementById('battle-video');
            const scrubber = document.getElementById('video-scrubber');
            const timeLabel = document.getElementById('video-time');
            if (!video || !scrubber || !timeLabel) return;
            
            // Total duration = crawl story (35s) + video + credits (20s)
            const storyDuration = 35;
            const creditsDuration = 20;
            const videoDuration = Number.isFinite(video.duration) ? video.duration : 90;
            const totalDuration = storyDuration + videoDuration + creditsDuration;
            
            // Calculate elapsed time based on current video position
            // During video playback, we're past the story (35s) and within video duration
            const videoElapsed = Number.isFinite(video.currentTime) ? video.currentTime : 0;
            const totalElapsed = storyDuration + videoElapsed;
            
            scrubber.max = totalDuration;
            scrubber.value = totalElapsed;
            timeLabel.textContent = `${formatTime(totalElapsed)} / ${formatTime(totalDuration)}`;
        }

        function showBattleVideoControls() {
            const controls = document.getElementById('battle-video-controls');
            const progress = document.getElementById('battle-video-progress');
            if (!controls || !progress) return;
            controls.style.opacity = '1';
            // Progress bar always visible
            progress.style.opacity = '1';
            if (battleVideoIdleTimer) clearTimeout(battleVideoIdleTimer);
            // Keep controls visible during credits
            if (!showingBattleVideoCredits) {
                battleVideoIdleTimer = setTimeout(() => {
                    controls.style.opacity = '0';
                    // Keep progress visible
                    progress.style.opacity = '1';
                }, 2000);
            }
        }

        function toggleBattleVideoPlayPause() {
            const video = document.getElementById('battle-video');
            if (!video) return;
            if (video.paused) {
                video.play().catch(() => {});
            } else {
                video.pause();
            }
            updateBattleVideoControls();
        }

        function skipBattleVideo(seconds) {
            const video = document.getElementById('battle-video');
            if (!video || Number.isNaN(video.duration)) return;
            const nextTime = Math.max(0, Math.min(video.currentTime + seconds, video.duration));
            video.currentTime = nextTime;
            updateBattleVideoProgress();
        }

        function toggleBattleVideoMute() {
            const video = document.getElementById('battle-video');
            const muteBtn = document.getElementById('video-mute-btn');
            
            // If blackhole audio is playing, mute that instead
            if (window.currentBlackholeAudio) {
                window.currentBlackholeAudio.muted = !window.currentBlackholeAudio.muted;
                if (muteBtn) {
                    muteBtn.textContent = window.currentBlackholeAudio.muted ? 'üîá' : 'üîä';
                }
            } else if (video) {
                // Otherwise mute the video
                video.muted = !video.muted;
                soundEnabled = !video.muted;
                const btn = document.getElementById('sound-btn');
                if (btn) btn.textContent = soundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
                updateBattleVideoControls();
            }
        }

        function applyBattleVideoMeta(meta) {
            const title = document.getElementById('battle-video-title');
            const subtitle = document.getElementById('battle-video-subtitle');
            const tagline = document.getElementById('battle-video-tagline');

            if (title) title.textContent = meta.overlayTitle || '';
            if (subtitle) subtitle.textContent = meta.overlaySubtitle || '';
            if (tagline) tagline.textContent = meta.overlayTagline || '';
        }

        function showBattleVideoCredits(meta) {
            showingBattleVideoCredits = true;
            // Hide video controls during credits
            const controls = document.getElementById('battle-video-controls');
            if (controls) controls.style.display = 'none';
            
            const credits = document.getElementById('battle-video-credits');
            const story = document.getElementById('battle-video-story');
            if (story) story.classList.remove('active');
            if (!credits) return;
            
            // Generate narrative-driven credits that connect battle events to resume achievements
            const narrativeCredits = generateNarrativeCredits(meta);
            
            credits.innerHTML = `<div style="width: 100%; max-width: 800px; margin: 0 auto; line-height: 1.8;\">${narrativeCredits.map(line => {
                if (line === '') return '<div style="height: 18px;"></div>';
                if (line.includes('‚îÅ')) return `<div style="font-size: 16px; opacity: 0.6; margin: 14px 0;">${line}</div>`;
                if (line.includes('MISSION COMPLETE') || line.includes('END TRANSMISSION')) return `<div style="font-size: 24px; font-weight: bold; margin: 20px 0;">${line}</div>`;
                if (line.includes('NUR DAWOODANI')) return `<div style="font-size: 32px; font-weight: 900; margin: 12px 0; letter-spacing: 2px;">${line}</div>`;
                if (line.includes('Senior Business Analyst') || line.includes('Achievement') || line.includes('Narrative') || line.includes('Skills')) return `<div style="font-size: 18px; opacity: 0.85; margin: 8px 0; font-weight: bold;">${line}</div>`;
                if (line.startsWith('‚Ä¢') || line.startsWith('‚òÖ')) return `<div style="font-size: 16px; margin: 6px 0 6px 20px; opacity: 0.9;">${line}</div>`;
                return `<div style="font-size: 17px; margin: 10px 0;">${line}</div>`;
            }).join('')}</div>`;
            void credits.offsetWidth;
            credits.classList.add('active');
        }
        
        function generateNarrativeCredits(meta) {
            // Generate story-specific credits that narrate what happened and connect to resume
            const battleName = meta.overlayTitle || 'TACTICAL ENGAGEMENT';
            const battleSubtitle = meta.overlaySubtitle || 'Strategic Operation';
            
            const narrativeMap = {
                'THE PHANTOM MENACE ENGAGEMENT': {
                    opening: 'The blockade was absolute. The odds insurmountable. Yet one analyst saw the path through chaos.',
                    climax: 'As enemy defenses crumbled, precision prevailed over overwhelming force.',
                    narrative: 'Nur Dawoodani orchestrated rapid transformations under extreme pressure. Systems that seemed impossible to evolve were rebuilt in weeks, not months. Agility was the weapon that won this battle.',
                    closing: 'In the silence after victory, a new era of digital agility began.'
                },
                'ATTACK OF THE CLONES ‚Äî GEONOSIS ARENA': {
                    opening: 'The enemy activated twelve separate fronts. Synchronization seemed impossible. Communication was fragmented. Stakes were highest they had ever been.',
                    climax: 'Through precision orchestration, twelve independent teams moved as one organism.',
                    narrative: 'Nur orchestrated cross-functional teams across competing business units. Dependencies that threatened collapse were managed with surgical precision. Leadership proved that coordination across chaos creates unstoppable momentum.',
                    closing: 'The combined might of unified teams proved greater than the sum of fragmented forces.'
                },
                'REVENGE OF THE SITH ‚Äî CORUSCANT SIEGE': {
                    opening: 'Regulatory obstacles compounded technical complexity. The deadline was immovable.',
                    climax: 'With architectural precision, the mission delivered on time despite overwhelming challenges.',
                    narrative: 'Nur navigated impossible constraints‚Äîregulatory mandates, technical debt, hard deadlines. Each decision was high-stakes. Every timeline held. Every requirement met.',
                    closing: 'The hero finds the path when all others say there is none.'
                },
                'A NEW HOPE ‚Äî DEATH STAR ASSAULT': {
                    opening: 'A small team. An impossible target. Conventional wisdom said it could not be done.',
                    climax: 'Data-driven execution transformed customer discovery. Revenue streams that had stalled began to flow.',
                    narrative: 'Nur pioneered AI-driven product innovations that generated $2M+ annual revenue. These were not incremental improvements‚Äîthey were transformative breakthroughs. Small teams with big ideas and precise execution can reshape entire markets.',
                    closing: '$2M+ in annual value. All created by vision, precision, and unwavering belief in possibility.'
                },
                'THE EMPIRE STRIKES BACK ‚Äî HOTH DEFENSE': {
                    opening: 'Critical systems were failing. Migration was in progress. Downtime meant millions lost per minute.',
                    climax: 'Real-time mitigation prevented catastrophe. 100% uptime was maintained despite impossible conditions.',
                    narrative: 'Nur held the line when everything threatened to collapse. During a $5M+ critical migration, systems stayed online every second. Crisis management at this scale requires nerves of steel, deep technical knowledge, and unwavering focus.',
                    closing: '$5M+ in revenue protected by one analyst who refused to let systems fall.'
                },
                'RETURN OF THE JEDI ‚Äî ENDOR ASSAULT': {
                    opening: 'Three fronts. Three systems. Three teams. Perfect synchronization required or everything failed.',
                    climax: 'Each element moved with precision timing. Interdependencies became strengths instead of vulnerabilities.',
                    narrative: 'Nur orchestrated a $4M+ enterprise transformation across warehouse, e-commerce, and retail systems simultaneously. Program-level leadership at the highest complexity.',
                    closing: '$4M+ in digital transformation delivered through perfect orchestration.'
                },
                'ROGUE ONE ‚Äî SCARIF INFILTRATION': {
                    opening: 'The mission was unauthorized. Success seemed impossible. Failure meant career risk.',
                    climax: 'Bold action and technical precision delivered what seemed undeliverable.',
                    narrative: 'Nur championed innovation when conservative thinking dominated. He eliminated 2M+ documents annually‚Äîa transformation that seemed reckless until results proved otherwise. Sometimes the greatest achievements require the courage to take risks when everyone else says to wait.',
                    closing: '2M+ documents eliminated. A whole new era of digital efficiency unlocked by one analyst\'s conviction.'
                },
                'SOLO ‚Äî KESSEL RUN ESCAPE': {
                    opening: 'Six months was the timeline. Management expected failure. The path was unclear.',
                    climax: 'Through creative architectural solutions, the impossible compressed into the achievable.',
                    narrative: 'Nur reduced a 6-month initiative to 3 months. A 60% reduction in project duration with zero compromises on quality. Creative problem-solving combined with technical mastery produced breakthroughs that seemed impossible.',
                    closing: 'The fastest, cleanest delivery. Proof that innovation and speed can coexist.'
                }
            };
            
            const details = narrativeMap[battleName] || {
                opening: 'Against formidable odds, one analyst made the difference.',
                climax: 'Victory was achieved through precision and unwavering focus.',
                narrative: 'Nur Dawoodani transformed enterprise systems and led teams to success where conventional thinking said failure was inevitable.',
                closing: 'Another victory for digital transformation.'
            };
            
            return [
                '',
                '',
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                'MISSION COMPLETE',
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                '',
                battleName,
                battleSubtitle,
                '',
                'THE CHALLENGE',
                details.opening,
                '',
                'THE TURNING POINT',
                details.climax,
                '',
                'THE BREAKTHROUGH',
                details.narrative,
                '',
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                'NUR DAWOODANI',
                'Business Analyst ‚Ä¢ 18+ Years ‚Ä¢ Global Enterprise Transformation',
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                '',
                'CORE COMPETENCIES',
                '‚òÖ Enterprise System Architecture ‚Ä¢ SAFe Agile Leadership',
                '‚òÖ Digital Transformation at Scale ‚Ä¢ Business Process Optimization',
                '‚òÖ Stakeholder Management ‚Ä¢ Risk Mitigation ‚Ä¢ Crisis Resolution',
                '‚òÖ AI/ML Product Innovation ‚Ä¢ Data-Driven Decision Making',
                '',
                'KEY ACHIEVEMENTS',
                '‚òÖ $2M+ annual revenue generated through AI-driven innovations',
                '‚òÖ $4M+ enterprise transformation orchestrated across multiple systems',
                '‚òÖ $5M+ revenue protected during critical migrations with zero downtime',
                '‚òÖ 2M+ documents eliminated annually through digital transformation',
                '‚òÖ 60% project duration reduction while maintaining quality standards',
                '‚òÖ 12+ cross-functional teams orchestrated across competing priorities',
                '',
                'EXPERIENCE',
                '‚Ä¢ Lululemon: Retail Transformation & System Migration Leadership',
                '‚Ä¢ HSBC: Enterprise Architecture & Digital Innovation',
                '‚Ä¢ Multiple Industries: Banking, Retail, Financial Services',
                '',
                details.closing,
                '',
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                'END TRANSMISSION',
                ''
            ];
        }

        function startBattleVideoPlayback() {
            const battleSceneEl = document.getElementById('battle-scene');
            const videoLayer = document.getElementById('battle-video-layer');
            const video = document.getElementById('battle-video');
            const transition = document.getElementById('battle-video-transition');
            const battleHud = document.getElementById('battle-hud');
            const battleCanvas = document.getElementById('battle-canvas');
            const audioControls = document.getElementById('audio-controls');
            const videoControls = document.getElementById('battle-video-controls');
            const videoOverlay = document.getElementById('battle-video-overlay');
            const videoProgress = document.getElementById('battle-video-progress');
            const story = document.getElementById('battle-video-story');

            if (!videoLayer || !video || !transition) return;

            renderMode = 'video';
            battleSceneEl.style.display = 'block';
            videoLayer.style.display = 'block';
            if (battleCanvas) battleCanvas.style.display = 'none';
            if (battleHud) battleHud.style.display = 'none';
            if (videoOverlay) videoOverlay.style.display = 'block';
            if (story) story.style.display = 'none';
            if (audioControls) {
                audioControls.style.opacity = '0';
                audioControls.style.pointerEvents = 'none';
            }

            stopCurrentAudio();

            transition.style.opacity = '1';

            // Use existing video metadata if story phase already selected one, otherwise pick a new one
            let src;
            if (!currentBattleVideoMeta) {
                src = getRandomBattleVideoSrc();
                currentBattleVideoMeta = getBattleVideoMeta(src);
            } else {
                // Get the video source from the metadata to maintain consistency
                const videoName = currentBattleVideoMeta.movie || 'Episode 1 battle';
                const videoMap = {
                    'Episode I ‚Äî The Phantom Menace': 'assets/videos/Episode 1 battle.mp4',
                    'Episode II ‚Äî Attack of the Clones': 'assets/videos/Episode 2 battle.mp4',
                    'Episode III ‚Äî Revenge of the Sith': 'assets/videos/Episode 3 battle.mp4',
                    'Episode IV ‚Äî A New Hope': 'assets/videos/Episode 4 battle.mp4',
                    'Episode V ‚Äî The Empire Strikes Back': 'assets/videos/Episode 5 battle.mp4',
                    'Episode VI ‚Äî Return of the Jedi': 'assets/videos/Episode 6 battle.mp4',
                    'Rogue One': 'assets/videos/Rogue 1 Battle.mp4',
                    'Solo: A Star Wars Story': 'assets/videos/SOLO battle.mp4'
                };
                src = videoMap[videoName] || getRandomBattleVideoSrc();
            }
            video.controls = false;
            video.style.display = 'block';
            video.src = src;
            video.currentTime = 0;
            video.muted = !soundEnabled;
            video.playsInline = true;
            video.load();

            // Update overlay with video metadata but NOT story
            const title = document.getElementById('battle-video-title');
            const subtitle = document.getElementById('battle-video-subtitle');
            const tagline = document.getElementById('battle-video-tagline');
            if (title) title.textContent = currentBattleVideoMeta.overlayTitle || '';
            if (subtitle) subtitle.textContent = currentBattleVideoMeta.overlaySubtitle || '';
            if (tagline) tagline.textContent = currentBattleVideoMeta.overlayTagline || '';

            video.onended = () => {
                if (videoOverlay) videoOverlay.style.display = 'none';
                if (transition) transition.style.opacity = '1';
                if (video) {
                    video.pause();
                    video.style.display = 'none';
                    video.muted = true; // Mute video audio
                }
                if (videoLayer) videoLayer.style.display = 'block';
                
                // Smooth fade out of video audio and any background audio
                try {
                    if (audioContext?.state === 'running') {
                        const now = audioContext.currentTime;
                        
                        // Fade out video element audio
                        if (video && video.volume !== undefined) {
                            const videoVolume = video.volume;
                            video.volume = Math.max(0, videoVolume - 0.1); // Quick fade
                            const volumeFade = setInterval(() => {
                                if (video.volume > 0) {
                                    video.volume = Math.max(0, video.volume - 0.05);
                                } else {
                                    clearInterval(volumeFade);
                                }
                            }, 50);
                        }
                        
                        // Fade out background audio if it exists
                        if (currentAudio && currentAudio.gainNode) {
                            currentAudio.gainNode.gain.cancelScheduledValues(now);
                            currentAudio.gainNode.gain.setValueAtTime(currentAudio.gainNode.gain.value, now);
                            currentAudio.gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.8); // 0.8 second fade
                        }
                    }
                } catch(e) {
                    // Silently handle audio context errors
                }
                
                showBattleVideoCredits(currentBattleVideoMeta || { credits: ['Mission Complete'] });
                playNurWarsSound('victory');
                setTimeout(() => {
                    showingBattleVideoCredits = false;
                    // Stop blackhole audio if it's playing
                    if (window.currentBlackholeAudio) {
                        window.currentBlackholeAudio.pause();
                        window.currentBlackholeAudio.currentTime = 0;
                    }
                    window.location.reload();
                }, 35000);
            };

            if (videoControls) {
                videoControls.style.opacity = '0';
                const playBtn = document.getElementById('video-play-btn');
                const backBtn = document.getElementById('video-back-btn');
                const fwdBtn = document.getElementById('video-forward-btn');
                const muteBtn = document.getElementById('video-mute-btn');
                const scrubber = document.getElementById('video-scrubber');
                if (playBtn) playBtn.onclick = (e) => { e.stopPropagation(); toggleBattleVideoPlayPause(); };
                if (backBtn) backBtn.onclick = (e) => { e.stopPropagation(); skipBattleVideo(-5); };
                if (fwdBtn) fwdBtn.onclick = (e) => { e.stopPropagation(); skipBattleVideo(5); };
                if (muteBtn) muteBtn.onclick = (e) => { e.stopPropagation(); toggleBattleVideoMute(); };
                if (scrubber) {
                    scrubber.oninput = (e) => {
                        e.stopPropagation();
                        const videoRef = document.getElementById('battle-video');
                        if (!videoRef || Number.isNaN(videoRef.duration)) return;
                        const scrubPosition = Number(scrubber.value);
                        const storyDuration = 35; // Crawl story was 35 seconds
                        // If seeking into video portion, adjust video time
                        if (scrubPosition > storyDuration) {
                            videoRef.currentTime = scrubPosition - storyDuration;
                        } else if (scrubPosition < storyDuration) {
                            // If seeking before video, restart it
                            videoRef.currentTime = 0;
                        }
                        updateBattleVideoProgress();
                    };
                }
            }

            video.ontimeupdate = updateBattleVideoProgress;
            video.onloadedmetadata = updateBattleVideoProgress;
            video.onplay = updateBattleVideoControls;
            video.onpause = updateBattleVideoControls;

            const handleShowControls = () => {
                if (videoControls) videoControls.style.opacity = '1';
                if (videoProgress) videoProgress.style.opacity = '1';
                if (battleVideoIdleTimer) clearTimeout(battleVideoIdleTimer);
                battleVideoIdleTimer = setTimeout(() => {
                    if (videoControls) videoControls.style.opacity = '0';
                    // Keep progress bar visible always
                    if (videoProgress) videoProgress.style.opacity = '1';
                }, 2000);
            };
            videoLayer.onmousemove = handleShowControls;
            videoLayer.onmouseenter = handleShowControls;
            videoLayer.ontouchstart = handleShowControls;

            setTimeout(() => {
                window.battleVideoStartTime = Date.now();
                video.play().catch(() => {
                    if (videoControls) videoControls.style.opacity = '1';
                });
                updateBattleVideoControls();
                updateBattleVideoProgress();
                transition.style.opacity = '0';
                // Keep progress visible throughout
                if (videoProgress) videoProgress.style.opacity = '1';
            }, 25);
        }

        function stopBattleVideoPlayback() {
            const videoLayer = document.getElementById('battle-video-layer');
            const video = document.getElementById('battle-video');
            const transition = document.getElementById('battle-video-transition');
            const videoControls = document.getElementById('battle-video-controls');
            const videoOverlay = document.getElementById('battle-video-overlay');
            const videoProgress = document.getElementById('battle-video-progress');

            if (battleVideoIdleTimer) {
                clearTimeout(battleVideoIdleTimer);
                battleVideoIdleTimer = null;
            }

            if (video) {
                video.pause();
                video.removeAttribute('src');
                video.load();
                video.controls = false;
                video.onended = null;
                video.ontimeupdate = null;
                video.onloadedmetadata = null;
                video.onplay = null;
                video.onpause = null;
            }

            if (transition) transition.style.opacity = '0';
            if (videoControls) videoControls.style.opacity = '0';
            if (videoProgress) videoProgress.style.opacity = '0';
            if (videoOverlay) videoOverlay.style.display = 'none';
            if (videoLayer) videoLayer.style.display = 'none';
        }
        
        function showCrawlSequence(crawlLocation) {
            // Position camera for crawl view in isolated 3D space far from solar system
            camera.position.copy(crawlLocation);
            camera.rotation.z = 0;
            
            // Expand camera far plane to see more of 3D space
            camera.far = 100000;
            camera.updateProjectionMatrix();
            
            // Get the crawl text element and start 3D animation
            const crawlText = document.getElementById('crawl-text');
            
            // If in battle video mode, replace text with battle-specific story
            if (battleVideoMode && currentBattleVideoMeta) {
                const storyLines = currentBattleVideoMeta.story || [];
                const storyHTML = `
                    <div style="height: 50vh;"></div>
                    ${storyLines.map(line => {
                        if (line === '') return '<div style="height: 20px;"></div>';
                        return `<p style="margin: 0 0 30px 0;">${line}</p>`;
                    }).join('')}
                `;
                crawlText.innerHTML = storyHTML;
            }
            
            // Reset position and styles for 3D effect
            crawlText.style.animation = 'none';
            crawlText.style.transition = 'none';
            crawlText.className = '';
            crawlText.style.position = 'absolute';
            crawlText.style.left = '50%';
            crawlText.style.transformOrigin = '50% 0%';
            crawlText.style.opacity = '1';
            
            // Show crawl overlay first
            const container = document.getElementById('nur-wars-container');
            const crawl = document.getElementById('opening-crawl');
            const battle = document.getElementById('battle-scene');
            
            container.style.display = 'block';
            crawl.style.display = 'block';
            battle.style.display = 'none';
            
            // Track timeline events
            let openingSoundPlayed = false;
            let battleTransitioned = false;
            const crawlStartTime = movieStartTime;
            const totalDuration = 35000; // Total crawl duration - reduced for faster battle start
            
            // Start scroll animation immediately
            start3DCrawlAnimation(crawlText);
            
            // Track progress and update scrubber
            function updateProgressDuringCrawl() {
                if (!nurWarsActive) return;
                
                const elapsed = moviePaused ? moviePauseTime : (Date.now() - movieStartTime);
                const progress = Math.min(elapsed / totalDuration, 1);
                
                // Update scrubber for crawl phase (0-35s of 145s total)
                const scrubber = document.getElementById('video-scrubber');
                const timeDisplay = document.getElementById('video-time');
                
                if (scrubber) scrubber.value = elapsed;
                if (timeDisplay) {
                    const totalSec = 145; // 35s crawl + 90s video + 20s credits
                    const current = Math.floor(elapsed / 1000);
                    const curMin = Math.floor(current / 60);
                    const curSec = current % 60;
                    const totMin = Math.floor(totalSec / 60);
                    const totSec = totalSec % 60;
                    timeDisplay.textContent = `${curMin}:${String(curSec).padStart(2, '0')} / ${totMin}:${String(totSec).padStart(2, '0')}`;
                }
                
                requestAnimationFrame(updateProgressDuringCrawl);
            }
            
            if (battleVideoMode) {
                updateProgressDuringCrawl();
            }
            
            // Check for timeline events on every frame
            function checkCrawlTimeline() {
                if (!nurWarsActive) return;
                
                const elapsed = moviePaused ? moviePauseTime : (Date.now() - movieStartTime);
                
                // Play opening sound at 2.8 seconds
                if (!openingSoundPlayed && elapsed >= 2800) {
                    playNurWarsSound('opening');
                    openingSoundPlayed = true;
                }
                
                // Transition to battle when scroll completes (at totalDuration)
                if (!battleTransitioned && elapsed >= totalDuration) {
                    battleTransitioned = true;
                    transitionToBattle(crawlLocation);
                    return; // Stop checking timeline
                }
                
                if (elapsed < totalDuration) {
                    requestAnimationFrame(checkCrawlTimeline);
                }
            }
            
            checkCrawlTimeline();
        }
        
        function start3DCrawlAnimation(element) {
            const totalDuration = 35000; // Reduced to 35s for faster transition to battle
            
            // Start large at bottom, move up and get smaller
            element.style.top = '100vh';
            element.style.willChange = 'transform';
            element.style.opacity = '1';
            
            // Show opening text first
            const openingText = document.getElementById('opening-text');
            const imageContainer = document.getElementById('nurwars-image-container');

            function animateFrame() {
                if (!nurWarsActive) return;
                
                // Get elapsed time respecting pause state
                const elapsed = moviePaused ? moviePauseTime : (Date.now() - movieStartTime);
                const progress = Math.min(elapsed / totalDuration, 1); // Clamp progress to 0-1
                
                // Show opening text for first 2.5 seconds (static, no scroll effect)
                if (elapsed < 2500) {
                    openingText.style.display = 'block';
                    openingText.style.opacity = Math.min(1, elapsed / 500); // Fade in first 500ms
                } else if (elapsed < 3500) {
                    openingText.style.opacity = Math.max(0, 1 - ((elapsed - 2500) / 500)); // Fade out over 500ms
                } else {
                    openingText.style.display = 'none';
                }
                
                // Nur Wars image appears at 3.5 seconds (when music starts) and scrolls with text
                if (elapsed >= 3500 && elapsed < 25000) {
                    imageContainer.style.display = 'block';
                    
                    // Apply same scroll animation to image starting at 3.5 second mark
                    const imageProgress = Math.min((elapsed - 3500) / (totalDuration - 3500), 1);
                    const distance = window.innerHeight * 2;
                    const imageY = -distance * imageProgress;
                    const imageRotation = 60 * imageProgress;
                    const imageScale = 1.0 - (0.95 * imageProgress);
                    const imageZ = -500 * imageProgress;
                    
                    imageContainer.style.transform = `translate(-50%, calc(-50% + ${imageY}px)) rotateX(${imageRotation}deg) scale(${imageScale}) translateZ(${imageZ}px)`;
                } else {
                    imageContainer.style.display = 'none';
                }
                
                // Apply scroll animation to entire text (including image)
                // Constant speed upward motion - linear only
                const distance = window.innerHeight * 2;
                const currentY = -distance * progress;
                
                // Linear rotation to create receding effect
                const rotationAngle = 60 * progress;
                
                // Uniform scale reduction - shrink both width and height proportionally
                const currentScale = 1.0 - (0.95 * progress);
                
                // Z depth for receding effect
                const currentZ = -500 * progress;
                
                element.style.transform = `translateX(-50%) translateY(${currentY}px) rotateX(${rotationAngle}deg) scale(${currentScale}) translateZ(${currentZ}px)`;
                
                // Only continue animation if not finished
                if (elapsed < totalDuration) {
                    requestAnimationFrame(animateFrame);
                }
            }
            
            animateFrame();
        }
        
        function transitionToBattle(currentLocation) {
            // Fade out crawl music/audio smoothly when transitioning to video
            if (battleVideoMode) {
                // Fade out current audio with longer decay time for smooth transition
                if (currentAudio && currentAudio.paused === false) {
                    try {
                        const now = audioContext?.currentTime || 0;
                        if (audioContext?.state === 'running' && currentAudio.gainNode) {
                            currentAudio.gainNode.gain.cancelScheduledValues(now);
                            currentAudio.gainNode.gain.setValueAtTime(currentAudio.gainNode.gain.value, now);
                            currentAudio.gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1.5); // 1.5 second fade
                            setTimeout(() => {
                                if (currentAudio) currentAudio.pause();
                            }, 1500);
                        }
                    } catch(e) {
                        if (currentAudio) currentAudio.pause();
                    }
                }
            }
            
            // Play battle transition sound only for 3D battle
            if (!battleVideoMode) {
                playNurWarsSound('battle');
            }
            
            // Fade out crawl with slower pan/zoom effect
            const crawl = document.getElementById('opening-crawl');
            crawl.style.animation = 'panZoomToBattle 4s ease-in-out forwards'; 
            
            // Move camera to battle location (closer to solar system) with slower transition
            const battleLocation = new THREE.Vector3(currentLocation.x + 800, currentLocation.y - 150, currentLocation.z - 1200);
            const battleCamPos = new THREE.Vector3(battleLocation.x, battleLocation.y, battleLocation.z + 800);
            
            // Star Wars style pan down transition
            // Start looking straight ahead (where crawl was going)
            const startLookAt = new THREE.Vector3(0, 0, -1000).applyQuaternion(camera.quaternion).add(camera.position);
            // End looking at the battle scene (Death Star location)
            const endLookAt = battleLocation.clone();
            
            const transitionStart = Date.now();
            const transitionDuration = 2000; // 2 seconds quick transition to battle
            
            function animateToBattle() {
                if (!nurWarsActive) return;
                
                const elapsed = Date.now() - transitionStart;
                const progress = Math.min(elapsed / transitionDuration, 1);
                const eased = easeInOut(progress);
                
                // Move camera to battle position
                camera.position.lerpVectors(currentLocation, battleCamPos, eased);
                
                // Pan the camera (look down effect)
                const currentLook = new THREE.Vector3().lerpVectors(startLookAt, endLookAt, eased);
                camera.lookAt(currentLook);
                
                if (progress >= 1) {
                    // Start battle scene
                    crawl.style.display = 'none';
                    crawl.style.animation = 'none';
                    
                    const battle = document.getElementById('battle-scene');
                    battle.style.display = 'block';

                    if (battleVideoMode) {
                        // Start video playback directly (story was shown in crawl)
                        startBattleVideoPlayback();
                    } else {
                        init3DBattleScene(battleLocation);
                    }
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animateToBattle);
                }
            }
            
            animateToBattle();
        }

        function closeNurWars() {
            nurWarsActive = false;
            renderMode = 'default';

            stopBattleVideoPlayback();
            
            // Clear all pending timeouts
            clearNurWarsTimeouts();
            
            const container = document.getElementById('nur-wars-container');
            container.style.display = 'none';
            
            // Hide audio controls and exit button when exiting NUR WARS
            const audioControls = document.getElementById('audio-controls');
            if (audioControls) {
                audioControls.style.opacity = '0';
                audioControls.style.pointerEvents = 'none';
            }
            
            const exitBtn = document.getElementById('exit-hyperspace-btn');
            if (exitBtn) {
                exitBtn.style.display = 'none';
            }
            
            // Restore UI
            document.body.classList.remove('nur-wars-active');
            
            // Stop NUR WARS audio and restore background audio
            stopCurrentAudio();
            if (typeof backgroundAudio !== 'undefined' && backgroundAudio && soundEnabled && backgroundAudio.audioContext.state === 'suspended') {
                backgroundAudio.audioContext.resume().catch(e => console.log('Audio resume failed:', e));
            }
            
            // Restore original camera and controls
            controls.enabled = true;
            
            // Restore main canvas z-index
            const mainCanvas = webGLRenderer.domElement;
            mainCanvas.style.zIndex = '';
            
            // Smooth transition back to original solar system view
            const returnDuration = 3000; // Slower return
            const startTime = Date.now();
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            
            // Reset to overview position
            const targetPos = new THREE.Vector3(0, 200, 800);
            const targetLookAt = new THREE.Vector3(0, 0, 0);
            
            function animateReturn() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / returnDuration, 1);
                const eased = easeInOut(progress);
                
                camera.position.lerpVectors(startPos, targetPos, eased);
                controls.target.lerpVectors(startTarget, targetLookAt, eased);
                camera.rotation.z = 0; // Reset any rotation
                
                if (progress < 1) {
                    requestAnimationFrame(animateReturn);
                } else {
                    // Reload page after battle completes naturally
                    window.location.reload();
                }
            }
            
            animateReturn();
            
            // Reset battle scene variables
            if (battleScene) {
                battleScene = null;
            }
            
            nurWarsCamera = null;
            nurWarsScene = null;
            nurWarsObjects = [];
            battlePhase = 'approach';
            battleTimer = 0;
            explosions = [];
            lasers = [];
            finalExplosionStarted = false;
        }

        // === ENHANCED SOUND SYSTEM FOR NUR WARS ===
        let nurWarsSounds = {};
        let currentAudio = null;
        let audioContext = null;
        
        function initNurWarsSounds() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                nurWarsSounds = {
                    opening: () => playRealStarWarsTheme(),
                    crawl: () => {}, // Continue playing main theme from opening
                    battle: () => playRealBattleMusic(),
                    laser: () => playLaserSound(),
                    explosion: () => playExplosionSound(),
                    victory: () => playVictoryFanfare()
                };
            } catch (e) {
                console.warn('Audio not supported');
            }
        }
        
        function stopCurrentAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            updatePlayPauseButton();
            // Fix backgroundAudio reference error - check if it exists and has pause method
            if (typeof backgroundAudio !== 'undefined' && backgroundAudio && typeof backgroundAudio.pause === 'function') {
                try {
                    backgroundAudio.pause();
                } catch (e) {
                    console.log('Background audio pause failed:', e);
                }
            }
        }
        
        function playRealStarWarsTheme() {
            stopCurrentAudio();
            const audio = new Audio('assets/audio/Star Wars Main Theme.mp3');
            audio.volume = 1.0;
            // Ensure audio plays through user interaction
            audio.play().then(() => {
                currentAudio = audio;
                updatePlayPauseButton();
            }).catch(e => {
                console.warn("Audio play failed, falling back to synth", e);
                playStarWarsTheme();
            });
        }
        
        function playRealBattleMusic() {
            stopCurrentAudio();
            const audio = new Audio('assets/audio/Star Wars Battle Background.mp3');
            audio.volume = 0.6;
            audio.loop = true;
            audio.play().then(() => {
                currentAudio = audio;
                updatePlayPauseButton();
            }).catch(e => {
                console.warn("Audio play failed", e);
                playBattleMusic();
            });
        }
        
        function playVictoryFanfare() {
            stopCurrentAudio();
            const audio = new Audio('assets/audio/Epic Star Wars Compilation.mp3');
            audio.currentTime = 952; // 15:52
            audio.volume = 1.0;
            audio.play().then(() => {
                currentAudio = audio;
                updatePlayPauseButton();
            }).catch(e => {
                console.warn("Audio play failed", e);
                playVictoryMusic();
            });
        }
        
        function playStarWarsTheme() {
            if (!audioContext) return;
            
            // Create a rich orchestral-like Star Wars theme
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            masterGain.gain.setValueAtTime(0.4, audioContext.currentTime);
            
            // Main melody (Star Wars theme)
            const melody = [
                {note: 'G4', duration: 0.5, time: 0},
                {note: 'G4', duration: 0.5, time: 0.5},
                {note: 'G4', duration: 0.5, time: 1.0},
                {note: 'C5', duration: 1.5, time: 1.5},
                {note: 'G5', duration: 1.5, time: 3.0},
                {note: 'F5', duration: 0.5, time: 4.5},
                {note: 'E5', duration: 0.5, time: 5.0},
                {note: 'D5', duration: 0.5, time: 5.5},
                {note: 'C6', duration: 1.5, time: 6.0},
                {note: 'G5', duration: 1.0, time: 7.5}
            ];
            
            const noteFreqs = {
                'G4': 392, 'C5': 523.25, 'G5': 783.99, 'F5': 698.46,
                'E5': 659.25, 'D5': 587.33, 'C6': 1046.50
            };
            
            melody.forEach(({note, duration, time}) => {
                // Main oscillator
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(noteFreqs[note], audioContext.currentTime + time);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2000, audioContext.currentTime + time);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime + time);
                gain.gain.linearRampToValueAtTime(0.8, audioContext.currentTime + time + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + time + duration);
                
                osc.start(audioContext.currentTime + time);
                osc.stop(audioContext.currentTime + time + duration);
                
                // Add harmonic
                const harmonic = audioContext.createOscillator();
                const harmonicGain = audioContext.createGain();
                
                harmonic.connect(harmonicGain);
                harmonicGain.connect(masterGain);
                
                harmonic.type = 'sine';
                harmonic.frequency.setValueAtTime(noteFreqs[note] * 2, audioContext.currentTime + time);
                
                harmonicGain.gain.setValueAtTime(0, audioContext.currentTime + time);
                harmonicGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + time + 0.1);
                harmonicGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + time + duration);
                
                harmonic.start(audioContext.currentTime + time);
                harmonic.stop(audioContext.currentTime + time + duration);
            });
        }
        
        function playImperialMarch() {
            if (!audioContext) return;
            
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            masterGain.gain.setValueAtTime(0.3, audioContext.currentTime);
            
            // Imperial March melody
            const march = [
                {note: 'A3', duration: 0.6}, {note: 'A3', duration: 0.6}, {note: 'A3', duration: 0.6},
                {note: 'F3', duration: 0.4}, {note: 'C4', duration: 0.2}, {note: 'A3', duration: 0.6},
                {note: 'F3', duration: 0.4}, {note: 'C4', duration: 0.2}, {note: 'A3', duration: 1.2}
            ];
            
            const noteFreqs = {
                'A3': 220, 'F3': 174.61, 'C4': 261.63
            };
            
            let currentTime = 0;
            
            // Play multiple times for the crawl duration
            for (let repeat = 0; repeat < 12; repeat++) {
                march.forEach(({note, duration}) => {
                    // Bass line
                    const bass = audioContext.createOscillator();
                    const bassGain = audioContext.createGain();
                    const bassFilter = audioContext.createBiquadFilter();
                    
                    bass.connect(bassFilter);
                    bassFilter.connect(bassGain);
                    bassGain.connect(masterGain);
                    
                    bass.type = 'sawtooth';
                    bass.frequency.setValueAtTime(noteFreqs[note], audioContext.currentTime + currentTime);
                    
                    bassFilter.type = 'lowpass';
                    bassFilter.frequency.setValueAtTime(800, audioContext.currentTime + currentTime);
                    
                    bassGain.gain.setValueAtTime(0, audioContext.currentTime + currentTime);
                    bassGain.gain.linearRampToValueAtTime(0.6, audioContext.currentTime + currentTime + 0.05);
                    bassGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + currentTime + duration);
                    
                    bass.start(audioContext.currentTime + currentTime);
                    bass.stop(audioContext.currentTime + currentTime + duration);
                    
                    // Add octave for richness
                    const octave = audioContext.createOscillator();
                    const octaveGain = audioContext.createGain();
                    
                    octave.connect(octaveGain);
                    octaveGain.connect(masterGain);
                    
                    octave.type = 'triangle';
                    octave.frequency.setValueAtTime(noteFreqs[note] * 2, audioContext.currentTime + currentTime);
                    
                    octaveGain.gain.setValueAtTime(0, audioContext.currentTime + currentTime);
                    octaveGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + currentTime + 0.05);
                    octaveGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + currentTime + duration);
                    
                    octave.start(audioContext.currentTime + currentTime);
                    octave.stop(audioContext.currentTime + currentTime + duration);
                    
                    currentTime += duration;
                });
                currentTime += 0.5; // Pause between repeats
            }
        }
        
        function playBattleMusic() {
            if (!audioContext) return;
            
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            masterGain.gain.setValueAtTime(0.25, audioContext.currentTime);
            
            // Create intense battle rhythm
            for (let i = 0; i < 4; i++) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(110 + i * 27.5, audioContext.currentTime);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1500 + i * 200, audioContext.currentTime);
                
                // Create rhythmic pattern
                let time = audioContext.currentTime;
                for (let j = 0; j < 300; j++) {
                    const intensity = 0.3 + Math.sin(j * 0.1) * 0.2;
                    gain.gain.setValueAtTime(intensity, time);
                    gain.gain.setValueAtTime(0.05, time + 0.08);
                    time += 0.15;
                }
                
                osc.start();
                setTimeout(() => osc.stop(), 45000);
            }
        }
        
        function playVictoryMusic() {
            if (!audioContext) return;
            
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            masterGain.gain.setValueAtTime(0.5, audioContext.currentTime);
            
            // Victory fanfare melody
            const victory = [
                {note: 'C5', duration: 0.8, time: 0},
                {note: 'G5', duration: 0.8, time: 0.8},
                {note: 'C6', duration: 1.2, time: 1.6},
                {note: 'G5', duration: 0.6, time: 2.8},
                {note: 'C6', duration: 1.5, time: 3.4}
            ];
            
            const noteFreqs = {
                'C5': 523.25, 'G5': 783.99, 'C6': 1046.50
            };
            
            victory.forEach(({note, duration, time}) => {
                // Main trumpet-like sound
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(noteFreqs[note], audioContext.currentTime + time);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(3000, audioContext.currentTime + time);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime + time);
                gain.gain.linearRampToValueAtTime(0.9, audioContext.currentTime + time + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + time + duration);
                
                osc.start(audioContext.currentTime + time);
                osc.stop(audioContext.currentTime + time + duration);
            });
        }
        
        function playLaserSound() {
            if (!audioContext) return;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(1200, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.3);
            
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(2000, audioContext.currentTime);
            filter.Q.setValueAtTime(5, audioContext.currentTime);
            
            gain.gain.setValueAtTime(0.4, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
        }
        
        function playExplosionSound() {
            if (!audioContext) return;
            
            // Create realistic explosion with multiple components
            const bufferSize = audioContext.sampleRate * 4;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            // Generate explosion noise
            for (let i = 0; i < bufferSize; i++) {
                const decay = Math.pow(1 - i / bufferSize, 1.5);
                data[i] = (Math.random() * 2 - 1) * decay;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            const compressor = audioContext.createDynamicsCompressor();
            
            noise.connect(filter);
            filter.connect(compressor);
            compressor.connect(gain);
            gain.connect(audioContext.destination);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(3000, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 3);
            
            gain.gain.setValueAtTime(0.6, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 4);
            
            noise.start();
        }
        
        function playNurWarsSound(soundName) {
            if (soundEnabled && nurWarsSounds[soundName]) {
                try {
                    nurWarsSounds[soundName]();
                } catch (e) {
                    console.warn('Could not play sound:', soundName);
                }
            }
        }
        
        // Battle scene creation functions
        function createDeathStar(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            modelsToLoad++;
            
            // Load Death Star GLTF model
            gltfLoader.load(
                'Unused/models/death_star_-_star_wars (1)/scene.gltf',
                (gltf) => {
                    const deathStar = gltf.scene;
                    const deathStarRadius = 180;
                    deathStar.scale.set(150, 150, 150);
                    // Place Death Star far in the background
                    deathStar.position.copy(battleLocation).add(new THREE.Vector3(0, 0, -4200));
                    deathStar.rotation.y = Math.PI / 4;
                    deathStar.userData.radius = deathStarRadius;
                    
                    // Add exhaust port on the surface (visible and outside)
                    const exhaustPortGeo = new THREE.SphereGeometry(8, 16, 16);
                    const exhaustPortMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
                    const exhaustPort = new THREE.Mesh(exhaustPortGeo, exhaustPortMat);
                    exhaustPort.position.copy(deathStar.position).add(new THREE.Vector3(0, -30, deathStarRadius));
                    battleSceneRef.add(exhaustPort);
                    deathStar.exhaustPort = exhaustPort;
                    
                    battleSceneRef.add(deathStar);
                    nurWarsObjects.push({ 
                        object: deathStar, 
                        type: 'deathstar' 
                    });
                    
                    modelsLoaded++;
                    console.log('Death Star loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Death Star:', error);
                    modelsLoaded++;
                    checkBattleReady();
                    // Fallback to procedural geometry
                    const deathStarGeo = new THREE.SphereGeometry(300, 32, 32);
                    const deathStarMat = new THREE.MeshStandardMaterial({ 
                        color: 0x333333, 
                        metalness: 0.8, 
                        roughness: 0.3 
                    });
                    const deathStar = new THREE.Mesh(deathStarGeo, deathStarMat);
                    deathStar.position.copy(battleLocation);
                    battleSceneRef.add(deathStar);
                    nurWarsObjects.push({ 
                        object: deathStar, 
                        type: 'deathstar' 
                    });
                }
            );
        }
        
        function createStarDestroyer(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            modelsToLoad++;
            
            // Load Star Destroyer GLTF model
            gltfLoader.load(
                'assets/models/republic_venator_star_destroyer/scene.gltf',
                (gltf) => {
                    const destroyer = gltf.scene;
                    destroyer.scale.set(0.8, 0.8, 0.8);
                    const stageCenter = battleLocation.clone().add(new THREE.Vector3(0, 0, 1600));
                    destroyer.position.set(
                        stageCenter.x - 900,
                        stageCenter.y + 260,
                        stageCenter.z + 300
                    );
                    destroyer.rotation.y = -Math.PI / 4;
                    destroyer.rotation.z = Math.PI / 12;
                    
                    battleSceneRef.add(destroyer);
                    nurWarsObjects.push({ 
                        object: destroyer, 
                        type: 'destroyer',
                        isCapitalShip: true
                    });
                    
                    // Add two more destroyers for a bigger Imperial presence
                    for (let i = 1; i <= 2; i++) {
                        const clone = destroyer.clone();
                        clone.position.set(
                            stageCenter.x - 900 - i * 380,
                            stageCenter.y + 200 + i * 70,
                            stageCenter.z + 500 + i * 240
                        );
                        clone.rotation.y = -Math.PI / 4 + i * 0.12;
                        clone.rotation.z = Math.PI / 12;
                        battleSceneRef.add(clone);
                        nurWarsObjects.push({
                            object: clone,
                            type: 'destroyer',
                            isCapitalShip: true
                        });
                    }

                    modelsLoaded++;
                    console.log('Star Destroyer loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Star Destroyer:', error);
                    modelsLoaded++;
                    checkBattleReady();
                    // Fallback
                    const destroyerGroup = new THREE.Group();
                    const hullGeo = new THREE.ConeGeometry(150, 600, 4);
                    const hullMat = new THREE.MeshStandardMaterial({ 
                        color: 0x444444, 
                        metalness: 0.9, 
                        roughness: 0.2 
                    });
                    const hull = new THREE.Mesh(hullGeo, hullMat);
                    hull.rotation.z = Math.PI / 2;
                    destroyerGroup.add(hull);
                    destroyerGroup.position.set(
                        battleLocation.x - 800,
                        battleLocation.y + 200,
                        battleLocation.z + 500
                    );
                    battleSceneRef.add(destroyerGroup);
                    nurWarsObjects.push({ 
                        object: destroyerGroup, 
                        type: 'destroyer',
                        isCapitalShip: true
                    });
                }
            );
        }
        
        function createMillenniumFalcon(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            modelsToLoad++;
            
            // Load Millennium Falcon GLTF model
            gltfLoader.load(
                'assets/models/star_wars_-_halcon_milenario/scene.gltf',
                (gltf) => {
                    const falcon = gltf.scene;
                    const stageCenter = battleLocation.clone().add(new THREE.Vector3(0, 0, 1600));
                    falcon.scale.set(32, 32, 32);
                    falcon.position.set(
                        stageCenter.x + 300,
                        stageCenter.y - 60,
                        stageCenter.z + 120
                    );
                    falcon.rotation.y = Math.PI / 6;
                    
                    battleSceneRef.add(falcon);
                    nurWarsObjects.push({ 
                        object: falcon, 
                        type: 'falcon' 
                    });
                    
                    modelsLoaded++;
                    console.log('Millennium Falcon loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Millennium Falcon:', error);
                    modelsLoaded++;
                    checkBattleReady();
                }
            );
        }
        
        function createXWings(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            const stageCenter = battleLocation.clone().add(new THREE.Vector3(0, 0, 1600));
            
            // Create 2 X-Wings using GLTF models
            for (let i = 0; i < 2; i++) {
                modelsToLoad++;
                gltfLoader.load(
                    'assets/models/x-wing_cockpit_version_3/scene.gltf',
                    (gltf) => {
                        const xwing = gltf.scene.clone();
                        xwing.scale.set(12, 12, 12);
                        xwing.position.set(
                            stageCenter.x + (i === 0 ? 120 : 260),
                            stageCenter.y - 140,
                            stageCenter.z + 20
                        );
                        xwing.rotation.y = Math.PI / 8;
                        
                        battleSceneRef.add(xwing);
                        nurWarsObjects.push({
                            object: xwing,
                            type: 'xwing',
                            isPlayer: i === 0,
                            health: 100,
                            velocity: new THREE.Vector3(0, 0, -3),
                            target: null
                        });
                        
                        modelsLoaded++;
                        console.log(`X-Wing ${i+1} loaded`, modelsLoaded, '/', modelsToLoad);
                        checkBattleReady();
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading X-Wing:', error);
                        modelsLoaded++;
                        checkBattleReady();
                    }
                );
            }
            
            // Add Anakin's Interceptor
            modelsToLoad++;
            gltfLoader.load(
                'assets/models/swbf2custom_-_anakins_eta-2_actis_interceptor/scene.gltf',
                (gltf) => {
                    const interceptor = gltf.scene;
                    interceptor.scale.set(15, 15, 15);
                    interceptor.position.set(
                        stageCenter.x + 80,
                        stageCenter.y - 120,
                        stageCenter.z - 40
                    );
                    interceptor.rotation.y = Math.PI / 6;
                    
                    battleSceneRef.add(interceptor);
                    nurWarsObjects.push({
                        object: interceptor,
                        type: 'interceptor',
                        isPlayer: false,
                        health: 120,
                        velocity: new THREE.Vector3(0, 0, -3.5),
                        target: null
                    });
                    
                    modelsLoaded++;
                    console.log('Interceptor loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Interceptor:', error);
                    modelsLoaded++;
                    checkBattleReady();
                }
            );
        }
        
        function createTIEInterceptors(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            const stageCenter = battleLocation.clone().add(new THREE.Vector3(0, 0, 1600));
            const interceptorCount = 6;
            modelsToLoad++;
            gltfLoader.load(
                'assets/models/star_wars_tiein_interceptor/scene.gltf',
                (gltf) => {
                    for (let i = 0; i < interceptorCount; i++) {
                        const interceptor = gltf.scene.clone();
                        interceptor.scale.set(9, 9, 9);
                        interceptor.position.set(
                            stageCenter.x + (i - (interceptorCount / 2)) * 140 + 100,
                            stageCenter.y + (Math.random() - 0.5) * 240,
                            stageCenter.z + 450 + (Math.random() - 0.5) * 180
                        );
                        interceptor.rotation.y = Math.PI + Math.PI / 5;
                        battleSceneRef.add(interceptor);
                        nurWarsObjects.push({
                            object: interceptor,
                            type: 'tieinterceptor',
                            health: 60
                        });
                    }
                    modelsLoaded++;
                    console.log('TIE Interceptors loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading TIE Interceptor:', error);
                    modelsLoaded++;
                    checkBattleReady();
                }
            );
        }

        function createTIEFighters(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            const stageCenter = battleLocation.clone().add(new THREE.Vector3(0, 0, 1600));
            
            // Create many TIE Fighters using a single GLTF load and clones
            const tieCount = 18;
            modelsToLoad++;
            gltfLoader.load(
                'assets/models/3d_t.i.e_fighter_-_star_wars_model/scene.gltf',
                (gltf) => {
                    for (let i = 0; i < tieCount; i++) {
                        const tie = gltf.scene.clone();
                        tie.scale.set(8, 8, 8);
                        tie.position.set(
                            stageCenter.x + (i - (tieCount / 2)) * 110 - 200,
                            stageCenter.y + (Math.random() - 0.5) * 260,
                            stageCenter.z + 300 + (Math.random() - 0.5) * 220
                        );
                        tie.rotation.y = Math.PI + Math.PI / 6;
                        
                        battleSceneRef.add(tie);
                        nurWarsObjects.push({
                            object: tie,
                            type: 'tiefighter',
                            health: 50
                        });
                    }
                    
                    modelsLoaded++;
                    console.log(`TIE Fighters loaded`, modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading TIE Fighter:', error);
                    modelsLoaded++;
                    checkBattleReady();
                }
            );
            
            // Add Phantom ship as an enemy
            modelsToLoad++;
            gltfLoader.load(
                'assets/models/phantom/scene.gltf',
                (gltf) => {
                    const phantom = gltf.scene;
                    phantom.scale.set(10, 10, 10);
                    phantom.position.set(
                        stageCenter.x - 260,
                        stageCenter.y + 60,
                        stageCenter.z + 180
                    );
                    phantom.rotation.y = Math.PI + Math.PI / 4;
                    
                    battleSceneRef.add(phantom);
                    nurWarsObjects.push({
                        object: phantom,
                        type: 'phantom',
                        health: 80,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 2.5,
                            (Math.random() - 0.5) * 2,
                            Math.random() * 2.5 + 0.5
                        )
                    });
                    
                    modelsLoaded++;
                    console.log('Phantom loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Phantom:', error);
                    modelsLoaded++;
                    checkBattleReady();
                }
            );
        }
        
        function createRazorCrest(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            const stageCenter = battleLocation.clone().add(new THREE.Vector3(0, 0, 1600));
            modelsToLoad++;
            gltfLoader.load(
                'assets/models/razor_crest/scene.gltf',
                (gltf) => {
                    const razor = gltf.scene;
                    razor.scale.set(18, 18, 18);
                    razor.position.set(
                        stageCenter.x - 320,
                        stageCenter.y - 80,
                        stageCenter.z + 160
                    );
                    razor.rotation.y = Math.PI / 5;
                    battleSceneRef.add(razor);
                    nurWarsObjects.push({ 
                        object: razor, 
                        type: 'razorcrest'
                    });
                    modelsLoaded++;
                    console.log('Razor Crest loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Razor Crest:', error);
                    modelsLoaded++;
                    checkBattleReady();
                }
            );
        }

        function createImperialShuttle(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            const stageCenter = battleLocation.clone().add(new THREE.Vector3(0, 0, 1600));
            modelsToLoad++;
            gltfLoader.load(
                'assets/models/imperial_shuttle/scene.gltf',
                (gltf) => {
                    const shuttle = gltf.scene;
                    shuttle.scale.set(0.6, 0.6, 0.6);
                    shuttle.position.set(
                        stageCenter.x - 520,
                        stageCenter.y + 140,
                        stageCenter.z + 380
                    );
                    shuttle.rotation.y = -Math.PI / 3;
                    battleSceneRef.add(shuttle);
                    nurWarsObjects.push({ 
                        object: shuttle, 
                        type: 'imperialshuttle',
                        isCapitalShip: true
                    });
                    modelsLoaded++;
                    console.log('Imperial Shuttle loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Imperial Shuttle:', error);
                    modelsLoaded++;
                    checkBattleReady();
                }
            );
        }

        function createDistantGalaxies(battleLocation) {
            // Galaxies are now only in solar system, not in battle
            // This keeps the battle clean and focused on the action
            console.log('Battle scene ready - galaxies in solar system only');
        }

        initNurWarsSounds();
        
        function checkBattleReady() {
            if (modelsLoaded >= modelsToLoad && !battleReady) {
                battleReady = true;
                console.log('All models loaded! Battle ready with', nurWarsObjects.length, 'objects');
                setupBattleScript();
            }
        }

        function init3DBattleScene(battleLocation) {
            // Reset loading counters
            modelsToLoad = 0;
            modelsLoaded = 0;
            battleReady = false;
            playerShotFired = false;
            
            // Create 3D scene FIRST before calling create functions
            nurWarsScene = new THREE.Scene();
            nurWarsScene.background = new THREE.Color(0x000000);
            
            // Switch to battle render mode
            renderMode = 'battle';
            
            // Use existing camera
            nurWarsCamera = camera; // Use the main camera
            
            // Set fallback camera position immediately (focus foreground stage)
            const stageCenter = battleLocation.clone().add(new THREE.Vector3(0, 0, 1600));
            nurWarsCamera.position.set(
                stageCenter.x,
                stageCenter.y + 220,
                stageCenter.z + 700
            );
            nurWarsCamera.lookAt(stageCenter);
            
            // Add both starfields from main scene to battle
            scene.children.forEach(child => {
                if (child.type === 'Points') {
                    const battleStarfield = child.clone();
                    nurWarsScene.add(battleStarfield);
                }
            });
            
            // NOW create all battle objects - they will be added to nurWarsScene
            // Create Death Star
            createDeathStar(battleLocation);
            
            // Create Imperial Star Destroyer
            createStarDestroyer(battleLocation);
            
            // Create Millennium Falcon
            createMillenniumFalcon(battleLocation);
            
            // Create X-Wings
            createXWings(battleLocation);
            
            // Create TIE Fighters
            createTIEFighters(battleLocation);
            
            // Create TIE Interceptors
            createTIEInterceptors(battleLocation);
            
            // Create Razor Crest
            createRazorCrest(battleLocation);
            
            // Create Imperial Shuttle
            createImperialShuttle(battleLocation);
            
            // Create distant galaxies
            createDistantGalaxies(battleLocation);

            // Wait for models to load before adjusting camera
            const waitForModels = setInterval(() => {
                if (battleReady && nurWarsObjects.length > 0) {
                    clearInterval(waitForModels);
                    console.log('Adjusting camera for', nurWarsObjects.length, 'loaded objects');
                    
                    // Frame the battle so all ships are visible
                    const allShips = nurWarsObjects.filter(obj => 
                        obj.type === 'xwing' || obj.type === 'tiefighter' || 
                        obj.type === 'falcon' || obj.type === 'interceptor' || obj.type === 'phantom'
                    );
                    
                    if (allShips.length > 0) {
                        const focusCenter = new THREE.Vector3();
                        const tempPos = new THREE.Vector3();
                        allShips.forEach(obj => {
                            obj.object.getWorldPosition(tempPos);
                            focusCenter.add(tempPos);
                        });
                        focusCenter.multiplyScalar(1 / allShips.length);
                        console.log('Camera focusing on center:', focusCenter);
                        
                        nurWarsCamera.position.copy(focusCenter).add(new THREE.Vector3(0, 300, 1000));
                        nurWarsCamera.lookAt(focusCenter);
                    }
                }
            }, 100);
            
            // Add lighting for battle
            const battleAmbient = new THREE.AmbientLight(0xffffff, 0.8);
            nurWarsScene.add(battleAmbient);
            
            const battleLight = new THREE.DirectionalLight(0xffffff, 1.5);
            battleLight.position.set(100, 200, 300);
            nurWarsScene.add(battleLight);
            
            const battleLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            battleLight2.position.set(-100, -100, 200);
            nurWarsScene.add(battleLight2);
            
            function buildProceduralTIEFighter() {
                const tieGroup = new THREE.Group();

                // Cockpit ball - more detailed hexagonal sphere
                const cockpitGeometry = new THREE.SphereGeometry(10, 12, 12);
                const cockpitMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    metalness: 0.8,
                    roughness: 0.3
                });
                const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
                tieGroup.add(cockpit);

                // Viewport windows
                const windowGeometry = new THREE.CircleGeometry(4, 8);
                const windowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x88aaff,
                    transparent: true,
                    opacity: 0.3
                });

                // Front window
                const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                frontWindow.position.z = 10;
                tieGroup.add(frontWindow);

                // Back window
                const backWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                backWindow.position.z = -10;
                backWindow.rotation.y = Math.PI;
                tieGroup.add(backWindow);

                // Hexagonal solar panels - more detailed
                const panelShape = new THREE.Shape();
                const hexRadius = 35;
                for (let j = 0; j < 6; j++) {
                    const angle = j * Math.PI / 3;
                    panelShape.lineTo(Math.cos(angle) * hexRadius, Math.sin(angle) * hexRadius);
                }
                panelShape.closePath();

                const extrudeSettings = { depth: 2, bevelEnabled: false };
                const panelGeometry = new THREE.ExtrudeGeometry(panelShape, extrudeSettings);
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    metalness: 0.9,
                    roughness: 0.4,
                    side: THREE.DoubleSide
                });

                // Left solar panel
                const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                leftPanel.position.x = -18;
                leftPanel.rotation.y = Math.PI / 2;
                tieGroup.add(leftPanel);

                // Panel frame (left)
                const frameGeometry = new THREE.TorusGeometry(35, 1.5, 6, 6);
                const frameMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444444,
                    metalness: 0.8,
                    roughness: 0.3
                });
                const leftFrame = new THREE.Mesh(frameGeometry, frameMaterial);
                leftFrame.position.x = -18;
                leftFrame.rotation.y = Math.PI / 2;
                tieGroup.add(leftFrame);

                // Right solar panel
                const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                rightPanel.position.x = 18;
                rightPanel.rotation.y = Math.PI / 2;
                tieGroup.add(rightPanel);

                // Panel frame (right)
                const rightFrame = new THREE.Mesh(frameGeometry, frameMaterial);
                rightFrame.position.x = 18;
                rightFrame.rotation.y = Math.PI / 2;
                tieGroup.add(rightFrame);

                // Connecting struts
                const strutGeometry = new THREE.CylinderGeometry(1.5, 1.5, 16, 8);
                const strutMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x666666,
                    metalness: 0.7,
                    roughness: 0.4
                });

                const leftStrut = new THREE.Mesh(strutGeometry, strutMaterial);
                leftStrut.position.x = -9;
                leftStrut.rotation.z = Math.PI / 2;
                tieGroup.add(leftStrut);

                const rightStrut = new THREE.Mesh(strutGeometry, strutMaterial);
                rightStrut.position.x = 9;
                rightStrut.rotation.z = Math.PI / 2;
                tieGroup.add(rightStrut);

                return tieGroup;
            }
        }



        let battlePhase = 'approach';
        let battleTimer = 0;
        let explosions = [];
        let cameraTarget = new THREE.Vector3();
        let finalExplosionStarted = false;
        let lastBattlePhase = '';
        let playerShotFired = false;
        let battleScriptReady = false;
        let battleCameraDesiredPos = new THREE.Vector3();
        let battleCameraDesiredLook = new THREE.Vector3();
        let battleCameraLookCurrent = new THREE.Vector3();
        let battleCameraInitialized = false;
        let lastLaserSoundAt = 0;
        let battleStoryEvents = null;
        let battleStoryIndex = 0;
        let battleCameraFocusOverride = null;
        let battleCameraFocusUntil = 0;

        function getPathPoint(path, t) {
            if (!path || path.length < 2) return null;
            const segCount = path.length - 1;
            const scaled = Math.min(Math.max(t, 0), 1) * segCount;
            const idx = Math.min(Math.floor(scaled), segCount - 1);
            const localT = scaled - idx;
            return new THREE.Vector3().lerpVectors(path[idx], path[idx + 1], localT);
        }

        function setupBattleScript() {
            if (battleScriptReady) return;
            battleScriptReady = true;

            const deathStar = nurWarsObjects.find(obj => obj.type === 'deathstar');
            const deathStarPos = deathStar ? deathStar.object.position.clone() : new THREE.Vector3();
            const stageCenter = deathStarPos.clone().add(new THREE.Vector3(0, 0, 1600));
            const deathStarRadius = deathStar && deathStar.object.userData.radius ? deathStar.object.userData.radius : 180;
            const exhaust = deathStar && deathStar.exhaustPort ? deathStar.exhaustPort.position.clone() : deathStarPos.clone().add(new THREE.Vector3(0, -30, deathStarRadius));
            const exhaustNormal = exhaust.clone().sub(deathStarPos).normalize();

            // Scripted paths and kill events
            nurWarsObjects.forEach(obj => {
                if (obj.type === 'xwing') {
                    const start = obj.object.position.clone();
                    const p1 = stageCenter.clone().add(new THREE.Vector3(350, 140, 200));
                    const p2 = stageCenter.clone().add(new THREE.Vector3(100, 60, -80));
                    const p3 = stageCenter.clone().add(new THREE.Vector3(30, 20, -200));
                    const p4 = exhaust.clone().add(exhaustNormal.clone().multiplyScalar(deathStarRadius * 1.0)).add(new THREE.Vector3(0, 25, 50));
                    const p5 = exhaust.clone().add(exhaustNormal.clone().multiplyScalar(deathStarRadius * 0.75)).add(new THREE.Vector3(0, 15, 25));
                    const p6 = exhaust.clone().add(exhaustNormal.clone().multiplyScalar(deathStarRadius * 0.5));
                    obj.path = [start, p1, p2, p3, p4, p5, p6];
                    obj.pathStart = obj.isPlayer ? 0 : 2;
                    obj.pathDuration = obj.isPlayer ? 280 : 160;
                    obj.destroyAt = obj.isPlayer ? null : 215 + Math.random() * 10;
                } else if (obj.type === 'interceptor') {
                    const start = obj.object.position.clone();
                    const p1 = stageCenter.clone().add(new THREE.Vector3(-320, 160, 220));
                    const p2 = stageCenter.clone().add(new THREE.Vector3(-180, 120, 40));
                    const p3 = stageCenter.clone().add(new THREE.Vector3(-100, 80, -120));
                    obj.path = [start, p1, p2, p3];
                    obj.pathStart = 4;
                    obj.pathDuration = 90;
                    obj.destroyAt = 100 + Math.random() * 15;
                } else if (obj.type === 'falcon') {
                    const start = obj.object.position.clone();
                    const p1 = stageCenter.clone().add(new THREE.Vector3(420, 200, 320));
                    const p2 = stageCenter.clone().add(new THREE.Vector3(200, 140, 80));
                    const p3 = stageCenter.clone().add(new THREE.Vector3(-120, 120, -80));
                    obj.path = [start, p1, p2, p3];
                    obj.pathStart = 6;
                    obj.pathDuration = 170;
                    obj.destroyAt = 250 + Math.random() * 6;
                } else if (obj.type === 'tiefighter') {
                    const start = obj.object.position.clone();
                    const p1 = stageCenter.clone().add(new THREE.Vector3((Math.random() - 0.5) * 700, (Math.random() - 0.5) * 300, 260));
                    const p2 = stageCenter.clone().add(new THREE.Vector3((Math.random() - 0.5) * 600, (Math.random() - 0.5) * 260, 60));
                    const p3 = stageCenter.clone().add(new THREE.Vector3((Math.random() - 0.5) * 500, (Math.random() - 0.5) * 220, -140));
                    obj.path = [start, p1, p2, p3];
                    obj.pathStart = 10 + Math.random() * 8;
                    obj.pathDuration = 90 + Math.random() * 30;
                    obj.destroyAt = 60 + Math.random() * 80;
                } else if (obj.type === 'phantom') {
                    const start = obj.object.position.clone();
                    const p1 = stageCenter.clone().add(new THREE.Vector3(-360, 140, 240));
                    const p2 = stageCenter.clone().add(new THREE.Vector3(-200, 120, 40));
                    obj.path = [start, p1, p2];
                    obj.pathStart = 8;
                    obj.pathDuration = 110;
                    obj.destroyAt = 120 + Math.random() * 20;
                } else if (obj.type === 'tieinterceptor') {
                    const start = obj.object.position.clone();
                    const p1 = stageCenter.clone().add(new THREE.Vector3((Math.random() - 0.5) * 750, (Math.random() - 0.5) * 320, 280));
                    const p2 = stageCenter.clone().add(new THREE.Vector3((Math.random() - 0.5) * 650, (Math.random() - 0.5) * 280, 80));
                    const p3 = stageCenter.clone().add(new THREE.Vector3((Math.random() - 0.5) * 550, (Math.random() - 0.5) * 240, -120));
                    obj.path = [start, p1, p2, p3];
                    obj.pathStart = 8 + Math.random() * 6;
                    obj.pathDuration = 100 + Math.random() * 20;
                    obj.destroyAt = 80 + Math.random() * 40;
                } else if (obj.type === 'razorcrest') {
                    const start = obj.object.position.clone();
                    const p1 = stageCenter.clone().add(new THREE.Vector3(-240, 100, 180));
                    const p2 = stageCenter.clone().add(new THREE.Vector3(-140, 80, 0));
                    const p3 = stageCenter.clone().add(new THREE.Vector3(-80, 60, -140));
                    obj.path = [start, p1, p2, p3];
                    obj.pathStart = 5;
                    obj.pathDuration = 150;
                    obj.destroyAt = 190 + Math.random() * 8;
                } else if (obj.type === 'imperialshuttle') {
                    const start = obj.object.position.clone();
                    const p1 = stageCenter.clone().add(new THREE.Vector3(-420, 160, 320));
                    const p2 = stageCenter.clone().add(new THREE.Vector3(-320, 140, 180));
                    obj.path = [start, p1, p2];
                    obj.pathStart = 3;
                    obj.pathDuration = 110;
                    obj.destroyAt = 100 + Math.random() * 6;
                }
            });
        }

        function updateBattleLogic() {
            if (!nurWarsActive || moviePaused || !battleReady) return;
            
            battleTimer++;
            
            // Scripted 5-minute battle timeline (300 seconds = 18000 frames at 60fps)
            const t = battleTimer / 60;

            // Story event scheduler (runs once)
            if (!battleStoryEvents) {
                battleStoryEvents = [
                    { time: 15, action: () => focusShip('xwing', 6, true) },
                    { time: 28, action: () => focusShip('xwing', 8) },
                    { time: 38, action: () => destroyShipsByType('tiefighter', 1) },
                    { time: 48, action: () => focusShip('falcon', 6) },
                    { time: 52, action: () => destroyShipsByType('tiefighter', 1) },
                    { time: 62, action: () => destroyShipsByType('tiefighter', 1) },
                    { time: 68, action: () => destroyShipsByType('tieinterceptor', 1) },
                    { time: 78, action: () => focusShip('interceptor', 6) },
                    { time: 88, action: () => focusShip('imperialshuttle', 8) },
                    { time: 95, action: () => destroyShipsByType('tiefighter', 1) },
                    { time: 98, action: () => destroyShipsByType('imperialshuttle', 1) },
                    { time: 112, action: () => focusShip('interceptor', 6) },
                    { time: 122, action: () => destroyShipsByType('interceptor', 1) },
                    { time: 132, action: () => destroyShipsByType('tiefighter', 2) },
                    { time: 140, action: () => destroyShipsByType('tiefighter', 1) },
                    { time: 148, action: () => focusShip('razorcrest', 6) },
                    { time: 152, action: () => destroyShipsByType('tieinterceptor', 1) },
                    { time: 158, action: () => focusShip('xwing', 6, true) },
                    { time: 160, action: () => destroyShipsByType('tiefighter', 1) },
                    { time: 168, action: () => focusShip('razorcrest', 8) },
                    { time: 178, action: () => destroyShipsByType('tiefighter', 2) },
                    { time: 188, action: () => destroyShipsByType('razorcrest', 1) },
                    { time: 202, action: () => destroyShipsByType('xwing', 1, true) },
                    { time: 215, action: () => focusShip('xwing', 14, true) },
                    { time: 225, action: () => destroyShipsByType('tiefighter', 1) },
                    { time: 235, action: () => focusShip('xwing', 8, true) },
                    { time: 240, action: () => destroyShipsByType('tiefighter', 1) },
                    { time: 245, action: () => focusShip('xwing', 12, true) },
                    { time: 255, action: () => destroyShipsByType('falcon', 1) },
                    { time: 263, action: () => focusShip('xwing', 16, true) },
                    { time: 265, action: () => destroyShipsByType('tieinterceptor', 1) },
                    { time: 268, action: () => destroyShipsByType('tiefighter', 2) },
                    { time: 272, action: () => destroyShipsByType('tiefighter', 1) },
                    { time: 278, action: () => focusDeathStar(16) }
                ];
            }

            while (battleStoryIndex < battleStoryEvents.length && t >= battleStoryEvents[battleStoryIndex].time) {
                battleStoryEvents[battleStoryIndex].action();
                battleStoryIndex++;
            }

            function focusShip(type, durationSeconds, preferPlayer) {
                let target = null;
                if (preferPlayer && type === 'xwing') {
                    target = nurWarsObjects.find(obj => obj.type === 'xwing' && obj.isPlayer);
                }
                if (!target) target = nurWarsObjects.find(obj => obj.type === type);
                if (target) {
                    battleCameraFocusOverride = target.object.position.clone();
                    battleCameraFocusUntil = t + durationSeconds;
                }
            }

            function focusDeathStar(durationSeconds) {
                const deathStar = nurWarsObjects.find(obj => obj.type === 'deathstar');
                if (deathStar) {
                    battleCameraFocusOverride = deathStar.object.position.clone();
                    battleCameraFocusUntil = t + durationSeconds;
                }
            }

            function destroyShipsByType(type, count, avoidPlayer) {
                let destroyed = 0;
                nurWarsObjects.slice().forEach(obj => {
                    if (destroyed >= count) return;
                    if (obj.type !== type || obj.health <= 0) return;
                    if (avoidPlayer && obj.type === 'xwing' && obj.isPlayer) return;
                    obj.health = 0;
                    createExplosion(obj.object.position.clone(), 140 + Math.random() * 90);
                    nurWarsScene.remove(obj.object);
                    const idx = nurWarsObjects.indexOf(obj);
                    if (idx >= 0) nurWarsObjects.splice(idx, 1);
                    destroyed++;
                });
            }
            // ACT 1: Approach (0-30s)
            if (t < 30) {
                battlePhase = 'approach';
            } 
            // ACT 2: Initial Engagement (30-80s) - "First Blood"
            else if (t < 80) {
                battlePhase = 'engage';
            } 
            // ACT 3: Main Battle (80-160s) - "The Dance of Death"
            else if (t < 160) {
                battlePhase = 'mainbattle';
            } 
            // ACT 4: Trench Run (160-220s) - "The Final Approach"
            else if (t < 220) {
                battlePhase = 'trench';
            } 
            // ACT 5: The Strike (220-280s) - "The Shot Heard Across the Galaxy"
            else if (t < 280) {
                battlePhase = 'attack';
            } 
            // ACT 6: Victory (280-300s) - "The Day We Won"
            else if (t < 300) {
                battlePhase = 'explosion';
            } 
            else {
                battlePhase = 'victory';
            }

            const deathStar = nurWarsObjects.find(obj => obj.type === 'deathstar');
            const playerXWing = nurWarsObjects.find(obj => obj.type === 'xwing' && obj.isPlayer);
            const falcon = nurWarsObjects.find(obj => obj.type === 'falcon');
            const ties = nurWarsObjects.filter(obj => obj.type === 'tiefighter' && obj.health > 0);
            const xwings = nurWarsObjects.filter(obj => (obj.type === 'xwing' || obj.type === 'interceptor') && obj.health > 0);

            if (battlePhase !== lastBattlePhase) {
                lastBattlePhase = battlePhase;
            }

            // Dynamic camera behavior per phase (follows ships with motion)
            const camOrbit = t * 0.6;
            const camWobble = Math.sin(t * 1.2) * 25;
            const forcedFocus = (battleCameraFocusOverride && t < battleCameraFocusUntil) ? battleCameraFocusOverride : null;
            if (battlePhase === 'approach') {
                if (xwings.length === 0) return;
                const avgPos = new THREE.Vector3();
                xwings.forEach(xw => avgPos.add(xw.object.position));
                avgPos.divideScalar(xwings.length);
                const focusPos = forcedFocus || avgPos;
                const offset = new THREE.Vector3(
                    Math.cos(camOrbit) * 220,
                    200 + camWobble,
                    700 + Math.sin(camOrbit) * 140
                );
                battleCameraDesiredPos.copy(focusPos).add(offset);
                battleCameraDesiredLook.copy(focusPos);
            } else if (battlePhase === 'engage') {
                const focus = forcedFocus || (falcon ? falcon.object.position : (xwings[0] ? xwings[0].object.position : deathStar ? deathStar.object.position : new THREE.Vector3()));
                const phaseProgress = Math.min((t - 30) / 50, 1);
                const offset = new THREE.Vector3(
                    Math.cos(camOrbit) * (220 + phaseProgress * 40),
                    140 + camWobble,
                    600 + Math.sin(camOrbit) * 180 + phaseProgress * 50
                );
                battleCameraDesiredPos.copy(focus).add(offset);
                battleCameraDesiredLook.copy(focus);
            } else if (battlePhase === 'mainbattle') {
                let focus = forcedFocus || (falcon ? falcon.object.position : (xwings[0] ? xwings[0].object.position : deathStar ? deathStar.object.position : new THREE.Vector3()));
                if (t > 100 && t < 130) {
                    const shuttle = nurWarsObjects.find(obj => obj.type === 'imperialshuttle');
                    if (shuttle) focus = shuttle.object.position;
                } else if (t >= 130 && t < 160) {
                    const interceptor = nurWarsObjects.find(obj => obj.type === 'interceptor');
                    if (interceptor) focus = interceptor.object.position;
                }
                const offset = new THREE.Vector3(
                    Math.cos(camOrbit) * 420,
                    220 + camWobble,
                    800 + Math.sin(camOrbit) * 220
                );
                battleCameraDesiredPos.copy(focus).add(offset);
                battleCameraDesiredLook.copy(focus);
            } else if (battlePhase === 'trench') {
                if (playerXWing && deathStar) {
                    const focus = forcedFocus || playerXWing.object.position;
                    const phaseProgress = (t - 160) / 60;
                    const offset = new THREE.Vector3(
                        Math.cos(camOrbit) * (120 - phaseProgress * 40),
                        80 + camWobble,
                        420 + Math.sin(camOrbit) * 60 - phaseProgress * 80
                    );
                    battleCameraDesiredPos.copy(focus).add(offset);
                    battleCameraDesiredLook.copy(deathStar.exhaustPort ? deathStar.exhaustPort.position : deathStar.object.position);
                }
            } else if (battlePhase === 'attack') {
                if (playerXWing && deathStar) {
                    const focus = forcedFocus || playerXWing.object.position;
                    const phaseProgress = Math.min((t - 220) / 60, 1);
                    const offset = new THREE.Vector3(
                        Math.cos(camOrbit) * (140 - phaseProgress * 50),
                        100 + camWobble - phaseProgress * 30,
                        380 + Math.sin(camOrbit) * 80 - phaseProgress * 120
                    );
                    battleCameraDesiredPos.copy(focus).add(offset);
                    battleCameraDesiredLook.copy(deathStar.exhaustPort ? deathStar.exhaustPort.position : deathStar.object.position);
                }
            } else if (battlePhase === 'explosion') {
                if (deathStar) {
                    const focus = forcedFocus || deathStar.object.position;
                    const pullback = Math.min(Math.max((t - 278) / 18, 0), 1);
                    const offset = new THREE.Vector3(
                        Math.cos(camOrbit) * (700 + pullback * 900),
                        420 + camWobble + pullback * 400,
                        900 + Math.sin(camOrbit) * 220 + pullback * 1000
                    );
                    battleCameraDesiredPos.copy(focus).add(offset);
                    battleCameraDesiredLook.copy(focus);
                    if (pullback > 0.2) {
                        nurWarsCamera.fov = Math.max(50, 60 - pullback * 15);
                        nurWarsCamera.updateProjectionMatrix();
                    }
                }
            }

            if (!battleCameraInitialized) {
                battleCameraInitialized = true;
                battleCameraLookCurrent.copy(battleCameraDesiredLook);
            }
            if (battleCameraDesiredPos.length() > 0) {
                // Add camera shake during explosion phase
                let shakeIntensity = 0;
                if (battlePhase === 'explosion') {
                    shakeIntensity = Math.max(0, 2.0 - (t - 280) / 10) * Math.sin(battleTimer * 0.15);
                    battleCameraDesiredPos.x += shakeIntensity * 8;
                    battleCameraDesiredPos.y += Math.sin(battleTimer * 0.12) * shakeIntensity * 6;
                }
                nurWarsCamera.position.lerp(battleCameraDesiredPos, 0.045);
            }
            battleCameraLookCurrent.lerp(battleCameraDesiredLook, 0.06);
            nurWarsCamera.lookAt(battleCameraLookCurrent);

            // Apply scripted flight paths
            nurWarsObjects.forEach(obj => {
                if (!obj.path || obj.health <= 0) return;
                const start = obj.pathStart || 0;
                const duration = obj.pathDuration || 20;
                const localT = (t - start) / duration;
                if (localT < 0 || localT > 1) return;
                const nextPos = getPathPoint(obj.path, localT);
                if (!nextPos) return;
                const prevPos = obj.object.position.clone();
                obj.object.position.copy(nextPos);
                obj.object.lookAt(nextPos.clone().add(nextPos.clone().sub(prevPos)));
            });
            
            // Update X-Wings with scripted behavior
            nurWarsObjects.filter(obj => obj.type === 'xwing').forEach(xwing => {
                if (xwing.health <= 0) return;
                
                if (battlePhase === 'approach') {
                    xwing.object.position.add(xwing.velocity);
                } else if (battlePhase === 'engage' || battlePhase === 'mainbattle' || battlePhase === 'trench' || battlePhase === 'attack') {
                    if (xwing.isPlayer) {
                        // Nur's X-Wing targets the exhaust port with more dramatic approach
                        const deathStar = nurWarsObjects.find(obj => obj.type === 'deathstar');
                        if (deathStar && deathStar.exhaustPort) {
                            const target = deathStar.exhaustPort.position;
                            const direction = target.clone().sub(xwing.object.position).normalize();
                            const speed = battlePhase === 'attack' ? 3.2 : (battlePhase === 'trench' ? 2.6 : 2.0);
                            xwing.object.position.add(direction.multiplyScalar(speed));
                            
                            // Look at target
                            xwing.object.lookAt(target);
                            
                            // Add targeting reticule effect as X-Wing closes in during attack phase
                            const distToTarget = xwing.object.position.distanceTo(target);
                            if (battlePhase === 'attack' && distToTarget < 600) {
                                // Create targeting marker every 8 frames
                                if (battleTimer % 8 === 0) {
                                    const markerGeometry = new THREE.SphereGeometry(5, 8, 8);
                                    const markerMaterial = new THREE.MeshBasicMaterial({ 
                                        color: 0x00ff00,
                                        wireframe: true
                                    });
                                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                                    marker.position.copy(target);
                                    nurWarsScene.add(marker);
                                    setTimeout(() => nurWarsScene.remove(marker), 200);
                                }
                            }
                            
                            // Fire during attack run - increase fire rate as approaching
                            const fireRateModifier = battlePhase === 'attack' ? Math.max(12, 24 - distToTarget / 50) : 20;
                            if (battlePhase === 'attack' && t > 260 && !playerShotFired && battleTimer % Math.ceil(fireRateModifier) === 0) {
                                createLaser(xwing.object.position.clone(), direction.clone(), 0x00ff00, true);
                                playerShotFired = true;
                                // Play special final shot sound with higher priority
                                playNurWarsSound('laser');
                            }
                        }
                    } else {
                        // Other X-Wings engage TIE fighters more aggressively
                        xwing.object.position.add(xwing.velocity);
                        
                        // Fire at TIE fighters more frequently
                        if ((battlePhase === 'engage' || battlePhase === 'mainbattle') && battleTimer % 16 === Math.floor(Math.random() * 16)) {
                            const ties = nurWarsObjects.filter(obj => obj.type === 'tiefighter' && obj.health > 0);
                            if (ties.length > 0) {
                                const target = ties[Math.floor(Math.random() * ties.length)];
                                const direction = target.object.position.clone().sub(xwing.object.position).normalize();
                                createLaser(xwing.object.position.clone(), direction, 0x00ff00, true);
                            }
                        }
                    }
                }
            });

            // Update Millennium Falcon (blue lasers)
            nurWarsObjects.filter(obj => obj.type === 'falcon').forEach(falconShip => {
                if (falconShip.health <= 0) return;
                const fireRate = battlePhase === 'attack' ? 14 : (battlePhase === 'trench' ? 15 : 16);
                if ((battlePhase === 'engage' || battlePhase === 'mainbattle' || battlePhase === 'trench' || battlePhase === 'attack') && battleTimer % fireRate === 0) {
                    const ties = nurWarsObjects.filter(obj => (obj.type === 'tiefighter' || obj.type === 'tieinterceptor') && obj.health > 0);
                    if (ties.length > 0) {
                        const target = ties[Math.floor(Math.random() * ties.length)];
                        const direction = target.object.position.clone().sub(falconShip.object.position).normalize();
                        createLaser(falconShip.object.position.clone(), direction, 0x00aaff, true);
                    }
                }
            });

            // Update Rebel Interceptor (blue lasers)
            nurWarsObjects.filter(obj => obj.type === 'interceptor').forEach(rebelInterceptor => {
                if (rebelInterceptor.health <= 0) return;
                const fireRate = battlePhase === 'attack' ? 14 : (battlePhase === 'trench' ? 16 : 18);
                if ((battlePhase === 'engage' || battlePhase === 'mainbattle' || battlePhase === 'trench' || battlePhase === 'attack') && battleTimer % fireRate === 0) {
                    const ties = nurWarsObjects.filter(obj => (obj.type === 'tiefighter' || obj.type === 'tieinterceptor') && obj.health > 0);
                    if (ties.length > 0) {
                        const target = ties[Math.floor(Math.random() * ties.length)];
                        const direction = target.object.position.clone().sub(rebelInterceptor.object.position).normalize();
                        createLaser(rebelInterceptor.object.position.clone(), direction, 0x00ccff, true);
                    }
                }
            });

            // Update Razor Crest (green/blue lasers)
            nurWarsObjects.filter(obj => obj.type === 'razorcrest').forEach(razor => {
                if (razor.health <= 0) return;
                const fireRate = battlePhase === 'attack' ? 16 : (battlePhase === 'trench' ? 18 : 20);
                if ((battlePhase === 'engage' || battlePhase === 'mainbattle' || battlePhase === 'trench' || battlePhase === 'attack') && battleTimer % fireRate === 0) {
                    const ties = nurWarsObjects.filter(obj => (obj.type === 'tiefighter' || obj.type === 'tieinterceptor') && obj.health > 0);
                    if (ties.length > 0) {
                        const target = ties[Math.floor(Math.random() * ties.length)];
                        const direction = target.object.position.clone().sub(razor.object.position).normalize();
                        createLaser(razor.object.position.clone(), direction, 0x00ff88, true);
                    }
                }
            });
            
            // Update TIE Fighters with more aggressive behavior
            nurWarsObjects.filter(obj => obj.type === 'tiefighter').forEach(tie => {
                if (tie.health <= 0) return;
                tie.object.rotation.y += 0.15; // Faster rotation for more dynamic look
                
                // Fire at X-Wings during engage/trench phases
                if ((battlePhase === 'engage' || battlePhase === 'mainbattle' || battlePhase === 'trench') && battleTimer % 24 === Math.floor(Math.random() * 24)) {
                    const xwings = nurWarsObjects.filter(obj => obj.type === 'xwing' && obj.health > 0);
                    if (xwings.length > 0) {
                        const target = xwings[Math.floor(Math.random() * xwings.length)];
                        const direction = target.object.position.clone().sub(tie.object.position).normalize();
                        createLaser(tie.object.position.clone(), direction, 0xff0000, false);
                    }
                }
            });

            // Timed ship destructions to tell the story
            nurWarsObjects.slice().forEach(obj => {
                if (!obj.destroyAt || obj.health <= 0) return;
                if (t >= obj.destroyAt) {
                    obj.health = 0;
                    createExplosion(obj.object.position.clone(), 120 + Math.random() * 80);
                    nurWarsScene.remove(obj.object);
                    const idx = nurWarsObjects.indexOf(obj);
                    if (idx >= 0) nurWarsObjects.splice(idx, 1);
                }
            });

            // Ensure only the player's X-Wing remains before the final strike
            if (t >= 245) {
                nurWarsObjects.slice().forEach(obj => {
                    if (obj.health <= 0) return;
                    const isRebel = obj.type === 'xwing' || obj.type === 'falcon' || obj.type === 'interceptor' || obj.type === 'razorcrest';
                    if (isRebel && !(obj.type === 'xwing' && obj.isPlayer)) {
                        obj.health = 0;
                        createExplosion(obj.object.position.clone(), 140 + Math.random() * 80);
                        nurWarsScene.remove(obj.object);
                        const idx = nurWarsObjects.indexOf(obj);
                        if (idx >= 0) nurWarsObjects.splice(idx, 1);
                    }
                });
            }

            // After the final strike, clean up remaining imperials for a clear victory shot
            if (t >= 285) {
                nurWarsObjects.slice().forEach(obj => {
                    if (obj.health <= 0) return;
                    const isImperial = obj.type === 'tiefighter' || obj.type === 'tieinterceptor' || obj.type === 'imperialshuttle';
                    if (isImperial) {
                        obj.health = 0;
                        createExplosion(obj.object.position.clone(), 160 + Math.random() * 80);
                        nurWarsScene.remove(obj.object);
                        const idx = nurWarsObjects.indexOf(obj);
                        if (idx >= 0) nurWarsObjects.splice(idx, 1);
                    }
                });
            }

            // Trigger Death Star destruction at scripted time if not already started
            if (deathStar && !finalExplosionStarted && t >= 275) {
                startDeathStarDestruction(deathStar);
            }
            
            // Update lasers
            updateLasers();
            
            // Update explosions
            updateExplosions();
            
            // Check for victory condition
            if (!deathStar && battlePhase !== 'victory') {
                battlePhase = 'victory';
                showVictoryMessage();
            }
            
            // Auto-close after victory sequence
            if (battlePhase === 'victory' && battleTimer > 18500) {
                closeNurWars();
                return;
            }
        }

        function createLaser(position, direction, color, isPlayerShot) {
            const laserGeometry = new THREE.CylinderGeometry(0.5, 0.5, 20);
            const laserMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                emissive: color,
                transparent: true,
                opacity: 0.9,
                emissiveIntensity: 1.2
            });
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            laser.position.copy(position);
            laser.lookAt(position.clone().add(direction));
            laser.rotateX(Math.PI / 2);
            
            nurWarsScene.add(laser);
            lasers.push({
                object: laser,
                velocity: direction.multiplyScalar(15),
                life: 100,
                isPlayerShot: isPlayerShot
            });
            
            // Play laser sound
            const now = performance.now();
            if (now - lastLaserSoundAt > 60) {
                playNurWarsSound('laser');
                lastLaserSoundAt = now;
            }
        }

        function updateLasers() {
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                laser.object.position.add(laser.velocity);
                laser.life--;
                
                // Check collisions
                if (laser.isPlayerShot) {
                    const deathStar = nurWarsObjects.find(obj => obj.type === 'deathstar');
                    if (deathStar && deathStar.exhaustPort) {
                        const distance = laser.object.position.distanceTo(deathStar.exhaustPort.position);
                        if (distance < 20) {
                            // Death Star hit! - Cinematic destruction sequence
                            startDeathStarDestruction(deathStar);
                            
                            // Remove laser
                            nurWarsScene.remove(laser.object);
                            lasers.splice(i, 1);
                            continue;
                        }
                    }
                }
                
                // Remove old lasers
                if (laser.life <= 0) {
                    nurWarsScene.remove(laser.object);
                    lasers.splice(i, 1);
                }
            }
        }

        function startDeathStarDestruction(deathStar) {
            if (finalExplosionStarted) return;
            finalExplosionStarted = true;
            
            // Zoom camera closer to Death Star for ultra-dramatic effect (stay outside)
            const deathStarPos = deathStar.object.position.clone();
            const deathStarRadius = deathStar.object.userData.radius || 180;
            
            // Create multiple explosion stages with much closer camera work
            setTimeout(() => {
                // First explosion at exhaust port - zoom in immediately
                createExplosion(deathStar.exhaustPort.position.clone(), 120);
                
                // Zoom camera much closer for intense destruction view
                const ultraClosePos = deathStarPos.clone();
                ultraClosePos.z += deathStarRadius + 260; // Stay outside the surface
                ultraClosePos.y += 120;
                ultraClosePos.x += 80; // Slight angle for better view
                
                const zoomDuration = 1500; // Faster zoom
                const startTime = Date.now();
                const startCameraPos = nurWarsCamera.position.clone();
                
                function zoomToDeathStar() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / zoomDuration, 1);
                    
                    nurWarsCamera.position.lerpVectors(startCameraPos, ultraClosePos, progress);
                    
                    // Look directly at the destruction point
                    const lookTarget = deathStar.exhaustPort.position.clone();
                    nurWarsCamera.lookAt(lookTarget);
                    
                    if (progress < 1) {
                        requestAnimationFrame(zoomToDeathStar);
                    }
                }
                zoomToDeathStar();
                
            }, 300);
            
            setTimeout(() => {
                // Secondary explosions - more dramatic and visible
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const explosionPos = deathStarPos.clone();
                        explosionPos.x += (Math.random() - 0.5) * 400;
                        explosionPos.y += (Math.random() - 0.5) * 400;
                        explosionPos.z += (Math.random() - 0.5) * 400;
                        createExplosion(explosionPos, 200 + Math.random() * 150);
                        
                        // Create additional smaller explosions for detail
                        for (let j = 0; j < 3; j++) {
                            setTimeout(() => {
                                const smallExplosionPos = explosionPos.clone();
                                smallExplosionPos.x += (Math.random() - 0.5) * 100;
                                smallExplosionPos.y += (Math.random() - 0.5) * 100;
                                smallExplosionPos.z += (Math.random() - 0.5) * 100;
                                createExplosion(smallExplosionPos, 80 + Math.random() * 60);
                            }, j * 150);
                        }
                    }, i * 200);
                }
            }, 1000);
            
            setTimeout(() => {
                // Final massive explosion - ultra close and dramatic
                createExplosion(deathStarPos, 1200); // Much larger explosion
                
                // Add shockwave ring
                const ringGeo = new THREE.RingGeometry(10, 20, 64);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffaa00, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const shockwave = new THREE.Mesh(ringGeo, ringMat);
                shockwave.position.copy(deathStarPos);
                shockwave.lookAt(nurWarsCamera.position);
                nurWarsScene.add(shockwave);
                
                // Animate shockwave in updateExplosions or separate logic
                explosions.push({
                    object: shockwave,
                    type: 'shockwave',
                    maxSize: 80, // Scale factor
                    currentSize: 1,
                    life: 100,
                    maxLife: 100
                });
                
                // Create ring of explosions around Death Star
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const ringPos = deathStarPos.clone();
                    ringPos.x += Math.cos(angle) * 300;
                    ringPos.y += Math.sin(angle) * 300;
                    createExplosion(ringPos, 300 + Math.random() * 200);
                }
                
                // Remove Death Star objects
                nurWarsScene.remove(deathStar.object);
                nurWarsScene.remove(deathStar.exhaustPort);
                nurWarsObjects.splice(nurWarsObjects.indexOf(deathStar), 1);
                
                // Intense camera shake effect
                const originalPos = nurWarsCamera.position.clone();
                let shakeTimer = 0;
                const shakeIntensity = 40; // Much more intense shake
                
                function cameraShake() {
                    if (shakeTimer < 90) { // Longer shake
                        nurWarsCamera.position.x = originalPos.x + (Math.random() - 0.5) * shakeIntensity;
                        nurWarsCamera.position.y = originalPos.y + (Math.random() - 0.5) * shakeIntensity;
                        nurWarsCamera.position.z = originalPos.z + (Math.random() - 0.5) * shakeIntensity;
                        shakeTimer++;
                        requestAnimationFrame(cameraShake);
                    } else {
                        // Pull back camera for victory view
                        const victoryPos = originalPos.clone();
                        victoryPos.z += 500;
                        victoryPos.y += 200;
                        
                        const pullBackDuration = 3000;
                        const pullBackStart = Date.now();
                        
                        function pullBackCamera() {
                            const elapsed = Date.now() - pullBackStart;
                            const progress = Math.min(elapsed / pullBackDuration, 1);
                            
                            nurWarsCamera.position.lerpVectors(originalPos, victoryPos, progress);
                            nurWarsCamera.lookAt(deathStarPos); // Look at explosion site
                            
                            if (progress < 1) {
                                requestAnimationFrame(pullBackCamera);
                            }
                        }
                        pullBackCamera();
                    }
                }
                cameraShake();
                
            }, 2500);
        }

        function createExplosion(position, maxSize) {
            // Core fireball
            const explosionGeometry = new THREE.SphereGeometry(1, 20, 20);
            const explosionMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00,
                transparent: true,
                opacity: 1
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(position);
            nurWarsScene.add(explosion);
            explosions.push({
                object: explosion,
                maxSize: maxSize,
                currentSize: 1,
                life: 120,
                maxLife: 120,
                type: 'core'
            });
            
            // Inner bright flash
            const flashGeo = new THREE.SphereGeometry(1, 16, 16);
            const flashMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 1
            });
            const flash = new THREE.Mesh(flashGeo, flashMat);
            flash.position.copy(position);
            nurWarsScene.add(flash);
            explosions.push({
                object: flash,
                maxSize: maxSize * 0.6,
                currentSize: 1,
                life: 40,
                maxLife: 40,
                type: 'flash'
            });
            
            // Outer smoke layer
            const smokeGeo = new THREE.SphereGeometry(1, 12, 12);
            const smokeMat = new THREE.MeshBasicMaterial({ 
                color: 0x442200,
                transparent: true,
                opacity: 0.7
            });
            const smoke = new THREE.Mesh(smokeGeo, smokeMat);
            smoke.position.copy(position);
            nurWarsScene.add(smoke);
            explosions.push({
                object: smoke,
                maxSize: maxSize * 1.3,
                currentSize: 1,
                life: 140,
                maxLife: 140,
                type: 'smoke'
            });
            
            // Debris particles
            for (let i = 0; i < 8; i++) {
                const debrisGeo = new THREE.BoxGeometry(2, 2, 2);
                const debrisMat = new THREE.MeshBasicMaterial({ color: 0x888888 });
                const debris = new THREE.Mesh(debrisGeo, debrisMat);
                debris.position.copy(position);
                nurWarsScene.add(debris);
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 12,
                    (Math.random() - 0.5) * 12,
                    (Math.random() - 0.5) * 12
                );
                explosions.push({
                    object: debris,
                    maxSize: 2,
                    currentSize: 2,
                    life: 80,
                    maxLife: 80,
                    type: 'debris',
                    velocity: vel
                });
            }
            
            // Play explosion sound
            playNurWarsSound('explosion');
        }

        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.life--;
                
                if (explosion.type === 'shockwave') {
                    explosion.currentSize += 1.5;
                    explosion.object.scale.setScalar(explosion.currentSize);
                    explosion.object.material.opacity = explosion.life / explosion.maxLife;
                } else if (explosion.type === 'debris') {
                    explosion.object.position.add(explosion.velocity);
                    explosion.velocity.multiplyScalar(0.98);
                    explosion.object.material.opacity = explosion.life / explosion.maxLife;
                } else if (explosion.type === 'flash') {
                    explosion.currentSize += explosion.maxSize / 10;
                    explosion.object.scale.setScalar(explosion.currentSize);
                    explosion.object.material.opacity = explosion.life / explosion.maxLife;
                } else if (explosion.type === 'smoke') {
                    if (explosion.currentSize < explosion.maxSize) {
                        explosion.currentSize += explosion.maxSize / 30;
                    }
                    explosion.object.scale.setScalar(explosion.currentSize);
                    explosion.object.material.opacity = (explosion.life / explosion.maxLife) * 0.5;
                } else {
                // Grow explosion core
                if (explosion.currentSize < explosion.maxSize) {
                    explosion.currentSize += explosion.maxSize / 60;
                    explosion.object.scale.setScalar(explosion.currentSize);
                }
                
                // Fade out
                const alpha = explosion.life / explosion.maxLife;
                explosion.object.material.opacity = alpha;
                
                // Change color over time
                const hue = (1 - alpha) * 0.1; // From red to yellow
                explosion.object.material.color.setHSL(hue, 1, 0.5);
                }
                
                // Remove old explosions
                if (explosion.life <= 0) {
                    nurWarsScene.remove(explosion.object);
                    explosions.splice(i, 1);
                }
            }
        }

        function showVictoryMessage() {
            // Play victory fanfare with conclusion theme
            playNurWarsSound('victory');
            
            // Create enhanced 3D text for victory message
            setTimeout(() => {
                const battleHud = document.getElementById('battle-hud');
                battleHud.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 30px; text-shadow: 0 0 40px #FFD700; animation: pulse 2s infinite; color: #FFD700; font-weight: 900;">THE LEGACY SYSTEM IS DESTROYED!</div>
                    <div style="font-size: 32px; margin-bottom: 25px; color: #87CEEB; text-shadow: 0 0 20px #87CEEB;">NUR DAWOODANI HAS SAVED THE GALAXY!</div>
                    <div style="font-size: 24px; opacity: 0.9; margin-bottom: 25px; color: #FFFFFF;">The Force of Business Analysis is strong with this one...</div>
                    <div style="font-size: 20px; opacity: 0.8; margin-bottom: 25px; color: #98FB98;">The Death Star of Technical Debt has been eliminated!</div>
                    <div style="font-size: 18px; opacity: 0.7; margin-bottom: 35px; color: #DDA0DD;">The Rebel Alliance celebrates another victory against the Empire of Legacy Systems!</div>
                    <div style="font-size: 16px; opacity: 0.6; margin-bottom: 40px; color: #F0E68C; font-style: italic;">"That's one small step for Business Analysis, one giant leap for Digital Transformation!"</div>
                    <button onclick="closeNurWars()" style="margin-top: 25px; background: rgba(255,215,0,0.3); border: 3px solid #FFD700; color: #FFD700; padding: 20px 40px; border-radius: 12px; font-family: 'Orbitron', serif; font-size: 22px; font-weight: bold; cursor: pointer; backdrop-filter: blur(15px); box-shadow: 0 0 25px rgba(255,215,0,0.6); transition: all 0.3s; text-transform: uppercase; letter-spacing: 2px;">
                        RETURN TO MISSION CONTROL
                    </button>
                `;
                
                // Add enhanced hover effect to button
                const button = battleHud.querySelector('button');
                button.addEventListener('mouseenter', () => {
                    button.style.transform = 'scale(1.15)';
                    button.style.boxShadow = '0 0 40px rgba(255,215,0,0.9)';
                    button.style.background = 'rgba(255,215,0,0.5)';
                });
                button.addEventListener('mouseleave', () => {
                    button.style.transform = 'scale(1)';
                    button.style.boxShadow = '0 0 25px rgba(255,215,0,0.6)';
                    button.style.background = 'rgba(255,215,0,0.3)';
                });
            }, 1500);
        }
        
        // Make functions global
        window.startNurWars = startNurWars;
        window.closeNurWars = closeNurWars;

        function closeSkyModal() {
            const skyDetails = document.getElementById('sky-details');
            skyDetails.style.display = 'none';
            
            if (isCenterView) {
                // Force reset when closing the sun modal
                isCenterView = false;
                focusedObject = null;
                controls.enableZoom = true;
                controls.maxDistance = 2000;
                controls.minDistance = 5;
                camera.fov = 60;
                camera.updateProjectionMatrix();
                undimBackground();
                updateMoonOrbitVisibility();
                viewHistory.length = 0;
                currentViewIndex = -1;
                updateBackButton();
                gsap.to(controls.target, { x: 0, y: 0, z: 0, duration: 0.8 });
                gsap.to(camera.position, { x: 0, y: 200, z: 800, duration: 0.8 });
                closeOverlay();
                return;
            } else if (focusedObject) {
                // Return to following the focused object closely
                const targetPos = new THREE.Vector3();
                focusedObject.getWorldPosition(targetPos);
                
                if (focusedObject.userData.isMoon) {
                    // For moons, return to parent planet
                    const parentPlanet = focusedObject.userData.parentPlanet;
                    if (parentPlanet) {
                        focusedObject = parentPlanet; // Switch focus to parent
                        parentPlanet.getWorldPosition(targetPos);
                        
                        // Update moon orbit visibility when returning to parent planet
                        updateMoonOrbitVisibility();
                        
                        // Dim background when returning to parent planet
                        dimBackground(parentPlanet);
                        
                        const dist = (parentPlanet.userData.size || 5) * 3 + 15;
                        const currentDir = camera.position.clone().sub(targetPos).normalize();
                        const newPos = targetPos.clone().add(currentDir.multiplyScalar(dist));
                        
                        gsap.to(camera.position, { x: newPos.x, y: newPos.y, z: newPos.z, duration: 1.0 });
                        controls.target.copy(targetPos);
                    }
                } else {
                    // For planets, return to close following position
                    controls.target.copy(targetPos);
                    
                    if (focusedObject.userData.isPlanet) {
                        // Ensure background is dimmed when returning to planet
                        dimBackground(focusedObject);
                        
                        const dist = (focusedObject.userData.size || 5) * 3 + 15;
                        const currentDir = camera.position.clone().sub(targetPos).normalize();
                        const newPos = targetPos.clone().add(currentDir.multiplyScalar(dist));
                        
                        gsap.to(camera.position, { x: newPos.x, y: newPos.y, z: newPos.z, duration: 1.0 });
                    }
                }
            }
        }

        const skyCloseBtn = document.getElementById('sky-close');
        if (skyCloseBtn) {
            skyCloseBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                closeSkyModal();
            });
        }

        function resetView() {
            // Set flag to stop animation updates
            stopSuctionAnimation = true;
            
            // Kill all stored animation references
            if (activeSuctionAnimations.position) activeSuctionAnimations.position.kill();
            if (activeSuctionAnimations.scale) activeSuctionAnimations.scale.kill();
            if (activeSuctionAnimations.rotation) activeSuctionAnimations.rotation.kill();
            activeSuctionAnimations = {};
            
            // Re-enable controls
            controls.enabled = true;
            
            if (isCenterView) {
                isCenterView = false;
                controls.enableZoom = true;
                controls.maxDistance = 2000;
                controls.minDistance = 5;
                camera.fov = 60;
                camera.updateProjectionMatrix();
            }
            
            if (solarSystem && solarSystem.userData && solarSystem.userData.isSucked) {
                // Restore solar system immediately
                solarSystem.userData.isSucked = false;
                solarSystem.visible = true;
                solarSystem.position.set(0, 0, 0);
                solarSystem.scale.set(1, 1, 1);
                solarSystem.rotation.set(0, 0, 0);
                
                // Restore UI
                const uiLayer = document.getElementById('ui-layer');
                if (uiLayer) uiLayer.style.display = 'flex';
                const blackHoleOverlay = document.getElementById('blackhole-overlay');
                if (blackHoleOverlay) blackHoleOverlay.style.display = 'none';
                document.body.classList.remove('labels-hidden');
            }
            
            // Reset black hole
            if (blackHoleGroup) {
                blackHoleGroup.position.set(900, 260, -250);
                blackHoleGroup.scale.set(1, 1, 1);
                blackHoleGroup.rotation.set(0, 0, 0);
                blackHoleGroup.updateMatrix();
                blackHoleGroup.updateMatrixWorld(true);
            }
            
            focusedObject = null;
            undimBackground();
            updateMoonOrbitVisibility();
            viewHistory.length = 0;
            currentViewIndex = -1;
            updateBackButton();
            document.getElementById('sky-details').style.display = 'none';
            closeOverlay();
            
            // Animate camera back smoothly
            gsap.to(controls.target, { x: 0, y: 0, z: 0, duration: 1.0 });
            gsap.to(camera.position, { 
                x: 0, 
                y: 150, 
                z: 900, 
                duration: 1.0,
                onComplete: () => {
                    controls.enabled = true;
                }
            });
        }

        window.resetView = resetView;
        window.closeOverlay = closeOverlay;
        window.closeSkyModal = closeSkyModal;

        // small html-escape helper
        function escapeHtml(str) {
        	if (!str) return '';
        	return String(str)
        		.replace(/&/g, '&amp;')
        		.replace(/</g, '&lt;')
        		.replace(/>/g, '&gt;')
        		.replace(/"/g, '&quot;')
        		.replace(/'/g, '&#039;');
        }

        window.addEventListener('wheel', (e) => {
            lastWheelTime = Date.now();
            if (isCenterView) {
                // Telescope zoom (FOV)
                let newFov = camera.fov + (e.deltaY * 0.05);
                newFov = Math.max(10, Math.min(60, newFov));
                camera.fov = newFov;
                camera.updateProjectionMatrix();
            }
        });

        // Keyboard navigation
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' || e.key === 'Backspace') {
                e.preventDefault();
                
                // Close modals first if open
                const skyDetails = document.getElementById('sky-details');
                const overlayPanel = document.getElementById('overlay-panel');
                
                if (skyDetails.style.display !== 'none') {
                    closeSkyModal();
                } else if (overlayPanel.classList.contains('active')) {
                    closeOverlay();
                } else {
                    // Try to go back to previous view
                    const wentBack = goToPreviousView();
                    if (!wentBack) {
                        // No previous view, just unselect and undim
                        focusedObject = null;
                        undimBackground();
                    }
                }
            }
        });

        // Prevent scrolling in modals from triggering zoom
        ['sky-content', 'overlay-panel'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('wheel', e => e.stopPropagation());
                el.addEventListener('click', e => e.stopPropagation());
                el.addEventListener('mousedown', e => e.stopPropagation());
            }
        });

        // === ANIMATION LOOP ===
        const clock = new THREE.Clock();

        function spawnComet() {
            // Create comet nucleus (brighter and more realistic)
            const nucleusGeo = new THREE.SphereGeometry(2, 12, 12);
            const nucleusMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffcc,
                transparent: true,
                opacity: 0.9
            });
            const nucleus = new THREE.Mesh(nucleusGeo, nucleusMat);
            
            // Create comet coma (glowing atmosphere around nucleus)
            const comaGeo = new THREE.SphereGeometry(4, 16, 16);
            const comaMat = new THREE.MeshBasicMaterial({ 
                color: 0xaaddff,
                transparent: true,
                opacity: 0.3
            });
            const coma = new THREE.Mesh(comaGeo, comaMat);
            
            // Group nucleus and coma together
            const cometGroup = new THREE.Group();
            cometGroup.add(nucleus);
            cometGroup.add(coma);
            
            // Random starting position (further out for more dramatic effect)
            const x = (Math.random() - 0.5) * 1200;
            const y = (Math.random() - 0.5) * 600;
            const z = (Math.random() - 0.5) * 1200;
            cometGroup.position.set(x, y, z);
            
            // Target closer to center for more visible trajectory
            const targetX = (Math.random() - 0.5) * 300;
            const targetY = (Math.random() - 0.5) * 150;
            const targetZ = (Math.random() - 0.5) * 300;
            const velocity = new THREE.Vector3(targetX - x, targetY - y, targetZ - z).normalize().multiplyScalar(4);
            
            scene.add(cometGroup);
            
            // Create trail system for this comet
            const trailPositions = [];
            const maxTrailLength = 80; // Longer trail
            
            comets.push({ 
                mesh: cometGroup, 
                nucleus: nucleus,
                coma: coma,
                velocity, 
                life: 600, // Longer life
                trailPositions: trailPositions,
                maxTrailLength: maxTrailLength,
                trailMeshes: [] // Store trail segment meshes
            });
            
            playSound('comet');
        }

        function fireLasers(ship) {
            const pos = new THREE.Vector3();
            ship.getWorldPosition(pos);
            const quat = new THREE.Quaternion();
            ship.getWorldQuaternion(quat);
            
            const laserGeo = new THREE.CylinderGeometry(0.2, 0.2, 10, 8);
            laserGeo.rotateX(Math.PI / 2);
            const laserMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            
            const l1 = new THREE.Mesh(laserGeo, laserMat);
            const l2 = new THREE.Mesh(laserGeo, laserMat);
            
            const offset = new THREE.Vector3(2, 0, 0).applyQuaternion(quat);
            l1.position.copy(pos).add(offset);
            l1.quaternion.copy(quat);
            l2.position.copy(pos).sub(offset);
            l2.quaternion.copy(quat);
            
            scene.add(l1);
            scene.add(l2);
            
            const velocity = new THREE.Vector3(0, 0, 10).applyQuaternion(quat);
            lasers.push({ mesh: l1, velocity, life: 100 });
            lasers.push({ mesh: l2, velocity, life: 100 });
            playSound('laser');
        }

        function animate() {
            requestAnimationFrame(animate);

            // Handle Nur Wars Battle Rendering
            if (nurWarsActive && renderMode === 'battle') {
                updateBattleLogic();
                webGLRenderer.render(nurWarsScene, camera);
                return; // Skip normal rendering
            }

            if (nurWarsActive && renderMode === 'video') {
                return; // Video playback handles visuals
            }

            // Continue rendering main scene during NUR WARS opening crawl for starfield
            const time = Date.now() * 0.001;
            
            // Add subtle parallax movement to starfields during NUR WARS for depth perception
            if (nurWarsActive) {
                starMesh.rotation.y += 0.0001;
                starMesh.rotation.x += 0.00005;
                if (window.upperStarMesh) {
                    upperStarMesh.rotation.y -= 0.00015; // Opposite direction for depth
                    upperStarMesh.rotation.x -= 0.00008;
                }
            }
            
            // Clean sun animation - no corona layers
            sun.rotation.y += 0.001; // Rotate sun counterclockwise (same as planets)
            
            // Animate sun glow
            if (sun.userData.glowMaterial) {
                sun.userData.glowMaterial.uniforms.time.value = time;
            }
            
            // Animate sun lights for pulsing bright effect
            if (sunCoreLight) {
                sunCoreLight.intensity = 8 + Math.sin(time * 4) * 1.5; // More dramatic pulsing
            }
            if (sunBrightLight) {
                sunBrightLight.intensity = 6 + Math.sin(time * 3) * 1;
            }
            if (sunWarmLight) {
                sunWarmLight.intensity = 4 + Math.sin(time * 2) * 0.5;
            }
            if (sunAmbientLight) {
                sunAmbientLight.intensity = 2 + Math.sin(time * 1.5) * 0.3;
            }
            
            // Move entire solar system slightly (Drift)
            if (!solarSystem.userData.isSucked) {
                solarSystem.position.x = Math.sin(time * 0.1) * 20;
                solarSystem.position.z = Math.cos(time * 0.15) * 20;
                solarSystem.position.y = Math.sin(time * 0.05) * 5;
                solarSystem.rotation.y = Math.sin(time * 0.02) * 0.05; // Slight system rotation
            }

            // Rotate orbits and planets
            objects.forEach(obj => {
                if (obj.type === 'orbit') {
                    if (timelineActive && (obj.isExperiencePlanet || obj.isExperienceMoon)) {
                        return;
                    }
                    obj.mesh.rotation.y += obj.speed;
                } else if (obj.type === 'ellipticalOrbit') {
                    if (timelineActive && obj.pivot.children[0].children.some(c => c.userData.name === 'Experience')) return;
                    
                    obj.theta += obj.speed;
                    obj.pivot.rotation.y = obj.theta;
                    const r = (obj.a * (1 - obj.e * obj.e)) / (1 + obj.e * Math.cos(obj.theta));
                    obj.radial.position.x = r;
                } else if (obj.type === 'rotate') {
                    obj.mesh.rotation.y += obj.speed;
                }
            });

            // Comets with realistic trails
            if (Math.random() < 0.003) spawnComet(); // Slightly less frequent for better performance
            
            for (let i = comets.length - 1; i >= 0; i--) {
                const c = comets[i];
                
                // Store current position for trail
                c.trailPositions.push(c.mesh.position.clone());
                
                // Limit trail length
                if (c.trailPositions.length > c.maxTrailLength) {
                    c.trailPositions.shift();
                }
                
                // Move comet
                c.mesh.position.add(c.velocity);
                
                // Animate nucleus and coma
                c.nucleus.rotation.x += 0.02;
                c.nucleus.rotation.y += 0.01;
                c.coma.rotation.x -= 0.01;
                c.coma.rotation.y += 0.015;
                
                // Create/update trail geometry
                if (c.trailPositions.length > 2) {
                    // Remove old trail meshes
                    c.trailMeshes.forEach(trailMesh => {
                        scene.remove(trailMesh);
                        if (trailMesh.geometry) trailMesh.geometry.dispose();
                        if (trailMesh.material) trailMesh.material.dispose();
                    });
                    c.trailMeshes = [];
                    
                    // Create new trail segments
                    for (let j = 1; j < c.trailPositions.length; j++) {
                        const segmentGeo = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            c.trailPositions[j-1].x, c.trailPositions[j-1].y, c.trailPositions[j-1].z,
                            c.trailPositions[j].x, c.trailPositions[j].y, c.trailPositions[j].z
                        ]);
                        segmentGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        // Trail opacity decreases towards the back
                        const opacity = (j / c.trailPositions.length) * 0.8;
                        const segmentMat = new THREE.LineBasicMaterial({ 
                            color: 0xaaddff,
                            transparent: true,
                            opacity: opacity,
                            linewidth: 2
                        });
                        
                        const trailSegment = new THREE.Line(segmentGeo, segmentMat);
                        scene.add(trailSegment);
                        c.trailMeshes.push(trailSegment);
                    }
                }
                
                // Create glowing particles along the trail (less frequent for performance)
                if (c.life % 4 === 0 && c.trailPositions.length > 5) {
                    // Create particles at random positions along the trail
                    const randomIndex = Math.floor(Math.random() * Math.min(c.trailPositions.length, 20));
                    const trailPos = c.trailPositions[c.trailPositions.length - 1 - randomIndex];
                    
                    if (trailPos) {
                        const pGeo = new THREE.BufferGeometry();
                        // Add some randomness to particle position
                        const px = trailPos.x + (Math.random() - 0.5) * 3;
                        const py = trailPos.y + (Math.random() - 0.5) * 3;
                        const pz = trailPos.z + (Math.random() - 0.5) * 3;
                        
                        pGeo.setAttribute('position', new THREE.Float32BufferAttribute([px, py, pz], 3));
                        const pMat = new THREE.PointsMaterial({ 
                            color: Math.random() > 0.5 ? 0xffffcc : 0xaaddff,
                            size: Math.random() * 2 + 1,
                            transparent: true,
                            opacity: 0.8
                        });
                        const p = new THREE.Points(pGeo, pMat);
                        scene.add(p);
                        cometParticles.push({ mesh: p, life: 120 }); // Longer particle life
                    }
                }
                
                // Fade out comet as it ages
                const fadeStart = c.life < 150;
                if (fadeStart) {
                    const fadeOpacity = c.life / 150;
                    c.nucleus.material.opacity = fadeOpacity * 0.9;
                    c.coma.material.opacity = fadeOpacity * 0.3;
                }

                c.life--;
                if (c.life <= 0) {
                    // Clean up trail meshes
                    c.trailMeshes.forEach(trailMesh => {
                        scene.remove(trailMesh);
                        if (trailMesh.geometry) trailMesh.geometry.dispose();
                        if (trailMesh.material) trailMesh.material.dispose();
                    });
                    
                    scene.remove(c.mesh);
                    comets.splice(i, 1);
                }
            }

            // Comet Particles (enhanced with longer trails)
            for (let i = cometParticles.length - 1; i >= 0; i--) {
                const p = cometParticles[i];
                p.life--;
                
                if (p.mesh.material) {
                    // Smoother fade out over longer period
                    p.mesh.material.opacity = (p.life / 120) * 0.8;
                    
                    // Slight size reduction as particle ages
                    if (p.mesh.material.size) {
                        p.mesh.material.size = Math.max(0.2, (p.life / 120) * p.mesh.material.size);
                    }
                }
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    if (p.mesh.geometry) p.mesh.geometry.dispose();
                    if (p.mesh.material) p.mesh.material.dispose();
                    cometParticles.splice(i, 1);
                }
            }

            // Lasers
            for (let i = lasers.length - 1; i >= 0; i--) {
                const l = lasers[i];
                l.mesh.position.add(l.velocity);
                l.life--;
                if (l.life <= 0) {
                    scene.remove(l.mesh);
                    lasers.splice(i, 1);
                }
            }

            // Update labels to position above objects
            labels.forEach(item => {
                const pos = new THREE.Vector3();
                item.object.getWorldPosition(pos);

                // Hide Moon labels when zoomed out
                if (item.object.userData.isMoon) {
                    if (camera.position.distanceTo(pos) > 85) {
                        item.div.style.display = 'none';
                        return;
                    }
                }

                // Hide labels of background moons when dimmed (they're too faint to be useful)
                if (backgroundDimming && item.object.userData.isMoon && 
                    focusedObject && item.object.userData.parentPlanet !== focusedObject) {
                    item.div.style.display = 'none';
                    return;
                }

                // Position label above the object with appropriate spacing
                const objectRadius = item.object.geometry ? item.object.geometry.parameters.radius : 50;
                let labelOffset;
                
                // Adjust label positioning based on focus state
                const isFocusedPlanetSystem = focusedObject && 
                    (item.object === focusedObject || 
                     (item.object.userData.isMoon && item.object.userData.parentPlanet === focusedObject));
                
                if (item.object.userData.isMoon) {
                    if (isFocusedPlanetSystem) {
                        // Moons of focused planet: very close to moon surface
                        labelOffset = new THREE.Vector3(0, objectRadius + 3, 0);
                    } else {
                        // Moons of other planets: further away (but they'll be dimmed anyway)
                        labelOffset = new THREE.Vector3(0, objectRadius + 8, 0);
                    }
                } else if (item.object.userData.isSun) {
                    // Sun: higher above for visibility
                    labelOffset = new THREE.Vector3(0, objectRadius + 30, 0);
                } else {
                    // Planets
                    if (isFocusedPlanetSystem) {
                        // Focused planet: closer label
                        labelOffset = new THREE.Vector3(0, objectRadius + 8, 0);
                    } else {
                        // Other planets: standard spacing
                        labelOffset = new THREE.Vector3(0, objectRadius + 15, 0);
                    }
                }
                
                pos.add(labelOffset);
                pos.project(camera);
                
                const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (pos.y * -0.5 + 0.5) * window.innerHeight;
                
                // Hide Sun label if camera is inside/very close to Sun
                if ((item.object.userData.isSun || item.object.userData.viewType === 'center') && camera.position.distanceTo(item.object.position) < 5) {
                    item.div.style.display = 'none';
                    return;
                }

                if (pos.z > 1) {
                    item.div.style.display = 'none';
                } else {
                    item.div.style.display = 'block';
                    item.div.style.left = `${x}px`;
                    item.div.style.top = `${y}px`;
                }
            });

            if (revealLabelsOnNextFrame) {
                document.body.classList.remove('labels-hidden');
                revealLabelsOnNextFrame = false;
            }

            // Continuous object following
            if (focusedObject && !isCenterView) {
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                const targetPos = new THREE.Vector3();
                focusedObject.getWorldPosition(targetPos);
                
                // Smoothly follow the object as it moves through its orbit
                controls.target.lerp(targetPos, 0.05); // Smooth following with lerp
                
                // Optionally maintain camera distance relative to the object
                if (focusedObject.userData.isPlanet) {
                    const desiredDistance = (focusedObject.userData.size || 5) * 3 + 15;
                    const currentDistance = camera.position.distanceTo(targetPos);
                    
                    // Only adjust if we're too far or too close
                    if (Math.abs(currentDistance - desiredDistance) > 5) {
                        const direction = camera.position.clone().sub(targetPos).normalize();
                        const newPos = targetPos.clone().add(direction.multiplyScalar(desiredDistance));
                        camera.position.lerp(newPos, 0.02); // Gentle distance correction
                    }
                }
            } else if (!focusedObject && !isCenterView && !solarSystem.userData.isSucked) {
                // Allow normal controls - user can freely explore
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
            } else if (!isDragging) {
                // Re-enable damping when dragging is done
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
            }

            controls.update();
            webGLRenderer.render(scene, camera);
        }

        // === RESIZE ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            if (nurWarsCamera) {
                nurWarsCamera.aspect = window.innerWidth / window.innerHeight;
                nurWarsCamera.updateProjectionMatrix();
            }
            webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // === INITIALIZATION ===
        setTimeout(() => {
            document.getElementById('loading').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                animate();
            }, 1000);
        }, 1000);
        
        }
    </script>
</body>
</html>
