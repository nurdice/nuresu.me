<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <title>Nur | Mission Control</title>
    <link rel="icon" href="data:,">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Poppins', sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #solar-loading-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.88);
            color: #dbeafe;
            font-family: 'Poppins', sans-serif;
            font-size: 18px;
            z-index: 6;
            letter-spacing: 0.5px;
        }

        #blackhole-overlay {
            position: fixed;
            inset: 0;
            background: #000;
            display: none;
            z-index: 8;
            pointer-events: none;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .label {
            position: absolute;
            color: rgba(255, 255, 255, 0.95);
            font-size: 16px;
            font-weight: 600;
            text-shadow: 0 0 8px rgba(0,0,0,0.8), 0 0 15px rgba(56, 189, 248, 0.4);
            pointer-events: auto;
            cursor: pointer;
            transition: opacity 0.3s, transform 0.3s;
            transform: translate(-50%, -50%);
            white-space: nowrap;
            background: transparent;
            padding: 4px 10px;
            border-radius: 12px;
            border: none;
            backdrop-filter: none;
            text-align: center;
        }

        body.labels-hidden .label {
            opacity: 0;
            pointer-events: none;
        }

        .label:hover {
            transform: translate(-50%, -50%) scale(1.1);
            text-shadow: 0 0 12px rgba(0,0,0,0.9), 0 0 25px rgba(56, 189, 248, 0.7);
        }

        .label.major {
            font-size: 22px;
            letter-spacing: 1px;
            text-transform: uppercase;
            background: transparent;
            border: none;
            backdrop-filter: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.8), 0 0 20px rgba(56, 189, 248, 0.5);
            color: #ffffff;
        }

        #overlay-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 400px;
            height: 100%;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            transform: translateX(100%);
            transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
            padding: 40px 40px 100px 40px;
            box-sizing: border-box;
            border-left: 1px solid rgba(255,255,255,0.1);
            color: #e2e8f0;
            overflow-y: auto;
            pointer-events: auto;
        }

        #overlay-panel.active {
            transform: translateX(0);
        }

        #overlay-panel h2 {
            font-size: 36px;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #38bdf8, #818cf8);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #overlay-panel h3 {
            color: #94a3b8;
            font-size: 18px;
            margin-bottom: 30px;
            font-weight: 400;
        }

        .content-block {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
        }

        .close-btn:hover { opacity: 1; }

        #controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: auto;
            z-index: 20;
            flex-wrap: wrap;
        }

        .hud-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            font-family: 'Poppins', sans-serif;
            font-size: 16px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hud-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.3);
        }

        #nur-wars-btn:hover {
            background: url('assets/images/nurwars.png') no-repeat center/contain !important;
            background-color: transparent !important;
            transform: scale(1.1) translateY(-2px) !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4) !important;
        }

        #loading {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #38bdf8;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 768px) {
            #overlay-panel { width: 100%; }
            .hud-btn { padding: 8px 16px; font-size: 12px; }
            #sky-details {
                top: 3%;
                height: 70%; /* Reduced height on mobile to avoid button overlap */
                width: 96%;
            }
            #sky-content {
                padding: 15px; /* Reduced padding on mobile */
                font-size: 12px; /* Smaller font on mobile */
                line-height: 1.4;
            }
        }

        #sky-details {
            position: fixed;
            top: 3%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #fff;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            pointer-events: auto;
            z-index: 25; /* Increased from 15 to be above controls */
            display: none;
            width: 94%;
            max-width: 1100px; /* Slightly smaller to avoid button overlap */
            height: 75%; /* Reduced height to avoid button overlap */
            animation: fadeIn 1s ease-out;
        }
        #sky-details h1 {
            font-size: 52px;
            margin-bottom: 20px;
            color: #38bdf8;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        #sky-content {
            font-size: 14px; /* Reduced font size to fit more content */
            line-height: 1.5; /* Tighter line height */
            background: rgba(15, 23, 42, 0.95);
            padding: 20px; /* Reduced padding */
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto;
            height: calc(100% - 100px); /* Adjusted height */
            overflow-y: hidden; /* Disable scrolling */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            padding-bottom: 20px; /* Minimal bottom padding */
        }
        #sky-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.3s;
            pointer-events: auto;
        }
        #sky-close:hover { background: rgba(255, 255, 255, 0.3); }
        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -20px); } to { opacity: 1; transform: translate(-50%, 0); } }
        @keyframes simpleFadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slowSpin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes pulseGlow { 0% { box-shadow: 0 0 10px rgba(56, 189, 248, 0.5); } 50% { box-shadow: 0 0 25px rgba(56, 189, 248, 0.9); } 100% { box-shadow: 0 0 10px rgba(56, 189, 248, 0.5); } }
        @keyframes charBounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        @keyframes charHover { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
        @keyframes char3D { 
            0% { transform: perspective(600px) rotateY(0deg) rotateX(0deg) scale(1); } 
            25% { transform: perspective(600px) rotateY(90deg) rotateX(10deg) scale(1.1); } 
            50% { transform: perspective(600px) rotateY(180deg) rotateX(0deg) scale(1.2) translateY(-10px); } 
            75% { transform: perspective(600px) rotateY(270deg) rotateX(-10deg) scale(1.1); } 
            100% { transform: perspective(600px) rotateY(360deg) rotateX(0deg) scale(1); } 
        }
        @keyframes expertGlow { 
            0% { transform: perspective(600px) rotateY(0deg) scale(1); filter: drop-shadow(0 0 10px rgba(56, 189, 248, 0.5)); } 
            50% { transform: perspective(600px) rotateY(180deg) scale(1.15); filter: drop-shadow(0 0 25px rgba(56, 189, 248, 0.8)); } 
            100% { transform: perspective(600px) rotateY(360deg) scale(1); filter: drop-shadow(0 0 10px rgba(56, 189, 248, 0.5)); } 
        }
        @keyframes professionalFloat { 
            0%, 100% { transform: perspective(400px) rotateY(0deg) translateY(0px); } 
            33% { transform: perspective(400px) rotateY(120deg) translateY(-5px); } 
            66% { transform: perspective(400px) rotateY(240deg) translateY(-3px); } 
        }
        @keyframes beginnerWobble { 
            0%, 100% { transform: rotate(0deg) scale(1); } 
            25% { transform: rotate(-5deg) scale(0.95); } 
            75% { transform: rotate(5deg) scale(1.05); } 
        }

        /* 3D Hero Face Animations */
        @keyframes einsteinThink {
            0%, 100% { transform: perspective(800px) rotateY(0deg) rotateX(0deg) scale(1); }
            25% { transform: perspective(800px) rotateY(15deg) rotateX(-5deg) scale(1.05); }
            50% { transform: perspective(800px) rotateY(0deg) rotateX(5deg) scale(1.1); }
            75% { transform: perspective(800px) rotateY(-15deg) rotateX(-5deg) scale(1.05); }
        }

        @keyframes newtonApple {
            0%, 100% { transform: perspective(800px) rotateY(0deg) translateY(0px) scale(1); }
            25% { transform: perspective(800px) rotateY(90deg) translateY(-3px) scale(1.02); }
            50% { transform: perspective(800px) rotateY(180deg) translateY(-5px) scale(1.05); }
            75% { transform: perspective(800px) rotateY(270deg) translateY(-3px) scale(1.02); }
        }

        @keyframes gandhiPeace {
            0%, 100% { transform: perspective(800px) rotateX(0deg) rotateY(0deg) scale(1); }
            33% { transform: perspective(800px) rotateX(10deg) rotateY(120deg) scale(1.03); }
            66% { transform: perspective(800px) rotateX(-10deg) rotateY(240deg) scale(1.03); }
        }

        @keyframes buddhaSerenity {
            0%, 100% { transform: perspective(800px) rotateY(0deg) scale(1) translateZ(0px); }
            25% { transform: perspective(800px) rotateY(90deg) scale(1.08) translateZ(10px); }
            50% { transform: perspective(800px) rotateY(180deg) scale(1.15) translateZ(20px); }
            75% { transform: perspective(800px) rotateY(270deg) scale(1.08) translateZ(10px); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        /* NUR WARS Crawl Animation - Fixed */
        @keyframes crawl {
            0% {
                top: 100vh;
                opacity: 1;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                top: -150vh;
                opacity: 0;
            }
        }

        .crawl-text-animated {
            position: absolute;
            left: 50%;
            transform: translateX(-50%) rotateX(25deg);
            transform-origin: 50% 100%;
            width: 80%;
            max-width: 800px;
            color: #FFFFFF;
            font-family: 'Orbitron', serif;
            font-size: 32px;
            line-height: 1.8;
            text-align: justify;
            animation: crawl 60s linear forwards;
        }

        @keyframes crawlFadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes panZoomToBattle {
            0% { 
                transform: scale(1) translateZ(0px);
                opacity: 1;
            }
            50% {
                transform: scale(1.8) translateZ(150px);
                opacity: 0.5;
            }
            100% { 
                transform: scale(3) translateZ(300px);
                opacity: 0;
            }
        }

        /* Hide controls during NUR WARS */
        .nur-wars-active #controls {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-out;
        }

        /* Audio controls - hidden by default, shown on hover or during NUR WARS */
        #audio-controls {
            display: none !important;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .nur-wars-active #audio-controls {
            display: flex !important;
            opacity: 0;
            pointer-events: auto;
        }

        .nur-wars-active #audio-controls:hover {
            opacity: 1 !important;
        }

        @keyframes slideInAudio {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Language Card Glow Effect */
        @keyframes languageCardGlow {
            0% { box-shadow: 0 0 5px rgba(56, 189, 248, 0.3), 0 0 10px rgba(56, 189, 248, 0.2), 0 0 15px rgba(56, 189, 248, 0.1); }
            50% { box-shadow: 0 0 20px rgba(56, 189, 248, 0.6), 0 0 30px rgba(56, 189, 248, 0.4), 0 0 40px rgba(56, 189, 248, 0.2); }
            100% { box-shadow: 0 0 5px rgba(56, 189, 248, 0.3), 0 0 10px rgba(56, 189, 248, 0.2), 0 0 15px rgba(56, 189, 248, 0.1); }
        }

        /* Custom scrollbar for language modal */
        .language-grid::-webkit-scrollbar {
            width: 4px;
        }
        .language-grid::-webkit-scrollbar-track {
            background: rgba(56, 189, 248, 0.1);
            border-radius: 2px;
        }
        .language-grid::-webkit-scrollbar-thumb {
            background: rgba(56, 189, 248, 0.4);
            border-radius: 2px;
        }
        .language-grid::-webkit-scrollbar-thumb:hover {
            background: rgba(56, 189, 248, 0.6);
        }

        /* Mobile View Styles */
        #mobile-view {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #05050c;
            color: #f0f0ff;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
            overflow-y: auto;
            z-index: 2000; /* Above loading screen initially */
        }
        .mobile-header { text-align: center; margin-bottom: 30px; border-bottom: 1px solid #1e293b; padding-bottom: 20px; }
        .mobile-header h1 { color: #38bdf8; font-size: 24px; margin: 0 0 10px 0; }
        .mobile-header h2 { font-size: 16px; color: #94a3b8; margin: 0 0 15px 0; }
        .mobile-contact { 
            font-size: 14px; 
            color: #94a3b8; 
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .mobile-contact a { color: #38bdf8; text-decoration: none; }
        .contact-separator { display: inline; opacity: 0.4; }
        .contact-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            align-items: center;
        }
        .mobile-buttons { 
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex; 
            flex-direction: row; 
            gap: 15px; 
            justify-content: center; 
            padding: 0 20px;
            background: transparent;
            border: none;
            box-sizing: border-box;
            z-index: 2001;
            pointer-events: none;
        }
        .mobile-buttons button {
            flex: 1;
            max-width: 250px;
            padding: 14px;
            border-radius: 30px;
            color: white;
            font-family: inherit;
            font-weight: bold;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
            transition: transform 0.2s;
        }
        .mobile-buttons button:active { transform: scale(0.96); }
        #mobile-view section { margin-bottom: 30px; }
        #mobile-view h3 {
            border-bottom: 1px solid #1e293b;
            padding-bottom: 5px;
            margin-bottom: 15px;
            font-size: 20px;
            letter-spacing: 1px;
        }
        .job-block, .project-block, .edu-block, .skill-block { margin-bottom: 20px; }
        #mobile-view h4 { margin: 0 0 5px 0; font-size: 18px; }
        .job-meta { font-size: 14px; margin-bottom: 10px; font-style: italic; }
        #mobile-view ul { margin: 0; padding-left: 20px; }
        #mobile-view li { margin-bottom: 8px; font-size: 16px; line-height: 1.6; }
        #mobile-view p { font-size: 16px; line-height: 1.6; margin: 0 0 15px 0; }

        /* Desktop Fallback Layout */
        .resume-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 80px 20px 120px 20px;
            animation: simpleFadeIn 0.8s ease-out;
        }
        .resume-grid {
            display: flex;
            flex-direction: column;
            gap: 40px;
        }
        
        @media (min-width: 900px) {
            .resume-container {
                padding: 40px 40px 120px 40px;
            }
            .resume-grid {
                display: grid;
                grid-template-columns: 320px 1fr;
                gap: 40px;
                align-items: start;
            }
            .resume-sidebar {
                border-right: 1px solid var(--border-color);
                padding-right: 30px;
                order: 0;
            }
            .resume-main {
                order: 0;
            }
            .mobile-header {
                display: grid;
                grid-template-columns: 320px 1fr;
                gap: 40px;
                align-items: center;
                text-align: left !important;
            }
            .header-image-container {
                text-align: right;
                padding-right: 30px;
            }
            .mobile-contact {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .contact-group { display: contents; }
        }
        
        #back-to-top {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 2002;
            backdrop-filter: blur(5px);
            font-size: 18px;
            transition: transform 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        #back-to-top:active { transform: scale(0.9); }

        @media (max-width: 899px) {
            .resume-sidebar {
                order: 2;
                margin-top: 40px;
            }
            .resume-main {
                order: 1;
            }
        }

        @media print {
            .mobile-buttons, #controls, .hud-btn, #sky-details, #ui-layer, #loading, .mobile-header button {
                display: none !important;
            }
            #mobile-view {
                position: relative;
                height: auto;
                overflow: visible;
                background: white !important;
                color: black !important;
            }
            .resume-container {
                width: 100%;
                max-width: none;
                padding: 0;
                margin: 0;
            }
            body {
                background: white !important;
                overflow: visible;
            }
        }
    </style>
</head>
<body class="labels-hidden">

    <div id="loading" style="display:none;"><div class="loader"></div></div>
    <div id="mobile-view"></div>
    <div id="canvas-container" style="display:none;"></div>
    <div id="solar-loading-overlay" style="display:flex;">
        <div style="font-weight:600; margin-bottom:6px;">Loading solar system‚Ä¶</div>
        <div id="solar-loading-progress" style="opacity:0.8; font-size:14px;">0%</div>
    </div>
    <div id="blackhole-overlay"></div>
    <div id="ui-layer" style="display:none;"></div>
    <div id="sky-details">
        <div id="sky-close" onclick="closeSkyModal()">‚úï</div>
        <h1 id="sky-title">Moon Title</h1>
        <div id="sky-content">Details go here...</div>
    </div>

    <div id="pdf-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:100; justify-content:center; align-items:center;">
        <div style="background:rgba(15, 23, 42, 0.95); padding:40px; border-radius:20px; border:1px solid rgba(255,255,255,0.1); text-align:center; backdrop-filter:blur(10px); max-width: 400px; width: 90%;">
            <h2 style="color:#38bdf8; margin-top:0;">Download Resume</h2>
            <p style="color:#cbd5e1; margin-bottom:30px;">Choose a style for your PDF resume:</p>
            
            <div style="display:flex; gap:20px; justify-content:center; flex-wrap:wrap;">
                <button onclick="generatePDF('professional')" style="
                    background: #e2e8f0; color: #0f172a; border:none; padding:12px 24px; border-radius:8px; 
                    cursor:pointer; font-weight:600; font-family:'Poppins',sans-serif; transition:transform 0.2s;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    Professional
                </button>
                
                <button onclick="generatePDF('space')" style="
                    background: linear-gradient(135deg, #38bdf8, #818cf8); color: white; border:none; padding:12px 24px; border-radius:8px; 
                    cursor:pointer; font-weight:600; font-family:'Poppins',sans-serif; transition:transform 0.2s;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    Space Theme
                </button>
            </div>
            
            <button onclick="document.getElementById('pdf-modal').style.display='none'" style="margin-top:30px; background:transparent; border:1px solid rgba(255,255,255,0.3); color:rgba(255,255,255,0.7); padding:8px 16px; border-radius:20px; cursor:pointer;">
                Cancel
            </button>
        </div>
    </div>

    <div id="overlay-panel">
        <button class="close-btn" onclick="closeOverlay()">√ó</button>
        <h2 id="panel-title">Title</h2>
        <h3 id="panel-subtitle">Subtitle</h3>
        <div id="panel-content"></div>
    </div>

    <div id="controls">
        <button class="hud-btn" onclick="event.stopPropagation(); resetView()">‚äô Reset View</button>
        <button class="hud-btn" onclick="toggleSound()" id="sound-btn">üîá Sound Off</button>
        <button class="hud-btn" onclick="toggleOrbits()" id="orbits-btn">ü™ê Show Orbits</button>
        <button class="hud-btn" onclick="goToPreviousView()" id="back-btn" style="display: none;">‚Üê Back</button>
        <button class="hud-btn" onclick="startNurWars()" id="nur-wars-btn" aria-label="Nur Wars" style="background: url('assets/images/nurwars.png') no-repeat center/contain; background-color: transparent; border: none; width: 120px; height: 60px; padding: 0; min-width: auto; box-shadow: none; backdrop-filter: none;"></button>
        <button class="hud-btn" onclick="document.getElementById('pdf-modal').style.display='flex'">üìÑ PDF Resume</button>
    </div>

    <!-- Movie Controls (NUR WARS only) -->
    <div id="audio-controls" style="position: fixed; top: 30px; right: 30px; display: flex; gap: 10px; z-index: 1002; flex-wrap: nowrap; align-items: center;">
        <button class="hud-btn" onclick="toggleSound()" id="nur-wars-sound-btn" aria-label="Toggle sound" style="padding: 10px 16px; font-size: 14px;">üîä</button>
        <button class="hud-btn" onclick="skipMovie(-5)" id="movie-back-btn" aria-label="Back 5 seconds" style="padding: 10px 16px; font-size: 14px;">‚è™ -5s</button>
        <button class="hud-btn" onclick="toggleMoviePlayPause()" id="movie-play-btn" aria-label="Play or pause movie" style="padding: 10px 16px; font-size: 14px;">‚è∏Ô∏è Pause</button>
        <button class="hud-btn" onclick="skipMovie(5)" id="movie-forward-btn" aria-label="Forward 5 seconds" style="padding: 10px 16px; font-size: 14px;">‚è© +5s</button>
    </div>

    <!-- NUR WARS Experience -->
    <div id="nur-wars-container" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: transparent; z-index: 1000; overflow: hidden; pointer-events: none;">
        <!-- Opening Crawl -->
        <div id="opening-crawl" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; perspective: 1200px; overflow: hidden; background: transparent; -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0.2) 8%, rgba(0,0,0,1) 20%, rgba(0,0,0,1) 100%); mask-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0.2) 8%, rgba(0,0,0,1) 20%, rgba(0,0,0,1) 100%); pointer-events: none;">
            <!-- Opening text - fixed position, not affected by scroll -->
            <p id="opening-text" style="font-size: 20px; text-align: center; opacity: 0.9; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; width: 90%; max-width: 800px; z-index: 1001; color: #0099FF; font-family: 'Arial Black', 'Franklin Gothic', sans-serif; letter-spacing: 2px; line-height: 1.4; font-weight: bold; text-transform: uppercase;">A long time ago in a galaxy far, far away....</p>
            
            <!-- Nur Wars image - fixed position overlay, animated separately -->
            <div id="nurwars-image-container" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; z-index: 999; width: 90%; max-width: 600px;">
                <img src="assets/images/nurwars opening.png" alt="NUR WARS" style="width: 100%; height: auto;">
            </div>
            
            <div id="crawl-text" style="position: absolute; top: 100vh; left: 50%; transform: translateX(-50%) rotateX(0deg) scale(1); transform-origin: 50% bottom; width: 98%; max-width: 1200px; color: #feda4a; font-family: 'Arial Black', 'Franklin Gothic', sans-serif; font-size: 36px; line-height: 1.8; text-align: center; letter-spacing: 2px; font-weight: bold;">
                
                <div style="height: 50vh;"></div>
                
                <p style="margin: 0 0 30px 0;">It is a period of digital transformation. Rebel analysts, striking from hidden offices, have won their first victory against the evil Legacy Systems Empire.</p>
                
                <p style="margin: 0 0 30px 0;">During the battle, rebel spies managed to steal secret plans to the Empire's ultimate weapon, the MONOLITHIC ARCHITECTURE‚Äîa legacy system with enough power to destroy an entire business process.</p>
                
                <p style="margin: 0 0 30px 0;">In this epic tale, young NUR DAWOODANI emerges as the chosen Business Analyst, wielding 18+ years of experience across retail and banking galaxies. From the corporate towers of LULULEMON to the financial fortresses of HSBC, he has brought balance to the Force of digital transformation.</p>
                
                <p style="margin: 0 0 30px 0;">His legendary achievements include architecting the Great Revamp that saved the Retail Galaxy from scalability collapse, wielding AI-driven Product Highlights to generate multi-million credit revenues, and leading the Paperless Rebellion that eliminated 2+ million sheets annually.</p>
                
                <p style="margin: 0 0 30px 0;">Now, as the Empire of Technical Debt threatens to engulf all business processes, the galaxy's only hope lies with this Business Analysis Jedi Master...</p>
                
                <p style="margin: 0 0 30px 0;">Will Nur's mastery of SAFe, stakeholder management, and epic decomposition be enough to restore order to the chaotic universe of enterprise software?</p>
                
                <p style="margin: 0;">The fate of digital transformation rests in his capable hands...</p>
            </div>
        </div>
        
        <!-- Battle Scene -->
        <div id="battle-scene" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
            <canvas id="battle-canvas" style="width: 100%; height: 100%;"></canvas>
            <div id="battle-hud" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #FFD700; font-family: 'Orbitron', serif; text-align: center;">
                <div style="font-size: 24px; margin-bottom: 10px;">REBEL ALLIANCE MISSION</div>
                <div style="font-size: 18px;">Destroy the Legacy System Death Star</div>
                <div style="font-size: 14px; margin-top: 10px; opacity: 0.8;">Use the Force of Business Analysis, Nur...</div>
            </div>
        </div>
        
        <!-- Close Button -->
        <button id="exit-hyperspace-btn" style="position: fixed; top: 20px; left: 20px; background: rgba(255,100,100,0.3); border: 2px solid #FF6464; color: #FF6464; padding: 12px 20px; border-radius: 5px; font-family: 'Orbitron', serif; cursor: pointer; z-index: 1003; display: none; font-weight: bold; pointer-events: auto;">
            ‚èπ EXIT HYPERSPACE
        </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="resume_data.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const RESUME_DATA = window.RESUME_DATA;
        const { jsPDF } = window.jspdf;
        
        // Initialize GLTF Loader for 3D models (supports KHR_materials_pbrSpecularGlossiness natively)
        const gltfLoader = new GLTFLoader();

        // Check if RESUME_DATA is loaded properly
        if (!RESUME_DATA) {
            console.error('RESUME_DATA not loaded properly');
            startFallbackMode('Resume data failed to load. Please refresh the page.');
            throw new Error('RESUME_DATA not available');
        }

        if (!RESUME_DATA.name) {
            console.error('RESUME_DATA.name is undefined');
            startFallbackMode('Resume data is incomplete. Please refresh the page.');
            throw new Error('RESUME_DATA.name not available');
        }


        // === STATE VARIABLES (MUST BE DECLARED FIRST) ===
        const objects = [];
        const clickableObjects = [];
        const labels = [];
        let revealLabelsOnNextFrame = false;
        const orbitPaths = [];
        const moonOrbitPaths = []; // Separate array for moon orbits
        let activeSuctionAnimations = {};
        let stopSuctionAnimation = false; // Flag to stop animation updates // Store animation tweens for cleanup
        let focusedObject = null;
        let isCenterView = false;
        let previousCameraPos = new THREE.Vector3();
        let previousTarget = new THREE.Vector3();
        let timelineActive = false;
        let soundEnabled = false;
        let backgroundAudio = null;
        let orbitsVisible = false;
        const comets = [];
        const cometParticles = [];
        const lasers = [];
        let falconModel = null;
        let falconModelPromise = null;
        let tieFighterModel = null;
        let tieFighterModelPromise = null;
        
        // View history system variables (functions defined after camera creation)
        const viewHistory = [];
        let currentViewIndex = -1;
        
        // Background dimming system
        let backgroundDimming = false;
        const backgroundObjects = []; // Will store all planets/moons for dimming
        
        // Tour mode system
        let tourMode = false;
        let tourIndex = 0;
        let tourSequence = [];
        let tourTimer = null;
        const TOUR_DURATION = 4000; // 4 seconds per stop
        
        // Gravitational visualization system
        let gravityMode = false;
        const gravityLines = [];
        const gravityParticles = [];
        let gravityAnimationFrame = 0;
        let renderMode = 'default'; // 'default' or 'battle'

        // === SETUP THREE.JS (BEFORE ANYTHING ELSE) ===
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        
        function startFallbackMode(errorMessage = null) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('canvas-container').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            
            const container = document.getElementById('mobile-view');
            container.style.display = 'block';
            
            container.addEventListener('scroll', () => {
                const btn = document.getElementById('back-to-top');
                if (btn) {
                    btn.style.display = container.scrollTop > 300 ? 'flex' : 'none';
                }
            });

            window.renderMobileView = (theme) => {
                const isSpace = theme === 'space';
                
                const linkColor = isSpace ? '#38bdf8' : '#2563eb';
                const borderColor = isSpace ? '#1e293b' : '#e2e8f0';
                const headerColor = isSpace ? '#38bdf8' : '#0f172a';
                const subHeaderColor = isSpace ? '#94a3b8' : '#64748b';
                const sectionTitleColor = isSpace ? '#38bdf8' : '#0f172a';
                const itemTitleColor = isSpace ? '#e2e8f0' : '#334155';

                // Theme Styles
                container.style.backgroundColor = isSpace ? '#05050c' : '#ffffff';
                container.style.color = isSpace ? '#f0f0ff' : '#1e293b';
                container.style.fontFamily = isSpace ? "'Courier New', Courier, monospace" : "'Poppins', sans-serif";
                container.style.setProperty('--border-color', borderColor);
                
                // Background effect for space
                if (isSpace) {
                    container.style.backgroundImage = "radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 3px), radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 2px), radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 3px)";
                    container.style.backgroundSize = "550px 550px, 350px 350px, 250px 250px";
                    container.style.backgroundPosition = "0 0, 40px 60px, 130px 270px";
                } else {
                    container.style.backgroundImage = "none";
                }

                const summaryTitle = isSpace ? "MISSION OBJECTIVE & PROFILE" : "SUMMARY";

                const profileImg = isSpace ? (RESUME_DATA.profileImageDark || RESUME_DATA.profileImage) : (RESUME_DATA.profileImageLight || RESUME_DATA.profileImage);

                let html = `
                    ${errorMessage ? `<div style="position: sticky; top: 0; z-index: 3000; background: rgba(220, 38, 38, 0.4); color: white; padding: 8px 10px; text-align: center; font-family: sans-serif; font-size: 11px; margin: 0; border-bottom: 1px solid rgba(255, 100, 100, 0.3); backdrop-filter: blur(12px); line-height: 1.3;">
                        <strong style="display:block; font-size:13px; margin-bottom:2px;">‚ö†Ô∏è 3D View Unavailable</strong>
                        ${errorMessage}
                    </div>` : ''}

                    <div class="resume-container" style="padding-top: ${errorMessage ? '140px' : '80px'}">
                    
                    <!-- Header -->
                    <div class="mobile-header" style="border-bottom: 1px solid ${borderColor}">
                        <div class="header-image-container">
                            <img src="${profileImg}" style="width: 160px; height: 160px; border-radius: 50%; border: 4px solid ${borderColor}; object-fit: cover;">
                        </div>
                        <div class="header-content">
                            <h1 style="color:${headerColor}; font-size: 32px; margin: 0 0 20px 0; line-height: 1.2;">${RESUME_DATA.name.toUpperCase()}</h1>
                            <h2 style="color:${subHeaderColor}; font-size: 20px; margin: 0 0 20px 0;">${RESUME_DATA.role}</h2>
                            <div class="mobile-contact" style="color:${subHeaderColor}">
                                <div class="contact-group">
                                    <span>üìß ${RESUME_DATA.contact.email}</span>
                                    <span class="contact-separator">|</span>
                                    <span>üì± ${RESUME_DATA.contact.phone}</span>
                                </div>
                                <div class="contact-group">
                                    <span>üìç ${RESUME_DATA.contact.location}</span>
                                    <span class="contact-separator">|</span>
                                    <span>üîó <a href="https://${RESUME_DATA.contact.linkedin}" target="_blank" style="color:${linkColor}">LinkedIn</a></span>
                                    <span class="contact-separator">|</span>
                                    <span>üåê <a href="https://${RESUME_DATA.contact.website}" target="_blank" style="color:${linkColor}">Website</a></span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="resume-grid">
                        <!-- Sidebar (Skills, Education) -->
                        <div class="resume-sidebar">
                `;

                // --- DYNAMIC RENDERER ---
                const renderPlanet = (planet) => {
                    const sectionTitle = isSpace ? (planet.spaceTitle || planet.title || planet.name) : (planet.title || planet.name);
                    let html = `<section><h3 style="color:${sectionTitleColor}; border-bottom: 1px solid ${borderColor}">${sectionTitle.toUpperCase()}</h3>`;
                    
                    if (planet.renderType === 'experience') {
                        planet.moons.forEach(moon => {
                            const d = isSpace ? (moon.spaceDetails || moon.pdfDetails || {}) : (moon.pdfDetails || moon.moonDetails || {});
                            html += `<div class="job-block">
                                <h4 style="color:${itemTitleColor}">${d.company || moon.name}</h4>
                                <div class="job-meta" style="color:${subHeaderColor}">${d.role} | ${d.duration}</div>
                                <ul>${(d.achievements || []).map(a => `<li>${a}</li>`).join('')}</ul>
                            </div>`;
                        });
                    } 
                    else if (planet.renderType === 'projects') {
                        planet.moons.forEach(moon => {
                            const d = isSpace ? (moon.spaceDetails || moon.pdfDetails || {}) : (moon.pdfDetails || moon.moonDetails || {});
                            html += `<div class="project-block">
                                <h4 style="color:${itemTitleColor}">${d.title || moon.name}</h4>
                                <p>${d.description || ''}</p>
                                ${d.impact ? `<p><strong>Impact:</strong> ${d.impact.join('. ')}</p>` : ''}
                            </div>`;
                        });
                    }
                    else if (planet.renderType === 'list' || planet.renderType === 'skills') {
                        planet.moons.forEach(moon => {
                            const d = isSpace ? (moon.spaceDetails || moon.pdfDetails || {}) : (moon.pdfDetails || moon.moonDetails || {});
                            const list = d.skills || d.tools || d.outcomes || d.items || [];
                            html += `<div class="skill-block">
                                <h4 style="color:${itemTitleColor}">${d.title || moon.name}</h4>
                                ${list.length ? `<p>${list.join(', ')}</p>` : ''}
                            </div>`;
                        });
                    }
                    else if (planet.renderType === 'text-list') {
                        planet.moons.forEach(moon => {
                            const d = isSpace ? (moon.spaceDetails || moon.pdfDetails || {}) : (moon.pdfDetails || moon.moonDetails || {});
                            const list = d.problems || d.practices || d.stages || d.stakeholders || d.approaches || [];
                            html += `<div class="project-block">
                                <h4 style="color:${itemTitleColor}">${d.title || moon.name}</h4>
                                ${d.description ? `<p>${d.description}</p>` : ''}
                                ${list.length ? `<ul>${list.map(i => `<li>${i}</li>`).join('')}</ul>` : ''}
                            </div>`;
                        });
                    }
                    else if (planet.renderType === 'education') {
                        const pd = isSpace ? (planet.spaceDetails || planet.pdfDetails || {}) : (planet.pdfDetails || {});
                        if (pd.degree) {
                            html += `<div class="edu-block">
                                <h4 style="color:${itemTitleColor}">${pd.degree}</h4>
                                <p>${pd.institution}<br>${pd.university}<br><span style="font-size:0.9em; opacity:0.8">${pd.duration || ''}</span></p>
                            </div>`;
                        }
                        planet.moons.forEach(moon => {
                            const d = isSpace ? (moon.spaceDetails || moon.pdfDetails || {}) : (moon.pdfDetails || moon.moonDetails || {});
                            const list = d.items || d.skills || [];
                            if (list.length) {
                                html += `<div class="edu-block"><h4 style="color:${itemTitleColor}">${d.title || moon.name}</h4><ul>${list.map(i => `<li>${i}</li>`).join('')}</ul></div>`;
                            }
                        });
                    }
                    else if (planet.renderType === 'languages') {
                        const pd = isSpace ? (planet.spaceDetails || planet.pdfDetails || {}) : (planet.pdfDetails || {});
                        if (pd.languages) {
                            html += `<div class="skill-block"><ul style="list-style:none; padding:0;">`;
                            pd.languages.forEach(lang => {
                                html += `<li style="margin-bottom:4px;"><strong>${lang.name}:</strong> ${lang.level}</li>`;
                            });
                            html += `</ul></div>`;
                        }
                    }
                    
                    html += `</section>`;
                    return html;
                };

                // --- SIDEBAR CONTENT ---
                const sidebarPlanets = RESUME_DATA.planets.filter(p => p.section === 'sidebar').sort((a,b) => a.order - b.order);
                sidebarPlanets.forEach(p => {
                    html += renderPlanet(p);
                });

                html += `</div> <!-- End Sidebar -->

                        <!-- Main Content (Summary, Experience, Projects) -->
                        <div class="resume-main">
                `;

                // --- MAIN CONTENT ---
                // Summary
                const summaryText = isSpace ? (RESUME_DATA.spaceSummary || RESUME_DATA.summary) : (RESUME_DATA.pdfSummary || RESUME_DATA.summary);
                html += `<section><h3 style="color:${sectionTitleColor}; border-bottom: 1px solid ${borderColor}">${summaryTitle}</h3><p>${summaryText}</p></section>`;

                const mainPlanets = RESUME_DATA.planets.filter(p => p.section === 'main').sort((a,b) => a.order - b.order);
                mainPlanets.forEach(p => {
                    html += renderPlanet(p);
                });
                
                html += `</div> <!-- End Main -->
                    </div> <!-- End Grid -->
                </div> <!-- End Container -->`;

                // Button Styles
                const commonBtnStyle = "cursor: pointer; font-family: inherit; font-weight: bold; transition: transform 0.2s; backdrop-filter: blur(5px);";
                const spaceBtnStyle = `background: rgba(56, 189, 248, 0.25); border: 1px solid rgba(56, 189, 248, 0.4); color: #e0f2fe; box-shadow: 0 4px 15px rgba(0,0,0,0.3); ${commonBtnStyle}`;
                const profBtnStyle = `background: rgba(241, 245, 249, 0.75); border: 1px solid rgba(226, 232, 240, 0.6); color: #0f172a; box-shadow: 0 2px 5px rgba(0,0,0,0.05); ${commonBtnStyle}`;

                const backToTopStyle = isSpace ? spaceBtnStyle : profBtnStyle;
                const btnTop = errorMessage ? '90px' : '20px';
                const btnRight = isMobile ? '20px' : '180px';
                const themeBtnStyle = isSpace 
                    ? `position: fixed; top: ${btnTop}; right: ${btnRight}; z-index: 2002; padding: 10px 16px; border-radius: 30px; font-size: 12px; ${spaceBtnStyle}`
                    : `position: fixed; top: ${btnTop}; right: ${btnRight}; z-index: 2002; padding: 10px 16px; border-radius: 30px; font-size: 12px; ${profBtnStyle}`;

                const downloadBtnStyle = isSpace 
                    ? spaceBtnStyle 
                    : profBtnStyle;

                // Add Floating Theme Button
                html += `<button onclick="renderMobileView('${isSpace ? 'professional' : 'space'}')" style="${themeBtnStyle}">
                    ${isSpace ? '‚òÄÔ∏è View Professional' : 'ü™ê View Space Theme'}
                </button>`;

                html += `<button id="back-to-top" onclick="document.getElementById('mobile-view').scrollTo({top: 0, behavior: 'smooth'})" style="${backToTopStyle}">‚Üë</button>`;

                html += `<div class="mobile-buttons">
                    ${!isMobile ? `<button onclick="window.print()" style="${downloadBtnStyle}">üñ®Ô∏è Print</button>` : ''}
                    <button onclick="generatePDF('professional')" style="${downloadBtnStyle}">üìÑ Professional PDF</button>
                    <button onclick="generatePDF('space')" style="${downloadBtnStyle}">üöÄ Space PDF</button>
                </div>`;

                container.innerHTML = html;
            };

            // Initial render - Professional (Light) by default
            renderMobileView('professional');
            
        }

        if (isMobile) {
            startFallbackMode();
        } else {

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.0008);
        
        // Container for Sun and Planets to move together
        const solarSystem = new THREE.Group();
        solarSystem.userData.isSucked = false;
        scene.add(solarSystem);

        // Black hole in the far background
        const blackHoleGroup = new THREE.Group();
        blackHoleGroup.userData = { isBlackHole: true, name: 'Black Hole' };
        blackHoleGroup.position.set(900, 260, -250);
        blackHoleGroup.renderOrder = 0;
        scene.add(blackHoleGroup);
        clickableObjects.push(blackHoleGroup);
        objects.push({ mesh: blackHoleGroup, speed: 0.0006, type: 'rotate' });

        blackHoleGroup.rotation.x = 0;

        const blackHoleLight = new THREE.PointLight(0xffffff, 35.0, 3600);
        blackHoleLight.position.set(0, 0, 0);
        blackHoleGroup.add(blackHoleLight);

        const blackHoleHitGeo = new THREE.SphereGeometry(160, 24, 24);
        const blackHoleHitMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.02
        });
        const blackHoleHit = new THREE.Mesh(blackHoleHitGeo, blackHoleHitMat);
        blackHoleHit.frustumCulled = false;
        blackHoleHit.userData = { isBlackHole: true };
        blackHoleGroup.add(blackHoleHit);

        // Add black sphere at center to hide stars
        const blackCenterGeo = new THREE.SphereGeometry(100, 32, 32);
        const blackCenterMat = new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: false
        });
        const blackCenter = new THREE.Mesh(blackCenterGeo, blackCenterMat);
        blackCenter.frustumCulled = false;
        blackCenter.position.z = 0;
        blackHoleGroup.add(blackCenter);

        gltfLoader.load(
            'assets/models/blackhole/scene.gltf',
            (gltf) => {
                const blackHoleModel = gltf.scene;
                blackHoleModel.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                        child.renderOrder = 0;
                        if (child.material) {
                            const mats = Array.isArray(child.material) ? child.material : [child.material];
                            mats.forEach((m) => {
                                if (!m) return;
                                m.depthTest = true;
                                m.depthWrite = true;
                                m.needsUpdate = true;
                            });
                        }
                        const mat = child.material;
                        // Keep materials as-is without emissive boost
                        if (Array.isArray(mat)) {
                            // Materials are arrays
                        } else {
                            // Single material
                        }
                    }
                });
                blackHoleModel.scale.set(140, 140, 140);
                blackHoleGroup.add(blackHoleModel);
            },
            undefined,
            (error) => {
                console.error('Failed to load black hole model', error);
            }
        );

        // UI layer hidden initially (labels, etc)
        const uiLayer = document.getElementById('ui-layer');
        const blackHoleOverlay = document.getElementById('blackhole-overlay');
        document.body.classList.add('labels-hidden');

        // Solar system loading state
        let solarModelsToLoad = 0;
        let solarModelsLoaded = 0;
        let solarLoadTimeoutId = null;

        const solarLoadingOverlay = document.getElementById('solar-loading-overlay');

        function updateSolarLoadingOverlay() {
            const progressEl = document.getElementById('solar-loading-progress');
            if (!progressEl) return;
            const percent = solarModelsToLoad === 0 ? 0 : Math.round((solarModelsLoaded / solarModelsToLoad) * 100);
            progressEl.textContent = `${percent}%`;
        }

        function checkSolarModelsReady() {
            updateSolarLoadingOverlay();
            if (solarModelsToLoad > 0 && solarModelsLoaded >= solarModelsToLoad) {
                // Show everything at once
                container.style.display = 'block';
                uiLayer.style.display = 'flex';
                solarLoadingOverlay.style.display = 'none';
                revealLabelsOnNextFrame = true;
                if (solarLoadTimeoutId) {
                    clearTimeout(solarLoadTimeoutId);
                    solarLoadTimeoutId = null;
                }
            }
        }

        // Failsafe: never block the UI forever
        solarLoadTimeoutId = setTimeout(() => {
            container.style.display = 'block';
            uiLayer.style.display = 'flex';
            solarLoadingOverlay.style.display = 'none';
            revealLabelsOnNextFrame = true;
        }, 15000);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(0, 150, 900); // High viewpoint for better perspective
        
        let webGLRenderer;
        try {
            webGLRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        } catch (e) {
            console.warn("WebGL failed, falling back to static view.");
            startFallbackMode("Hardware Acceleration is disabled or not supported. To see the interactive 3D solar system, please enable <strong>'Use graphics acceleration when available'</strong> in your browser settings and reload the page.");
            throw new Error("WebGL Fallback");
        }
        webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        webGLRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        webGLRenderer.shadowMap.enabled = true;
        webGLRenderer.shadowMap.type = THREE.PCFShadowShadowMap;
        if ('outputColorSpace' in webGLRenderer) {
            webGLRenderer.outputColorSpace = THREE.SRGBColorSpace;
        } else if ('outputEncoding' in webGLRenderer) {
            webGLRenderer.outputEncoding = THREE.sRGBEncoding;
        }
        webGLRenderer.toneMapping = THREE.NoToneMapping;
        container.appendChild(webGLRenderer.domElement);

        const controls = new OrbitControls(camera, webGLRenderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 2000;
        if (isMobile) {
            controls.enablePan = false;
            controls.rotateSpeed = 0.5;
        }

        // === VIEW HISTORY SYSTEM (AFTER CAMERA/CONTROLS CREATION) ===
        function saveCurrentView() {
            const currentView = {
                cameraPosition: camera.position.clone(),
                cameraTarget: controls.target.clone(),
                focusedObject: focusedObject,
                isCenterView: isCenterView,
                timestamp: Date.now()
            };
            
            // Remove any views after current index (when going back and then making new selection)
            viewHistory.splice(currentViewIndex + 1);
            
            // Add new view
            viewHistory.push(currentView);
            currentViewIndex = viewHistory.length - 1;
            
            // Limit history to last 10 views
            if (viewHistory.length > 10) {
                viewHistory.shift();
                currentViewIndex--;
            }
            
            // Update back button visibility
            updateBackButton();
        }
        
        function goToPreviousView() {
            if (currentViewIndex > 0) {
                currentViewIndex--;
                const previousView = viewHistory[currentViewIndex];
                
                // Restore previous view
                focusedObject = previousView.focusedObject;
                isCenterView = previousView.isCenterView;
                
                // Update moon orbit visibility for the restored focused object
                updateMoonOrbitVisibility();
                
                // Animate to previous camera position
                gsap.to(camera.position, {
                    x: previousView.cameraPosition.x,
                    y: previousView.cameraPosition.y,
                    z: previousView.cameraPosition.z,
                    duration: 1.0
                });
                
                gsap.to(controls.target, {
                    x: previousView.cameraTarget.x,
                    y: previousView.cameraTarget.y,
                    z: previousView.cameraTarget.z,
                    duration: 1.0
                });
                
                // Close any open modals
                document.getElementById('sky-details').style.display = 'none';
                document.getElementById('overlay-panel').classList.remove('active');
                
                // Update back button visibility
                updateBackButton();
                
                return true; // Successfully went back
            }
            return false; // No previous view available
        }
        
        function updateBackButton() {
            const backBtn = document.getElementById('back-btn');
            if (backBtn) {
                backBtn.style.display = (currentViewIndex > 0) ? 'block' : 'none';
            }
        }
        
        // Make goToPreviousView available globally
        window.goToPreviousView = goToPreviousView;

        // === LIGHTING ===
        // Ambient light now configured with sun setup for better brightness
        
        const sunLight = new THREE.PointLight(0xffffff, 6, 2000);
        sunLight.position.set(0, 0, 0);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096;
        sunLight.shadow.mapSize.height = 4096;
        scene.remove(sunLight);
        solarSystem.add(sunLight);

        // Additional fill lights to make planets visible from all angles
        const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        fillLight1.position.set(500, 300, 500);
        scene.add(fillLight1);

        const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
        fillLight2.position.set(-500, 200, -300);
        scene.add(fillLight2);

        const fillLight3 = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight3.position.set(0, -400, 600);
        scene.add(fillLight3);

        // === MINIMAL GSAP REPLACEMENT ===
        const gsap = {
            to: function(target, config) {
                const startValues = {};
                const endValues = config;
                const duration = (config.duration || 0) * 1000;
                const startTime = Date.now();
                const easeFunc = this.easeInOut;

                Object.keys(endValues).forEach(key => {
                    if (key !== 'duration' && key !== 'ease' && key !== 'onComplete') {
                        startValues[key] = target[key];
                    }
                });

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = easeFunc(progress);

                    Object.keys(startValues).forEach(key => {
                        target[key] = startValues[key] + (endValues[key] - startValues[key]) * eased;
                    });

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else if (config.onComplete) {
                        config.onComplete();
                    }
                };

                animate();
            },
            easeInOut: function(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }
        };

        // === TEXTURE GENERATORS ===
        function createCanvasTexture(width, height, drawFn) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            drawFn(ctx, width, height);
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            // expose the source canvas for UI snapshot fallback
            tex._canvas = canvas;
            return tex;
        }

        // Red Experience planet with Jupiter-like atmosphere - BRIGHTER
        function drawRed(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#8a2a2a'); // Brighter starting color
            grad.addColorStop(0.15, '#d04a4a'); // Much brighter
            grad.addColorStop(0.3, '#ff5a5a'); // Bright red
            grad.addColorStop(0.4, '#ff7777'); // Even brighter
            grad.addColorStop(0.5, '#ff6666');
            grad.addColorStop(0.6, '#ff5555');
            grad.addColorStop(0.7, '#ee4444');
            grad.addColorStop(0.85, '#bb3333');
            grad.addColorStop(1, '#8a2a2a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Atmospheric bands (lighter)
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 18; i++) {
                const y = (i / 18) * h;
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.08 + 0.02})`; // Reduced darkness
                ctx.fillRect(0, y, w, Math.random() * 25 + 12);
            }

            // Large storm/vortex - brighter
            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = 'rgba(220, 60, 60, 0.4)'; // Brighter storm
            ctx.beginPath();
            ctx.ellipse(w * 0.62, h * 0.58, w * 0.2, h * 0.14, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Atmospheric swirls - brighter
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 200; i++) {
                ctx.fillStyle = `rgba(255,220,220,${Math.random() * 0.18})`; // Brighter swirls
                ctx.beginPath();
                ctx.ellipse(Math.random() * w, Math.random() * h, 50 + Math.random() * 130, 12 + Math.random() * 35, Math.random() * Math.PI, 0, Math.PI * 2);
                ctx.fill();
            }

            // Bright highlights for atmospheric reflection
            for(let i = 0; i < 120; i++) {
                ctx.fillStyle = `rgba(255,180,180,${Math.random() * 0.25})`; // Brighter highlights
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, Math.random() * 18 + 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // BRIGHTER TEXTURE GENERATORS
        // Mars - Even lighter red/orange
        function drawMars(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#8b5a3a');
            grad.addColorStop(0.15, '#b8704a');
            grad.addColorStop(0.3, '#e07855');
            grad.addColorStop(0.5, '#ff9966');
            grad.addColorStop(0.7, '#e07855');
            grad.addColorStop(0.85, '#b8704a');
            grad.addColorStop(1, '#8b5a3a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 15; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1 + 0.02})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 60 + Math.random() * 150, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 150; i++) {
                ctx.fillStyle = `rgba(255, 180, 120, ${Math.random() * 0.25})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 30 + Math.random() * 80, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Venus - Brighter golden yellow
        function drawVenus(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#d4b85a'); // Much brighter starting color
            grad.addColorStop(0.15, '#ffeb8f'); // Brighter
            grad.addColorStop(0.3, '#ffffbb'); // Brighter
            grad.addColorStop(0.5, '#ffffbb'); // Brighter
            grad.addColorStop(0.7, '#ffeb99');
            grad.addColorStop(0.85, '#f5d86f');
            grad.addColorStop(1, '#d4b85a'); // Brighter end
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 10; i++) {
                const y = (i / 10) * h;
                ctx.fillStyle = `rgba(200, 160, 80, ${Math.random() * 0.06 + 0.01})`; // Reduced darkness
                ctx.fillRect(0, y, w, Math.random() * 30 + 15);
            }

            ctx.globalCompositeOperation = 'overlay';
            for(let i = 0; i < 150; i++) {
                ctx.fillStyle = `rgba(255, 240, 180, ${Math.random() * 0.3})`; // Brighter overlay
                ctx.beginPath();
                ctx.ellipse(Math.random() * w, Math.random() * h, 70 + Math.random() * 140, 20 + Math.random() * 40, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Jupiter - Even lighter cream/tan
        function drawJupiter(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#6b5a45');
            grad.addColorStop(0.15, '#b39a7a');
            grad.addColorStop(0.3, '#ddb878');
            grad.addColorStop(0.4, '#e8d9a8');
            grad.addColorStop(0.5, '#ddb878');
            grad.addColorStop(0.6, '#d4a574');
            grad.addColorStop(0.7, '#c49c6a');
            grad.addColorStop(0.85, '#a68a67');
            grad.addColorStop(1, '#8b7a57');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 20; i++) {
                const y = (i / 20) * h;
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1 + 0.02})`;
                ctx.fillRect(0, y, w, Math.random() * 20 + 10);
            }

            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = 'rgba(240, 140, 100, 0.2)';
            ctx.beginPath();
            ctx.ellipse(w * 0.65, h * 0.55, w * 0.18, h * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 180; i++) {
                ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, Math.random() * 15 + 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Saturn - Brighter vanilla/cream
        function drawSaturn(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#8b7a5a');
            grad.addColorStop(0.15, '#d9c896');
            grad.addColorStop(0.3, '#f0e8c8');
            grad.addColorStop(0.5, '#fffae6');
            grad.addColorStop(0.7, '#f0e8c8');
            grad.addColorStop(0.85, '#d9c896');
            grad.addColorStop(1, '#8b7a5a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 12; i++) {
                const y = (i / 12) * h;
                ctx.fillStyle = `rgba(140, 120, 80, ${Math.random() * 0.08 + 0.02})`;
                ctx.fillRect(0, y, w, Math.random() * 15 + 8);
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 150; i++) {
                ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.18})`;
                ctx.beginPath();
                ctx.ellipse(Math.random() * w, Math.random() * h, 60 + Math.random() * 120, 10 + Math.random() * 20, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Uranus - Brighter light cyan
        function drawUranus(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#5a7a9a');
            grad.addColorStop(0.2, '#7aaacc');
            grad.addColorStop(0.35, '#99ccff');
            grad.addColorStop(0.5, '#bbddff');
            grad.addColorStop(0.65, '#99ccff');
            grad.addColorStop(0.8, '#7aaacc');
            grad.addColorStop(1, '#5a7a9a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'overlay';
            for(let i = 0; i < 25; i++) {
                ctx.fillStyle = `rgba(180, 220, 255, ${Math.random() * 0.2})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 60 + Math.random() * 120, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Neptune - Brighter light blue
        function drawNeptune(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#5a7a9a');
            grad.addColorStop(0.2, '#3399ff');
            grad.addColorStop(0.35, '#66b3ff');
            grad.addColorStop(0.5, '#99ccff');
            grad.addColorStop(0.65, '#66b3ff');
            grad.addColorStop(0.8, '#3399ff');
            grad.addColorStop(1, '#5a7a9a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = 'rgba(150, 200, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(w * 0.7, h * 0.4, w * 0.12, 0, Math.PI * 2);
            ctx.fill();

            for(let i = 0; i < 35; i++) {
                ctx.fillStyle = `rgba(200, 230, 255, ${Math.random() * 0.25})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 50 + Math.random() * 100, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Photorealistic Earth texture using advanced canvas techniques like the sun
        function drawEarth(ctx, w, h) {
            // Base ocean with sophisticated depth gradient
            const oceanGradient = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h)/2);
            oceanGradient.addColorStop(0, '#1e40af');
            oceanGradient.addColorStop(0.3, '#1d4ed8');
            oceanGradient.addColorStop(0.6, '#1e3a8a');
            oceanGradient.addColorStop(0.8, '#1e293b');
            oceanGradient.addColorStop(1, '#0f172a');
            ctx.fillStyle = oceanGradient;
            ctx.fillRect(0, 0, w, h);

            // Add thousands of ocean depth particles for realism
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 8000; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 3 + 0.5;
                const intensity = Math.random() * 0.15 + 0.05;
                
                ctx.fillStyle = `rgba(30, 58, 138, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add ocean surface sparkles
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 2000; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 1.5 + 0.2;
                const intensity = Math.random() * 0.3 + 0.1;
                
                ctx.fillStyle = `rgba(100, 150, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'source-over';

            // AFRICA - with advanced gradient and texture
            ctx.save();
            const africaGradient = ctx.createRadialGradient(w * 0.53, h * 0.4, 0, w * 0.53, h * 0.4, w * 0.15);
            africaGradient.addColorStop(0, '#22c55e');
            africaGradient.addColorStop(0.3, '#16a34a');
            africaGradient.addColorStop(0.6, '#15803d');
            africaGradient.addColorStop(0.8, '#166534');
            africaGradient.addColorStop(1, '#14532d');
            ctx.fillStyle = africaGradient;
            
            // Create Africa with bezier curves
            ctx.beginPath();
            ctx.moveTo(w * 0.52, h * 0.22);
            ctx.bezierCurveTo(w * 0.58, h * 0.20, w * 0.62, h * 0.25, w * 0.63, h * 0.30);
            ctx.bezierCurveTo(w * 0.62, h * 0.38, w * 0.60, h * 0.45, w * 0.58, h * 0.52);
            ctx.bezierCurveTo(w * 0.56, h * 0.58, w * 0.52, h * 0.60, w * 0.48, h * 0.58);
            ctx.bezierCurveTo(w * 0.44, h * 0.55, w * 0.43, h * 0.48, w * 0.45, h * 0.40);
            ctx.bezierCurveTo(w * 0.46, h * 0.32, w * 0.48, h * 0.25, w * 0.52, h * 0.22);
            ctx.fill();

            // Add thousands of vegetation particles to Africa
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 3000; i++) {
                const x = w * (0.43 + Math.random() * 0.20);
                const y = h * (0.22 + Math.random() * 0.38);
                if(ctx.isPointInPath(x, y)) {
                    const size = Math.random() * 2 + 0.3;
                    const intensity = Math.random() * 0.4 + 0.1;
                    ctx.fillStyle = `rgba(21, 128, 61, ${intensity})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Add bright vegetation highlights
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 800; i++) {
                const x = w * (0.43 + Math.random() * 0.20);
                const y = h * (0.22 + Math.random() * 0.38);
                const size = Math.random() * 1 + 0.2;
                const intensity = Math.random() * 0.2 + 0.05;
                ctx.fillStyle = `rgba(34, 197, 94, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // ASIA - with sophisticated rendering
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            const asiaGradient = ctx.createRadialGradient(w * 0.73, h * 0.23, 0, w * 0.73, h * 0.23, w * 0.2);
            asiaGradient.addColorStop(0, '#10b981');
            asiaGradient.addColorStop(0.4, '#059669');
            asiaGradient.addColorStop(0.7, '#047857');
            asiaGradient.addColorStop(1, '#065f46');
            ctx.fillStyle = asiaGradient;
            
            ctx.beginPath();
            ctx.moveTo(w * 0.58, h * 0.15);
            ctx.bezierCurveTo(w * 0.75, h * 0.10, w * 0.85, h * 0.15, w * 0.88, h * 0.25);
            ctx.bezierCurveTo(w * 0.87, h * 0.32, w * 0.82, h * 0.36, w * 0.75, h * 0.35);
            ctx.bezierCurveTo(w * 0.68, h * 0.33, w * 0.62, h * 0.28, w * 0.60, h * 0.22);
            ctx.bezierCurveTo(w * 0.58, h * 0.18, w * 0.58, h * 0.15, w * 0.58, h * 0.15);
            ctx.fill();

            // Add detailed terrain to Asia
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 4000; i++) {
                const x = w * (0.58 + Math.random() * 0.30);
                const y = h * (0.15 + Math.random() * 0.20);
                const size = Math.random() * 2.5 + 0.4;
                const intensity = Math.random() * 0.3 + 0.1;
                ctx.fillStyle = `rgba(4, 120, 87, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // NORTH AMERICA - with advanced texturing
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            const naGradient = ctx.createRadialGradient(w * 0.22, h * 0.23, 0, w * 0.22, h * 0.23, w * 0.15);
            naGradient.addColorStop(0, '#6ee7b7');
            naGradient.addColorStop(0.3, '#10b981');
            naGradient.addColorStop(0.7, '#059669');
            naGradient.addColorStop(1, '#047857');
            ctx.fillStyle = naGradient;
            
            ctx.beginPath();
            ctx.moveTo(w * 0.15, h * 0.10);
            ctx.bezierCurveTo(w * 0.28, h * 0.06, w * 0.33, h * 0.12, w * 0.32, h * 0.20);
            ctx.bezierCurveTo(w * 0.31, h * 0.28, w * 0.28, h * 0.33, w * 0.22, h * 0.36);
            ctx.bezierCurveTo(w * 0.18, h * 0.35, w * 0.14, h * 0.30, w * 0.12, h * 0.22);
            ctx.bezierCurveTo(w * 0.13, h * 0.15, w * 0.15, h * 0.10, w * 0.15, h * 0.10);
            ctx.fill();

            // Add forest detail to North America
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 2500; i++) {
                const x = w * (0.12 + Math.random() * 0.21);
                const y = h * (0.10 + Math.random() * 0.26);
                const size = Math.random() * 2 + 0.3;
                const intensity = Math.random() * 0.35 + 0.1;
                ctx.fillStyle = `rgba(5, 150, 105, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // SOUTH AMERICA - with rainforest detail
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            const saGradient = ctx.createRadialGradient(w * 0.23, h * 0.53, 0, w * 0.23, h * 0.53, w * 0.12);
            saGradient.addColorStop(0, '#34d399');
            saGradient.addColorStop(0.4, '#10b981');
            saGradient.addColorStop(0.8, '#059669');
            saGradient.addColorStop(1, '#047857');
            ctx.fillStyle = saGradient;
            
            ctx.beginPath();
            ctx.moveTo(w * 0.22, h * 0.38);
            ctx.bezierCurveTo(w * 0.28, h * 0.40, w * 0.29, h * 0.48, w * 0.27, h * 0.56);
            ctx.bezierCurveTo(w * 0.25, h * 0.64, w * 0.22, h * 0.68, w * 0.20, h * 0.66);
            ctx.bezierCurveTo(w * 0.18, h * 0.60, w * 0.19, h * 0.50, w * 0.20, h * 0.42);
            ctx.bezierCurveTo(w * 0.21, h * 0.38, w * 0.22, h * 0.38, w * 0.22, h * 0.38);
            ctx.fill();

            // Add Amazon rainforest particles
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 1500; i++) {
                const x = w * (0.18 + Math.random() * 0.11);
                const y = h * (0.38 + Math.random() * 0.30);
                const size = Math.random() * 1.5 + 0.2;
                const intensity = Math.random() * 0.4 + 0.1;
                ctx.fillStyle = `rgba(16, 185, 129, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // AUSTRALIA - with desert and coastal detail
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            const ausGradient = ctx.createRadialGradient(w * 0.82, h * 0.68, 0, w * 0.82, h * 0.68, w * 0.06);
            ausGradient.addColorStop(0, '#fbbf24');
            ausGradient.addColorStop(0.5, '#f59e0b');
            ausGradient.addColorStop(0.8, '#d97706');
            ausGradient.addColorStop(1, '#16a34a');
            ctx.fillStyle = ausGradient;
            ctx.beginPath();
            ctx.ellipse(w * 0.82, h * 0.68, w * 0.055, h * 0.035, 0, 0, Math.PI * 2);
            ctx.fill();

            // Add desert texture to Australia
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 800; i++) {
                const x = w * (0.77 + Math.random() * 0.10);
                const y = h * (0.65 + Math.random() * 0.06);
                const size = Math.random() * 1.5 + 0.2;
                const intensity = Math.random() * 0.3 + 0.1;
                ctx.fillStyle = `rgba(217, 119, 6, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Add sophisticated cloud system like the sun's particle system
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            // Thousands of cloud particles for realism
            for(let i = 0; i < 5000; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 4 + 0.5;
                const intensity = Math.random() * 0.15 + 0.05;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Larger cloud formations
            ctx.globalCompositeOperation = 'lighter';
            for(let i = 0; i < 800; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 15 + 5;
                const intensity = Math.random() * 0.2 + 0.05;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Hurricane spiral systems with mathematical precision
            const drawAdvancedSpiral = (centerX, centerY, radius, intensity, arms = 3) => {
                ctx.globalCompositeOperation = 'screen';
                for(let arm = 0; arm < arms; arm++) {
                    ctx.beginPath();
                    for(let angle = 0; angle < Math.PI * 8; angle += 0.05) {
                        const r = (angle / (Math.PI * 8)) * radius;
                        const spiralAngle = angle + (arm * Math.PI * 2 / arms);
                        const x = centerX + Math.cos(spiralAngle) * r;
                        const y = centerY + Math.sin(spiralAngle) * r;
                        
                        if(angle === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.strokeStyle = `rgba(255, 255, 255, ${intensity})`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            };
            
            drawAdvancedSpiral(w * 0.35, h * 0.35, w * 0.04, 0.3, 4); // Atlantic hurricane
            drawAdvancedSpiral(w * 0.85, h * 0.40, w * 0.035, 0.25, 3); // Pacific typhoon
            ctx.restore();

            // Professional polar ice caps with advanced layering
            ctx.save();
            
            // Arctic ice cap with multiple layers like the sun
            ctx.globalCompositeOperation = 'source-over';
            const arcticGradient = ctx.createRadialGradient(w * 0.5, h * 0.05, 0, w * 0.5, h * 0.05, w * 0.3);
            arcticGradient.addColorStop(0, '#ffffff');
            arcticGradient.addColorStop(0.3, '#f8fafc');
            arcticGradient.addColorStop(0.6, '#f1f5f9');
            arcticGradient.addColorStop(0.8, '#e2e8f0');
            arcticGradient.addColorStop(1, '#cbd5e1');
            ctx.fillStyle = arcticGradient;
            
            ctx.beginPath();
            ctx.moveTo(w * 0.25, 0);
            ctx.bezierCurveTo(w * 0.4, h * 0.02, w * 0.6, h * 0.02, w * 0.75, 0);
            ctx.bezierCurveTo(w * 0.8, h * 0.04, w * 0.78, h * 0.08, w * 0.72, h * 0.10);
            ctx.bezierCurveTo(w * 0.5, h * 0.12, w * 0.3, h * 0.10, w * 0.22, h * 0.08);
            ctx.bezierCurveTo(w * 0.2, h * 0.04, w * 0.25, 0, w * 0.25, 0);
            ctx.fill();

            // Add thousands of ice crystals
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 3000; i++) {
                const x = w * (0.2 + Math.random() * 0.6);
                const y = h * (0 + Math.random() * 0.12);
                const size = Math.random() * 2 + 0.2;
                const intensity = Math.random() * 0.4 + 0.1;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Antarctic ice cap with similar advanced treatment
            ctx.globalCompositeOperation = 'source-over';
            const antarcticGradient = ctx.createRadialGradient(w * 0.5, h * 0.9, 0, w * 0.5, h * 0.9, w * 0.35);
            antarcticGradient.addColorStop(0, '#ffffff');
            antarcticGradient.addColorStop(0.4, '#f8fafc');
            antarcticGradient.addColorStop(0.7, '#f1f5f9');
            antarcticGradient.addColorStop(0.9, '#e2e8f0');
            antarcticGradient.addColorStop(1, '#cbd5e1');
            ctx.fillStyle = antarcticGradient;
            
            ctx.beginPath();
            ctx.moveTo(w * 0.15, h);
            ctx.bezierCurveTo(w * 0.3, h * 0.95, w * 0.7, h * 0.95, w * 0.85, h);
            ctx.bezierCurveTo(w * 0.88, h * 0.88, w * 0.82, h * 0.84, w * 0.75, h * 0.83);
            ctx.bezierCurveTo(w * 0.5, h * 0.82, w * 0.25, h * 0.83, w * 0.18, h * 0.84);
            ctx.bezierCurveTo(w * 0.12, h * 0.88, w * 0.15, h, w * 0.15, h);
            ctx.fill();

            // Add Antarctic ice crystals
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 4000; i++) {
                const x = w * (0.15 + Math.random() * 0.7);
                const y = h * (0.82 + Math.random() * 0.18);
                const size = Math.random() * 2.5 + 0.3;
                const intensity = Math.random() * 0.5 + 0.1;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();

            // Add atmospheric glow effect like the sun's outer glow
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            const atmosphereGradient = ctx.createRadialGradient(w/2, h/2, Math.min(w, h) * 0.35, w/2, h/2, Math.min(w, h) * 0.5);
            atmosphereGradient.addColorStop(0, 'rgba(135, 206, 235, 0)');
            atmosphereGradient.addColorStop(0.7, 'rgba(135, 206, 235, 0.1)');
            atmosphereGradient.addColorStop(0.9, 'rgba(135, 206, 235, 0.2)');
            atmosphereGradient.addColorStop(1, 'rgba(135, 206, 235, 0.4)');
            ctx.fillStyle = atmosphereGradient;
            ctx.fillRect(0, 0, w, h);
            ctx.restore();
        }

        // Moon/Rocky texture
        function drawRocky(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#5a5a5a');
            grad.addColorStop(0.5, '#a8a8a8');
            grad.addColorStop(1, '#6a6a6a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for (let i = 0; i < 250; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const r = Math.random() * 10 + 2;
                
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 0, 0, ${0.2 + Math.random() * 0.35})`;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(x - r/3, y - r/3, r / 2.2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 200, 200, ${0.15 + Math.random() * 0.25})`;
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(230, 230, 230, ${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 40 + Math.random() * 120, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Green planet texture (for Education)
        function drawGreen(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#0d3a1a');
            grad.addColorStop(0.15, '#1d6b2f');
            grad.addColorStop(0.3, '#2d8c42');
            grad.addColorStop(0.5, '#4db85a');
            grad.addColorStop(0.7, '#2d8c42');
            grad.addColorStop(0.85, '#1d6b2f');
            grad.addColorStop(1, '#0d3a1a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Vegetation/forest patterns
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.2 + 0.05})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 50 + Math.random() * 150, 0, Math.PI * 2);
                ctx.fill();
            }

            // Lighter vegetation highlights
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(100, 200, 100, ${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 20 + Math.random() * 60, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Light Green Yellow planet texture
        function drawLightGreenYellow(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#eaff80');
            grad.addColorStop(0.5, '#f7ffcc');
            grad.addColorStop(1, '#eaff80');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 15; i++) {
                const y = (i / 15) * h;
                ctx.fillStyle = `rgba(180, 200, 100, ${Math.random() * 0.1 + 0.02})`;
                ctx.fillRect(0, y, w, Math.random() * 20 + 10);
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(255, 255, 220, ${Math.random() * 0.2})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, Math.random() * 20 + 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Yellow moon texture - Brighter
        function drawYellow(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#7a5a2a');
            grad.addColorStop(0.15, '#c4a850');
            grad.addColorStop(0.3, '#e8d966');
            grad.addColorStop(0.5, '#ffeb99');
            grad.addColorStop(0.7, '#e8d966');
            grad.addColorStop(0.85, '#c4a850');
            grad.addColorStop(1, '#7a5a2a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for (let i = 0; i < 80; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const r = Math.random() * 8 + 2;
                
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 0, 0, ${0.1 + Math.random() * 0.15})`;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(x - r/3, y - r/3, r / 2.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 200, ${0.15 + Math.random() * 0.2})`;
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 60; i++) {
                ctx.fillStyle = `rgba(255, 255, 220, ${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 30 + Math.random() * 80, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Teal moon texture - Brighter
        function drawTeal(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#3a5a7a');
            grad.addColorStop(0.15, '#5a8aaa');
            grad.addColorStop(0.3, '#7abacc');
            grad.addColorStop(0.5, '#99ddff');
            grad.addColorStop(0.7, '#7abacc');
            grad.addColorStop(0.85, '#5a8aaa');
            grad.addColorStop(1, '#3a5a7a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(0, 0, 0, ${0.15 + Math.random() * 0.2})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 60 + Math.random() * 120, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 70; i++) {
                ctx.fillStyle = `rgba(220, 255, 255, ${Math.random() * 0.15})`;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 25 + Math.random() * 100, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Blue Education planet texture - BRIGHTER
        function drawBlue(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#2a4a8a'); // Much brighter starting blue
            grad.addColorStop(0.15, '#4a7acc'); // Brighter
            grad.addColorStop(0.3, '#5a9aff'); // Bright blue
            grad.addColorStop(0.5, '#6abaff'); // Even brighter
            grad.addColorStop(0.7, '#5a9aff');
            grad.addColorStop(0.85, '#4a7acc');
            grad.addColorStop(1, '#2a4a8a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Water/ocean patterns - lighter
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1 + 0.02})`; // Reduced darkness
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 50 + Math.random() * 150, 0, Math.PI * 2);
                ctx.fill();
            }

            // Cloud highlights - brighter
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(180, 220, 255, ${Math.random() * 0.25})`; // Brighter clouds
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 20 + Math.random() * 60, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Moon surface textures - showing what each moon represents
        function drawEmailSurface(ctx, w, h) {
            // Email represented as an envelope/message surface
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#2a2a3a');
            grad.addColorStop(0.5, '#4a5a7a');
            grad.addColorStop(1, '#2a2a3a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Envelope pattern
            ctx.globalCompositeOperation = 'overlay';
            ctx.strokeStyle = 'rgba(255, 200, 100, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(w, 0);
            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.lineTo(0, 0);
            ctx.stroke();

            // Email lines
            for(let i = 1; i < 6; i++) {
                ctx.strokeStyle = `rgba(200, 200, 255, ${0.3 - i*0.05})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(10, h * (i / 6));
                ctx.lineTo(w - 10, h * (i / 6));
                ctx.stroke();
            }

            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 200, 0.2)';
            ctx.fillRect(w * 0.2, h * 0.2, w * 0.6, h * 0.3);
        }

        function drawPhoneSurface(ctx, w, h) {
            // Phone represented as a display/screen surface
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#1a1a2a');
            grad.addColorStop(0.5, '#3a4a5a');
            grad.addColorStop(1, '#1a1a2a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Phone screen with grid pattern
            ctx.globalCompositeOperation = 'overlay';
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
            ctx.lineWidth = 1;
            for(let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.moveTo((w / 10) * i, 0);
                ctx.lineTo((w / 10) * i, h);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, (h / 10) * i);
                ctx.lineTo(w, (h / 10) * i);
                ctx.stroke();
            }

            // Glowing dots
            ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
            for(let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * w * 0.8 + w * 0.1, Math.random() * h * 0.8 + h * 0.1, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawLocationSurface(ctx, w, h) {
            // Location represented as a map/coordinates surface
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#1a3a2a');
            grad.addColorStop(0.5, '#3a6a5a');
            grad.addColorStop(1, '#1a3a2a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Map grid
            ctx.globalCompositeOperation = 'overlay';
            ctx.strokeStyle = 'rgba(100, 255, 150, 0.3)';
            ctx.lineWidth = 1;
            for(let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo((w / 8) * i, 0);
                ctx.lineTo((w / 8) * i, h);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, (h / 8) * i);
                ctx.lineTo(w, (h / 8) * i);
                ctx.stroke();
            }

            // Location pin
            ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.4, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(255, 200, 100, 0.8)';
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.4, 8, 0, Math.PI * 2);
            ctx.fill();

            // Coordinate lines
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, h * 0.4);
            ctx.lineTo(w, h * 0.4);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(w * 0.5, 0);
            ctx.lineTo(w * 0.5, h);
            ctx.stroke();
            ctx.setLineDash([]);
        }


        function drawMercury(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#696969');
            grad.addColorStop(0.5, '#808080');
            grad.addColorStop(1, '#505050');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalCompositeOperation = 'multiply';
            for (let i = 0; i < 300; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const r = Math.random() * 15 + 2;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.2})`;
                ctx.fill();
            }
        }

        // White texture (English)
        function drawWhite(ctx, w, h) {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, w, h);
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = 'rgba(200,200,255,0.1)';
            ctx.fillRect(0,0,w,h);
        }

        // Orange texture (Hindi)
        function drawOrange(ctx, w, h) {
            ctx.fillStyle = '#ff9900';
            ctx.fillRect(0, 0, w, h);
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = 'rgba(255,200,100,0.2)';
            for(let i=0; i<50; i++) {
                ctx.beginPath();
                ctx.arc(Math.random()*w, Math.random()*h, Math.random()*20, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // Green and Orange texture (Gujarati)
        function drawGreenOrange(ctx, w, h) {
            ctx.fillStyle = '#2ecc71'; // Green base
            ctx.fillRect(0, 0, w, h);
            
            ctx.fillStyle = '#ff9900'; // Orange patches
            for(let i=0; i<40; i++) {
                ctx.beginPath();
                ctx.arc(Math.random()*w, Math.random()*h, 30 + Math.random()*50, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // Bluish Green texture (Marathi)
        function drawBluishGreen(ctx, w, h) {
            const grad = ctx.createLinearGradient(0, 0, w, h);
            grad.addColorStop(0, '#1abc9c');
            grad.addColorStop(1, '#16a085');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);
        }

        // Texture map for dynamic loading
        const textureMap = {
            "drawRed": drawRed,
            "drawVenus": drawVenus,
            "drawJupiter": drawJupiter,
            "drawBlue": drawBlue,
            "drawLightGreenYellow": drawLightGreenYellow,
            "drawEarth": drawEarth,
            "drawGreen": drawGreen,
            "drawTeal": drawTeal,
            "drawYellow": drawYellow,
            "drawUranus": drawUranus,
            "drawSaturn": drawSaturn,
            "drawMars": drawMars
        };

        // === HELPER FUNCTIONS (MUST BE BEFORE USE) ===
        function createLabel(text, object, isMajor = false) {
            const div = document.createElement('div');
            div.className = isMajor ? 'label major' : 'label';
            div.innerHTML = text;
            div.onclick = (e) => {
                e.stopPropagation();
                focusOnObject(object);
            };
            document.getElementById('ui-layer').appendChild(div);
            labels.push({ div, object });
        }

        // === AUDIO SETUP ===
        function playSound(type) {
            if (!soundEnabled) return;
            const ctx = backgroundAudio ? backgroundAudio.audioContext : new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);

            if (type === 'laser') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.start();
                osc.stop(ctx.currentTime + 0.1);
            } else if (type === 'comet') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.05, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
                osc.start();
                osc.stop(ctx.currentTime + 0.5);
            }
        }

        function initAudio() {
            // tear down any previous audio nodes safely
            if (backgroundAudio) {
                try { backgroundAudio.oscillator.stop(); } catch(e){}
                try { backgroundAudio.oscillator.disconnect(); } catch(e){}
                try { backgroundAudio.gainNode.disconnect(); } catch(e){}
            }

            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // vary tone a little for texture, start muted
            oscillator.frequency.setValueAtTime(220 + Math.random() * 220, audioContext.currentTime);
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);

            try { oscillator.start(); } catch(e){ /* already started */ }

            backgroundAudio = { oscillator, gainNode, audioContext };
        }

        window.toggleSound = () => {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('sound-btn');
            const movieBtn = document.getElementById('nur-wars-sound-btn');

            if (soundEnabled) {
                btn.textContent = 'üîä Sound On';
                if (movieBtn) movieBtn.textContent = 'üîä';
                // Only resume background audio if NOT in NUR WARS movie
                if (!nurWarsActive && backgroundAudio) {
                    if (!backgroundAudio) initAudio();
                    // must resume audio context on user gesture and ramp gain
                    const ctx = backgroundAudio.audioContext;
                    ctx.resume().then(() => {
                        const now = ctx.currentTime;
                        try {
                            backgroundAudio.gainNode.gain.cancelScheduledValues(now);
                            backgroundAudio.gainNode.gain.setValueAtTime(backgroundAudio.gainNode.gain.value || 0, now);
                            backgroundAudio.gainNode.gain.linearRampToValueAtTime(0.01, now + 0.5);
                        } catch(e) { backgroundAudio.gainNode.gain.value = 0.01; }
                    }).catch(()=>{ /* ignore resume errors */ });
                }
                // Resume movie audio if playing
                if (currentAudio && currentAudio.paused && nurWarsActive && !moviePaused) {
                    currentAudio.play().catch(() => {});
                }
            } else {
                btn.textContent = 'üîá Sound Off';
                if (movieBtn) movieBtn.textContent = 'üîá';
                if (backgroundAudio) {
                    const now = backgroundAudio.audioContext.currentTime;
                    try {
                        backgroundAudio.gainNode.gain.cancelScheduledValues(now);
                        backgroundAudio.gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
                    } catch(e) { backgroundAudio.gainNode.gain.value = 0; }
                }
                // Pause movie audio if playing
                if (currentAudio && !currentAudio.paused) {
                    currentAudio.pause();
                }
            }
        };

        function updatePlayPauseButton() {
            const btn = document.getElementById('audio-play-btn');
            if (!btn) return;
            if (!currentAudio) {
                btn.textContent = '‚èØÔ∏è Play';
                return;
            }
            btn.textContent = currentAudio.paused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pause';
        }

        window.togglePlayPause = () => {
            if (!currentAudio) {
                updatePlayPauseButton();
                return;
            }

            if (currentAudio.paused) {
                if (!soundEnabled) {
                    window.toggleSound();
                }
                currentAudio.play().then(() => {
                    updatePlayPauseButton();
                }).catch(() => {
                    updatePlayPauseButton();
                });
            } else {
                currentAudio.pause();
                updatePlayPauseButton();
            }
        };

        window.skipAudio = (seconds) => {
            if (!currentAudio || Number.isNaN(currentAudio.currentTime)) return;
            const duration = Number.isFinite(currentAudio.duration) ? currentAudio.duration : null;
            const newTime = currentAudio.currentTime + seconds;
            if (duration !== null && duration > 0) {
                currentAudio.currentTime = Math.min(Math.max(newTime, 0), Math.max(duration - 0.1, 0));
            } else {
                currentAudio.currentTime = Math.max(newTime, 0);
            }
        };

        // Function to update moon orbit visibility based on focused planet
        function updateMoonOrbitVisibility() {
            moonOrbitPaths.forEach(moonOrbitData => {
                const shouldShowMoonOrbit = orbitsVisible && focusedObject && 
                    focusedObject.userData.isPlanet && 
                    moonOrbitData.parentPlanet === focusedObject;
                moonOrbitData.path.visible = shouldShowMoonOrbit;
            });
        }

        window.toggleOrbits = () => {
            orbitsVisible = !orbitsVisible;
            const btn = document.getElementById('orbits-btn');
            btn.textContent = orbitsVisible ? 'ü™ê Hide Orbits' : 'ü™ê Show Orbits';
            
            // Toggle planet orbits (always visible when orbits are on)
            orbitPaths.forEach(path => {
                path.visible = orbitsVisible;
            });
            
            // Toggle moon orbits (only visible when orbits are on AND a planet is focused)
            moonOrbitPaths.forEach(moonOrbitData => {
                const shouldShowMoonOrbit = orbitsVisible && focusedObject && 
                    focusedObject.userData.isPlanet && 
                    moonOrbitData.parentPlanet === focusedObject;
                moonOrbitData.path.visible = shouldShowMoonOrbit;
            });
        };

        // === PDF GENERATION ===
        window.generatePDF = async (theme) => {
            const modal = document.getElementById('pdf-modal');
            const originalText = modal.innerHTML;
            modal.innerHTML = '<div style="color:white;text-align:center">Generating PDF...<br>Please wait.</div>';
            
            // Allow UI to update
            await new Promise(r => setTimeout(r, 100));
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const PAGE_WIDTH = doc.internal.pageSize.getWidth();
            const PAGE_HEIGHT = doc.internal.pageSize.getHeight();
            const margin = 25;
            const contentWidth = PAGE_WIDTH - (margin * 2);
            
            // Helper to strip emojis and non-standard chars to prevent junk characters
            const safeText = (text) => {
                if (!text) return "";
                // Remove common emoji ranges and symbols that might break standard PDF fonts
                return text.replace(/[\u{1F600}-\u{1F6FF}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F900}-\u{1F9FF}\u{1F004}\u{1F0CF}\u{1F170}-\u{1F251}\u{1F000}-\u{1F02F}]/gu, '')
                           .replace(/[^\x00-\x7F\u0080-\u00FF\u2010-\u2015\u2022]/g, " ") // Keep basic latin, accents, dashes, bullets
                           .replace(/\s+/g, ' ')
                           .trim();
            };

            // Load Profile Image safely
            let profileImg = null;
            try {
                profileImg = await new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => resolve(img);
                    img.onerror = () => {
                        console.warn("Profile image failed to load (likely CORS). Continuing without it.");
                        resolve(null);
                    };
                    img.src = 'assets/images/Profile.jpg';
                });
            } catch (e) {
                console.warn("Image load error", e);
            }

            // Theme Config
            const isSpace = theme === 'space';
            const colors = isSpace ? {
                bg: [5, 5, 12], // Deep Space
                text: [240, 240, 255],
                accent: [56, 189, 248], // Cyan
                secondary: [148, 163, 184],
                line: [30, 41, 59]
            } : {
                bg: [255, 255, 255],
                text: [40, 40, 40],
                accent: [41, 128, 185], // Professional Blue
                secondary: [80, 80, 80],
                line: [200, 200, 200]
            };

            const titles = isSpace ? {
                summary: "MISSION OBJECTIVE & PROFILE",
                experience: "FLIGHT LOG & MISSION HISTORY",
                skills: "OPERATIONAL SUBSYSTEMS",
                projects: "DEPLOYED MISSION PAYLOADS",
                education: "ACADEMIC & TRAINING DATA"
            } : {
                summary: "SUMMARY",
                experience: "PROFESSIONAL EXPERIENCE",
                skills: "SKILLS & COMPETENCIES",
                projects: "KEY PROJECTS",
                education: "EDUCATION"
            };

            // Helper to draw background
            const drawBackground = () => {
                doc.setFillColor(...colors.bg);
                doc.rect(0, 0, PAGE_WIDTH, PAGE_HEIGHT, 'F');

                // Page Border
                doc.setDrawColor(...colors.line);
                doc.setLineWidth(0.5);
                doc.rect(15, 15, PAGE_WIDTH - 30, PAGE_HEIGHT - 30, 'S');

                if (isSpace) {
                    // Stars
                    for (let i = 0; i < 150; i++) {
                        const x = Math.random() * PAGE_WIDTH;
                        const y = Math.random() * PAGE_HEIGHT;
                        const r = Math.random() * 0.3 + 0.1;
                        const brightness = Math.floor(Math.random() * 100) + 155;
                        doc.setFillColor(brightness, brightness, brightness);
                        doc.circle(x, y, r, 'F');
                    }

                    // Webb Spikes (Bright Stars)
                    for (let i = 0; i < 6; i++) {
                        const x = Math.random() * PAGE_WIDTH;
                        const y = Math.random() * PAGE_HEIGHT;
                        doc.setDrawColor(255, 255, 255);
                        doc.setLineWidth(0.1);
                        const size = 2 + Math.random() * 2;
                        doc.line(x - size, y, x + size, y);
                        doc.line(x, y - size, x, y + size);
                        doc.line(x - size*0.7, y - size*0.7, x + size*0.7, y + size*0.7);
                        doc.line(x - size*0.7, y + size*0.7, x + size*0.7, y - size*0.7);
                    }
                    
                    // Nebulae
                    const nebulaColors = [[255, 100, 100], [100, 200, 255], [200, 100, 255]];
                    for (let n = 0; n < 3; n++) {
                        const cx = Math.random() * PAGE_WIDTH;
                        const cy = Math.random() * PAGE_HEIGHT;
                        const color = nebulaColors[Math.floor(Math.random() * nebulaColors.length)];
                        doc.setFillColor(...color);
                        for (let p = 0; p < 40; p++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * 30 * Math.random();
                            const px = cx + Math.cos(angle) * dist;
                            const py = cy + Math.sin(angle) * dist;
                            if (px > 0 && px < PAGE_WIDTH && py > 0 && py < PAGE_HEIGHT) {
                                doc.circle(px, py, Math.random() * 0.5, 'F');
                            }
                        }
                    }
                }
            };

            // Initial Background
            drawBackground();

            let y = margin;

            // === HEADER ===
            // Image
            let headerTextWidth = contentWidth;
            if (profileImg) {
                const imgSize = 30;
                const imgX = PAGE_WIDTH - margin - imgSize;
                headerTextWidth = contentWidth - imgSize - 5;
                try {
                    doc.addImage(profileImg, 'JPEG', imgX, y, imgSize, imgSize);
                    doc.setDrawColor(...colors.accent);
                    doc.setLineWidth(0.5);
                    doc.rect(imgX, y, imgSize, imgSize);
                } catch (e) {
                    console.warn("Could not add image to PDF (likely tainted canvas)", e);
                }
            }

            // Name & Role
            doc.setFont(isSpace ? "courier" : "helvetica", "bold");
            doc.setFontSize(24);
            doc.setTextColor(...colors.accent);
            
            const nameLines = doc.splitTextToSize(safeText(RESUME_DATA.name).toUpperCase(), headerTextWidth);
            doc.text(nameLines, margin, y + 8);
            const nameHeight = nameLines.length * 8;
            
            doc.setFont(isSpace ? "courier" : "helvetica", "normal");
            doc.setFontSize(12);
            doc.setTextColor(...colors.text);
            const roleLines = doc.splitTextToSize(safeText(RESUME_DATA.role), headerTextWidth);
            doc.text(roleLines, margin, y + 8 + nameHeight);

            // Contact Info
            y += 25;
            doc.setFontSize(9);
            doc.setTextColor(...colors.secondary);
            
            const c = RESUME_DATA.contact;
            const contactItems = [
                c.email ? `EMAIL: ${c.email}` : null,
                c.phone ? `PHONE: ${c.phone}` : null,
                c.location ? `LOC: ${c.location}` : null,
                c.website ? `WEB: ${c.website}` : null,
                c.linkedin ? `IN: ${c.linkedin.replace(/^https?:\/\//, '')}` : null
            ].filter(Boolean);

            doc.text(contactItems.join("   |   "), margin, y);

            y += 5;
            doc.setDrawColor(...colors.line);
            doc.setLineWidth(0.5);
            doc.line(margin, y, PAGE_WIDTH - margin, y);
            y += 8;

            // === SUMMARY ===
            if (RESUME_DATA.pdfSummary || RESUME_DATA.summary) {
                doc.setFont(isSpace ? "courier" : "helvetica", "bold");
                doc.setFontSize(11);
                doc.setTextColor(...colors.accent);
                doc.text(titles.summary, margin, y);
                y += 5;
                
                doc.setFont(isSpace ? "courier" : "helvetica", "normal");
                doc.setFontSize(10);
                doc.setTextColor(...colors.text);
                const summaryText = safeText(isSpace ? (RESUME_DATA.spaceSummary || RESUME_DATA.pdfSummary) : (RESUME_DATA.pdfSummary || RESUME_DATA.summary));
                const splitSummary = doc.splitTextToSize(summaryText, contentWidth);
                doc.text(splitSummary, margin, y);
                y += splitSummary.length * 4.5 + 5;
            }

            // === SECTIONS ===
            const checkPageBreak = (currentY, needed) => {
                if (currentY + needed > PAGE_HEIGHT - margin) {
                    doc.addPage();
                    drawBackground();
                    return margin;
                }
                return currentY;
            };

            const renderSectionTitle = (title, currentY) => {
                currentY = checkPageBreak(currentY, 15);
                doc.setFont(isSpace ? "courier" : "helvetica", "bold");
                doc.setFontSize(12);
                doc.setTextColor(...colors.accent);
                
                if (!isSpace) {
                    doc.setFillColor(240, 240, 240);
                    doc.rect(margin, currentY - 4, contentWidth, 6, 'F');
                }
                
                doc.text(title.toUpperCase(), margin, currentY);
                return currentY + 8;
            };
            
            // EXPERIENCE
            const expPlanet = RESUME_DATA.planets.find(p => p.name === "Experience");
            if (expPlanet && expPlanet.moons) {
                y = renderSectionTitle(titles.experience, y);
                
                expPlanet.moons.forEach(job => {
                    const details = isSpace ? (job.spaceDetails || job.pdfDetails || job.moonDetails || {}) : (job.pdfDetails || job.moonDetails || {});
                    const company = safeText(details.company || job.name);
                    const role = safeText(details.role || "");
                    const duration = safeText(details.duration || "");
                    const location = safeText(details.location || "");

                    y = checkPageBreak(y, 15);

                    // Line 1: Company (Left) | Location (Right)
                    doc.setFont(isSpace ? "courier" : "helvetica", "bold");
                    doc.setFontSize(11);
                    doc.setTextColor(...colors.text);
                    doc.text(company, margin, y);
                    
                    doc.setFontSize(9);
                    doc.setTextColor(...colors.secondary);
                    doc.text(location, PAGE_WIDTH - margin, y, { align: "right" });
                    
                    y += 5;

                    // Line 2: Role (Left) | Duration (Right)
                    doc.setFont(isSpace ? "courier" : "helvetica", "italic");
                    doc.setFontSize(10);
                    doc.setTextColor(...colors.text);
                    doc.text(role, margin, y);

                    doc.setFont(isSpace ? "courier" : "helvetica", "normal");
                    doc.setFontSize(9);
                    doc.setTextColor(...colors.secondary);
                    doc.text(duration, PAGE_WIDTH - margin, y, { align: "right" });
                    
                    y += 6;

                    // Achievements / Responsibilities
                    doc.setFontSize(10);
                    doc.setTextColor(...colors.text);
                    
                    const items = [...(details.achievements || []), ...(details.responsibilities || [])];
                    if (items.length === 0 && job.details) {
                        items.push(...job.details.split('\n').slice(1));
                    } else if (items.length === 0 && details.description) {
                        items.push(details.description);
                    }

                    items.forEach(item => {
                        if (!item) return;
                        const cleanItem = safeText(item.replace(/^‚Ä¢\s*/, ''));
                        if (!cleanItem) return;
                        
                        const bullet = "‚Ä¢";
                        const indent = 5;
                        const textWidth = contentWidth - indent;
                        const splitText = doc.splitTextToSize(cleanItem, textWidth);
                        const blockHeight = splitText.length * 4.5;
                        
                        y = checkPageBreak(y, blockHeight);
                        doc.text(bullet, margin, y);
                        doc.text(splitText, margin + indent, y);
                        y += blockHeight + 1;
                    });
                    y += 4;
                });
            }

            // SKILLS
            const skillsPlanet = RESUME_DATA.planets.find(p => p.name === "Skills");
            if (skillsPlanet) {
                y += 2;
                y = renderSectionTitle(titles.skills, y);
                
                doc.setFontSize(10);
                doc.setTextColor(...colors.text);
                
                if (skillsPlanet.moons) {
                    skillsPlanet.moons.forEach(cat => {
                        const details = isSpace ? (cat.spaceDetails || cat.pdfDetails || cat.moonDetails || {}) : (cat.pdfDetails || cat.moonDetails || {});
                        const catTitle = safeText(details.title || cat.name);
                        
                        y = checkPageBreak(y, 10);
                        doc.setFont(undefined, "bold");
                        doc.text(catTitle, margin, y);
                        y += 5;
                        
                        doc.setFont(undefined, "normal");
                        const skills = details.skills || [];
                        skills.forEach(skill => {
                            const cleanSkill = safeText(skill);
                            const splitSkill = doc.splitTextToSize(cleanSkill, contentWidth - 10);
                            y = checkPageBreak(y, splitSkill.length * 4.5);
                            doc.text("‚Ä¢", margin + 3, y);
                            doc.text(splitSkill, margin + 8, y);
                            y += splitSkill.length * 4.5 + 1;
                        });
                        y += 3;
                    });
                }
                y += 5;
            }

            // PROJECTS
            const projPlanet = RESUME_DATA.planets.find(p => p.name === "Projects");
            if (projPlanet && projPlanet.moons) {
                y = renderSectionTitle(titles.projects, y);
                
                projPlanet.moons.forEach(proj => {
                    const details = isSpace ? (proj.spaceDetails || proj.pdfDetails || proj.moonDetails || {}) : (proj.pdfDetails || proj.moonDetails || {});
                    const title = safeText(details.title || proj.name);
                    const desc = safeText(details.description || "");
                    const impact = details.impact ? details.impact.map(i => safeText(i)).join(". ") : "";
                    
                    y = checkPageBreak(y, 15);
                    doc.setFont(undefined, "bold");
                    doc.text(title, margin, y);
                    
                    doc.setFont(undefined, "normal");
                    const fullText = `${desc} Impact: ${impact}`;
                    const split = doc.splitTextToSize(fullText, contentWidth);
                    
                    y += 4;
                    doc.text(split, margin, y);
                    y += split.length * 4 + 3;
                });
                y += 5;
            }

            // EDUCATION
            const eduPlanet = RESUME_DATA.planets.find(p => p.name === "Education");
            if (eduPlanet) {
                y = renderSectionTitle(titles.education, y);
                const d = isSpace ? (eduPlanet.spaceDetails || eduPlanet.pdfDetails || eduPlanet.details || {}) : (eduPlanet.pdfDetails || eduPlanet.details || {});
                
                y = checkPageBreak(y, 10);
                doc.setFont(undefined, "bold");
                
                const degreeLines = doc.splitTextToSize(safeText(d.degree || ""), contentWidth);
                doc.text(degreeLines, margin, y);
                y += degreeLines.length * 5;
                
                doc.setFont(undefined, "normal");
                const eduInfo = `${safeText(d.institution || "")}, ${safeText(d.location || "")} | ${safeText(d.duration || "")}`;
                const eduLines = doc.splitTextToSize(eduInfo, contentWidth);
                doc.text(eduLines, margin, y);
            }

            // Save
            doc.save(`Nur_Dawoodani_Resume_${theme}.pdf`);
            
            // Reset Modal
            modal.innerHTML = originalText;
            modal.style.display = 'none';
        };

        // Update the sky-details panel to parse structured data
        function landOnMoon(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            const data = moon.userData.moonDetails || moon.userData.details;

            titleEl.textContent = moon.userData.name;
            let html = '';

            if (typeof data === 'object' && data !== null) {
                // Handle different data structures
                if (data.company) {
                    // Experience data
                    html = `<h3>${data.company}</h3>`;
                    html += `<p><em>${data.role} | ${data.duration}</em></p>`;
                    if (data.industry) html += `<p><strong>Industry:</strong> ${data.industry}</p>`;
                    
                    if (data.achievements) {
                        html += `<p><strong>Major Achievements:</strong></p><ul>`;
                        data.achievements.forEach(achievement => {
                            html += `<li>${achievement}</li>`;
                        });
                        html += `</ul>`;
                    }
                    
                    if (data.responsibilities) {
                        html += `<p><strong>Core Responsibilities:</strong></p><ul>`;
                        data.responsibilities.forEach(resp => {
                            html += `<li>${resp}</li>`;
                        });
                        html += `</ul>`;
                    }
                    
                    if (data.products) {
                        html += `<p><strong>Shipped Products:</strong></p><ul>`;
                        data.products.forEach(product => {
                            html += `<li>${product}</li>`;
                        });
                        html += `</ul>`;
                    }
                    
                    if (data.techStack) {
                        html += `<p><strong>Tech Stack:</strong></p><ul>`;
                        data.techStack.forEach(tech => {
                            html += `<li>${tech}</li>`;
                        });
                        html += `</ul>`;
                    }
                } else if (data.title && data.skills) {
                    // Skills data
                    html = `<h3>${data.title}</h3><ul>`;
                    data.skills.forEach(skill => {
                        html += `<li>${skill}</li>`;
                    });
                    html += `</ul>`;
                } else if (data.title && data.impact) {
                    // Project data
                    html = `<h3>${data.title}</h3>`;
                    if (data.subtitle) html += `<p><strong>${data.subtitle}</strong></p>`;
                    if (data.description) html += `<p>${data.description}</p>`;
                    html += `<p><strong>Impact:</strong></p><ul>`;
                    data.impact.forEach(item => {
                        html += `<li>${item}</li>`;
                    });
                    html += `</ul>`;
                } else if (data.degree) {
                    // Education data
                    html = `<h3>EDUCATION</h3>`;
                    html += `<p><strong>${data.degree}</strong><br>${data.field}</p>`;
                    html += `<p><strong>${data.institution}</strong><br>${data.duration}</p>`;
                } else if (data.method) {
                    // Contact data
                    html = `<h3>${data.method}</h3>`;
                    if (data.link) {
                        html += `<p><a href="${data.link}" style="color:#38bdf8">${data.value}</a></p>`;
                    } else {
                        html += `<p>${data.value}</p>`;
                    }
                }
            } else {
                // Fallback for string data
                html = `<p>${data || "No details available."}</p>`;
            }

            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        function scaleModelToRadius(model, targetRadius) {
            const initialBox = new THREE.Box3().setFromObject(model);
            const initialSize = new THREE.Vector3();
            initialBox.getSize(initialSize);
            const maxDim = Math.max(initialSize.x, initialSize.y, initialSize.z) || 1;
            const scale = (targetRadius * 2) / maxDim;
            model.scale.setScalar(scale);

            const scaledBox = new THREE.Box3().setFromObject(model);
            const scaledCenter = new THREE.Vector3();
            scaledBox.getCenter(scaledCenter);
            model.position.sub(scaledCenter);
        }

        function applyModelColorSpace(model) {
            // Do nothing - use models as-is
        }

        // === BRIGHT GLOWING SUN LIKE A FIREBALL ===
        const sunGeo = new THREE.SphereGeometry(85, 256, 256);
        
        // Create a bright, glowing sun texture
        const sunTexture = createCanvasTexture(2048, 2048, (ctx, w, h) => {
            // Bright radial gradient base - much brighter colors
            const centerGrad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w/2);
            centerGrad.addColorStop(0, '#ffffff');    // Pure white center (hottest)
            centerGrad.addColorStop(0.1, '#ffffcc'); // Very bright yellow
            centerGrad.addColorStop(0.3, '#ffff66'); // Bright yellow
            centerGrad.addColorStop(0.5, '#ffcc33'); // Golden yellow
            centerGrad.addColorStop(0.7, '#ff9933'); // Orange
            centerGrad.addColorStop(0.9, '#ff6600'); // Deep orange
            centerGrad.addColorStop(1, '#ff3300');   // Red edge
            ctx.fillStyle = centerGrad;
            ctx.fillRect(0, 0, w, h);
            
            // Add bright plasma effects
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 12000; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 6 + 1;
                const intensity = Math.random() * 0.8 + 0.2;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add bright flares and hot spots
            ctx.globalCompositeOperation = 'lighter';
            for(let i = 0; i < 300; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 30 + 10;
                const intensity = Math.random() * 0.6 + 0.2;
                
                ctx.fillStyle = `rgba(255, 255, 200, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Add some darker spots for contrast (but still bright)
            ctx.globalCompositeOperation = 'multiply';
            for(let i = 0; i < 15; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 25 + 10;
                
                ctx.fillStyle = `rgba(200, 150, 100, ${Math.random() * 0.3 + 0.1})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add super bright core flares
            ctx.globalCompositeOperation = 'screen';
            for(let i = 0; i < 80; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const size = Math.random() * 15 + 3;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.9 + 0.1})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        
        // Bright emissive material that glows like a light bulb
        const sunMat = new THREE.MeshStandardMaterial({ 
            map: sunTexture,
            toneMapped: false,
            fog: false,
            transparent: false,
            emissive: 0xffffff,
            emissiveIntensity: 4.0,
            emissiveMap: sunTexture,
            metalness: 0,
            roughness: 1
        });
        
        const sun = new THREE.Group();
        sun.userData = {
            name: RESUME_DATA.name,
            role: RESUME_DATA.role,
            summary: RESUME_DATA.summary,
            isSun: true
        };
        solarSystem.add(sun);

        const sunPlaceholder = new THREE.Mesh(sunGeo, sunMat);
        sunPlaceholder.castShadow = false;
        sunPlaceholder.receiveShadow = false;
        sun.add(sunPlaceholder);

        solarModelsToLoad++;
        updateSolarLoadingOverlay();
        gltfLoader.load(
            'assets/models/the_star_sun/scene.gltf',
            (gltf) => {
                const sunModel = gltf.scene;
                applyModelColorSpace(sunModel);
                sunModel.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                scaleModelToRadius(sunModel, 85);
                sun.add(sunModel);
                sun.remove(sunPlaceholder);
                solarModelsLoaded++;
                checkSolarModelsReady();
            },
            undefined,
            (error) => {
                console.error('Error loading sun model:', error);
                solarModelsLoaded++;
                checkSolarModelsReady();
            }
        );
        
        // Add realistic sun glow effect
        const sunGlowGeo = new THREE.SphereGeometry(120, 64, 64); // Larger than sun
        const sunGlowMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                glowColor: { value: new THREE.Color(0xffaa33) }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 glowColor;
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                    intensity += sin(time * 2.0) * 0.1; // Pulsing effect
                    gl_FragColor = vec4(glowColor, intensity * 0.4);
                }
            `,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        
        const sunGlow = new THREE.Mesh(sunGlowGeo, sunGlowMat);
        sun.add(sunGlow);
        
        // Store glow material for animation
        sun.userData.glowMaterial = sunGlowMat;
        
        // Make Sun clickable
        clickableObjects.push(sun);

        // Clean bright sun without corona layers - no banding
        // Just the sun itself with enhanced brightness and glow

        // Intense sun lighting like a bright bulb
        const sunCoreLight = new THREE.PointLight(0xffffff, 60, 3500);
        sunCoreLight.position.set(0, 0, 0);
        solarSystem.add(sunCoreLight);

        const sunBrightLight = new THREE.PointLight(0xffffff, 48, 3000);
        sunBrightLight.position.set(0, 0, 0);
        solarSystem.add(sunBrightLight);

        const sunWarmLight = new THREE.PointLight(0xffffff, 36, 2500);
        sunWarmLight.position.set(0, 0, 0);
        solarSystem.add(sunWarmLight);

        const sunAmbientLight = new THREE.PointLight(0xffffff, 18, 2000);
        sunAmbientLight.position.set(0, 0, 0);
        solarSystem.add(sunAmbientLight);

        // Add ambient light for overall scene brightness
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        createLabel("NUR<br><span style='font-size:0.6em; opacity:0.8; color: #38bdf8;'>Business Analyst</span>", sun, true);

        // === IMPROVED STARFIELD WITH CIRCULAR STARS ===
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 10000;
        const starPositions = new Float32Array(starsCount * 3);
        const starColors = new Float32Array(starsCount * 3);
        const starSizes = new Float32Array(starsCount);

        const starColorChoices = [
            new THREE.Color(0xffffff),   // white
            new THREE.Color(0xffffcc),   // yellow
            new THREE.Color(0xccccff),   // blue
            new THREE.Color(0xffcccc),   // red
            new THREE.Color(0xccffcc),   // green
            new THREE.Color(0xffccdd),   // pink
            new THREE.Color(0xccffff),   // cyan
            new THREE.Color(0xffffaa)    // pale yellow
        ];

        for(let i = 0; i < starsCount; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 4000;
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 4000;
            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 4000;

            const col = starColorChoices[Math.floor(Math.random() * starColorChoices.length)];
            starColors[i * 3] = col.r;
            starColors[i * 3 + 1] = col.g;
            starColors[i * 3 + 2] = col.b;

            starSizes[i] = Math.random() * 2.5 + 0.8;
        }

        starsGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starsGeo.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        starsGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

        const starsMat = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.9,
            fog: false,
            alphaTest: 0.5
        });

        const starTexture = new THREE.CanvasTexture((() => {
            const cvs = document.createElement('canvas');
            cvs.width = 64;
            cvs.height = 64;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(32, 32, 20, 0, Math.PI * 2);
            ctx.fill();
            return cvs;
        })());

        starsMat.map = starTexture;
        const starMesh = new THREE.Points(starsGeo, starsMat);
        starMesh.layers.set(0);
        scene.add(starMesh);

        // === ADDITIONAL STARFIELD FOR NUR WARS CRAWL AREA ===
        // Create stars in upper region where camera pans for opening crawl
        const upperStarsGeo = new THREE.BufferGeometry();
        const upperStarsCount = 8000;
        const upperStarPositions = new Float32Array(upperStarsCount * 3);
        const upperStarColors = new Float32Array(upperStarsCount * 3);
        const upperStarSizes = new Float32Array(upperStarsCount);

        for(let i = 0; i < upperStarsCount; i++) {
            // Position stars in upper region (Y: 10000 to 20000)
            upperStarPositions[i * 3] = (Math.random() - 0.5) * 8000;
            upperStarPositions[i * 3 + 1] = Math.random() * 10000 + 10000; // Y between 10000-20000
            upperStarPositions[i * 3 + 2] = (Math.random() - 0.5) * 8000;

            const col = starColorChoices[Math.floor(Math.random() * starColorChoices.length)];
            upperStarColors[i * 3] = col.r;
            upperStarColors[i * 3 + 1] = col.g;
            upperStarColors[i * 3 + 2] = col.b;

            upperStarSizes[i] = Math.random() * 2.5 + 0.8;
        }

        upperStarsGeo.setAttribute('position', new THREE.BufferAttribute(upperStarPositions, 3));
        upperStarsGeo.setAttribute('color', new THREE.BufferAttribute(upperStarColors, 3));
        upperStarsGeo.setAttribute('size', new THREE.BufferAttribute(upperStarSizes, 1));

        const upperStarsMat = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.9,
            fog: false,
            alphaTest: 0.5,
            map: starTexture
        });

        const upperStarMesh = new THREE.Points(upperStarsGeo, upperStarsMat);
        upperStarMesh.layers.set(0);
        scene.add(upperStarMesh);
        window.upperStarMesh = upperStarMesh; // Make accessible globally for animation

        // === ADD NEBULA CLOUDS IN CRAWL AREA FOR DEPTH ===
        for (let i = 0; i < 3; i++) {
            const nebulaGeo = new THREE.PlaneGeometry(3000, 2000);
            const nebulaCanvas = document.createElement('canvas');
            nebulaCanvas.width = 512;
            nebulaCanvas.height = 512;
            const ctx = nebulaCanvas.getContext('2d');
            
            // Create gradient nebula
            const gradient = ctx.createRadialGradient(256, 256, 50, 256, 256, 300);
            const colors = [
                ['rgba(100, 50, 150, 0.15)', 'rgba(100, 50, 150, 0)'],
                ['rgba(50, 100, 200, 0.15)', 'rgba(50, 100, 200, 0)'],
                ['rgba(150, 50, 100, 0.15)', 'rgba(150, 50, 100, 0)']
            ];
            gradient.addColorStop(0, colors[i][0]);
            gradient.addColorStop(1, colors[i][1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            const nebulaTex = new THREE.CanvasTexture(nebulaCanvas);
            const nebulaMat = new THREE.MeshBasicMaterial({
                map: nebulaTex,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            const nebulaMesh = new THREE.Mesh(nebulaGeo, nebulaMat);
            nebulaMesh.position.set(
                (Math.random() - 0.5) * 6000,
                Math.random() * 8000 + 12000,
                (Math.random() - 0.5) * 6000 - 2000
            );
            nebulaMesh.rotation.x = Math.random() * Math.PI;
            nebulaMesh.rotation.y = Math.random() * Math.PI;
            nebulaMesh.layers.set(0);
            scene.add(nebulaMesh);
        }

        // === IMPROVED REALISTIC GALAXIES WITH VARIED COLORS ===
        function createGalaxy(colorScheme = 0) {
            const colors = [
                { core: 'rgba(255, 200, 100, 0.4)', arms: 'rgba(255, 150, 200, 0.3)', wisps: 'rgba(200, 100, 255, 0.15)' },
                { core: 'rgba(150, 200, 255, 0.4)', arms: 'rgba(100, 200, 255, 0.3)', wisps: 'rgba(200, 200, 255, 0.15)' },
                { core: 'rgba(200, 100, 200, 0.4)', arms: 'rgba(150, 100, 255, 0.3)', wisps: 'rgba(150, 50, 255, 0.15)' },
                { core: 'rgba(255, 150, 100, 0.4)', arms: 'rgba(255, 100, 50, 0.3)', wisps: 'rgba(255, 150, 100, 0.15)' }
            ];
            
            const color = colors[colorScheme % colors.length];
            
            const texture = createCanvasTexture(512, 512, (ctx, w, h) => {
                // Realistic galaxy with disk
                const coreGrad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w/2);
                coreGrad.addColorStop(0, color.core);
                coreGrad.addColorStop(0.3, color.core.replace('0.4', '0.25'));
                coreGrad.addColorStop(0.6, color.core.replace('0.4', '0.1'));
                coreGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = coreGrad;
                ctx.fillRect(0, 0, w, h);

                // Realistic spiral arms
                ctx.globalCompositeOperation = 'lighter';
                for(let arm = 0; arm < 4; arm++) {
                    for(let i = 0; i < 100; i++) {
                        const t = i / 100;
                        const angle = arm * Math.PI / 2 + t * Math.PI * 4;
                        const r = t * w * 0.45;
                        const x = w/2 + Math.cos(angle) * r;
                        const y = h/2 + Math.sin(angle) * r;
                        
                        const opacity = (1 - t * 0.8);
                        ctx.fillStyle = color.arms.replace(/[\d.]+\)$/, `${opacity * 0.3})`);
                        ctx.beginPath();
                        ctx.arc(x, y, 15 + t * 20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Dust lanes
                ctx.globalCompositeOperation = 'multiply';
                const dustGrad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w/2);
                dustGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
                dustGrad.addColorStop(0.5, 'rgba(0, 0, 0, 0.15)');
                dustGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = dustGrad;
                ctx.fillRect(0, 0, w, h);

                // Star clusters
                ctx.globalCompositeOperation = 'screen';
                for(let i = 0; i < 100; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    ctx.fillStyle = color.wisps.replace(/[\d.]+\)$/, `${Math.random() * 0.3})`);
                    ctx.beginPath();
                    ctx.arc(x, y, Math.random() * 3 + 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            const spriteMat = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true, 
                sizeAttenuation: true,
                fog: true
            });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(250, 250, 1);
            return sprite;
        }

        // Add realistic galaxies with varied colors
        const galaxyPositions = [
            { x: 600, y: 400, z: -2500, color: 0 },
            { x: -700, y: -300, z: -2700, color: 1 },
            { x: 400, y: -600, z: -2400, color: 2 },
            { x: -500, y: 500, z: -2600, color: 3 },
            { x: 800, y: -400, z: -2800, color: 0 },
            { x: -300, y: 700, z: -2300, color: 1 },
            { x: 300, y: 200, z: -2550, color: 2 }
        ];

        galaxyPositions.forEach((pos, idx) => {
            const galaxy = createGalaxy(pos.color);
            galaxy.position.set(pos.x, pos.y, pos.z);
            scene.add(galaxy);
        });

        function getPlanetModelPath(planetName) {
            const name = (planetName || '').toLowerCase();
            
            // Map resume planet names to GLTF model folders
            if (name.includes('skills')) return 'assets/models/planet_of_phoenix/scene.gltf';      // Jupiter-like for Skills
            if (name.includes('experience')) return 'assets/models/lava_planet/scene.gltf';        // Mars-like for Experience
            if (name.includes('expertise')) return 'assets/models/saturn_planet/scene.gltf';       // Saturn for Expertise
            if (name.includes('projects')) return 'assets/models/dathomir/scene.gltf';             // Dathomir for Projects
            if (name.includes('education')) return 'assets/models/jupiter/scene.gltf';             // Jupiter for Education
            if (name.includes('certifications')) return 'assets/models/neptune/scene.gltf';        // Neptune for Certifications
            if (name.includes('contact')) return 'assets/models/uranus/scene.gltf';               // Uranus for Contact
            
            // Fallback for old mappings
            if (name.includes('earth')) return 'assets/models/planet_earth/scene.gltf';
            if (name.includes('saturn')) return 'assets/models/saturn_planet/scene.gltf';
            if (name.includes('uranus')) return 'assets/models/uranus/scene.gltf';
            if (name.includes('neptune')) return 'assets/models/neptune/scene.gltf';
            if (name.includes('mars')) return 'assets/models/lava_planet/scene.gltf';
            if (name.includes('venus')) return 'assets/models/planet_afroditi/scene.gltf';
            if (name.includes('jupiter')) return 'assets/models/jupiter/scene.gltf';
            
            return 'assets/models/planet/scene.gltf';
        }

        // Moon models removed - use simple procedural spheres for performance

        // === CREATE PLANETS ===
        RESUME_DATA.planets.forEach((data, idx) => {
            const config = {
                ...data,
                texture: textureMap[data.texture] || drawRed,
                inclination: data.inclination !== undefined ? data.inclination : (Math.random() * 0.4 - 0.2),
                node: data.node !== undefined ? data.node : Math.random() * Math.PI * 2,
                hasRings: data.hasRings !== undefined ? data.hasRings : false,
                eccentricity: data.eccentricity !== undefined ? data.eccentricity : 0,
                tilt: data.tilt !== undefined ? data.tilt : 0
            };

            // Orbital Plane Orientation (Node)
            const planeGroup = new THREE.Group();
            planeGroup.rotation.y = config.node;
            solarSystem.add(planeGroup);

            // Inclination Group
            const orbitGroup = new THREE.Group();
            orbitGroup.rotation.x = config.inclination;
            planeGroup.add(orbitGroup);

            // Orbit path visualization - MORE VISIBLE
            const pathGeo = new THREE.BufferGeometry();
            const pathPoints = [];
            for(let i = 0; i <= 256; i++) {
                const angle = (i / 256) * Math.PI * 2;
                const r = (config.distance * (1 - config.eccentricity * config.eccentricity)) / (1 + config.eccentricity * Math.cos(angle));
                pathPoints.push(
                    Math.cos(angle) * r,
                    0,
                    Math.sin(angle) * r
                );
            }
            pathGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pathPoints), 3));
            const pathMat = new THREE.LineBasicMaterial({ 
                color: 0xaabbff, 
                transparent: true, 
                opacity: 0.5,
                linewidth: 2
            });
            const path = new THREE.Line(pathGeo, pathMat);
            path.visible = orbitsVisible;
            orbitGroup.add(path);
            orbitPaths.push(path);

            const planetGroup = new THREE.Group();
            planetGroup.userData = { ...data, isPlanet: true };

            // Planet Pivot handles the angle (theta)
            const planetPivot = new THREE.Group();
            const initialTheta = Math.random() * Math.PI * 2;
            planetPivot.rotation.y = initialTheta;
            orbitGroup.add(planetPivot);

            // Radial Group handles the distance from sun (r)
            const radialGroup = new THREE.Group();
            planetPivot.add(radialGroup);
            
            // Axial Tilt Group
            const tiltGroup = new THREE.Group();
            tiltGroup.rotation.z = config.tilt;
            radialGroup.add(tiltGroup);

            // Planet is at 0,0,0 inside tiltGroup
            tiltGroup.add(planetGroup);
            planetGroup.position.set(0, 0, 0);

            // Calculate initial radius
            const initialR = (config.distance * (1 - config.eccentricity * config.eccentricity)) / (1 + config.eccentricity * Math.cos(initialTheta));
            radialGroup.position.x = initialR;

            // Push elliptical orbit object
            objects.push({ type: 'ellipticalOrbit', pivot: planetPivot, radial: radialGroup, a: config.distance, e: config.eccentricity, speed: config.speed, theta: initialTheta });
            objects.push({ mesh: planetGroup, speed: 0.003, type: 'rotate' });
            clickableObjects.push(planetGroup);
            backgroundObjects.push(planetGroup); // Add planet to background objects for dimming
            createLabel(data.name, planetGroup);

            // Planet model rings are included in GLTF - don't add old canvas ring

            const planetModelPath = getPlanetModelPath(data.name);
            
            solarModelsToLoad++;
            updateSolarLoadingOverlay();
            gltfLoader.load(
                planetModelPath,
                (gltf) => {
                    const planetModel = gltf.scene;
                    const isContactPlanet = data.name === 'Contact';
                    const boostContactEmissive = (material) => {
                        if (!material || !('emissive' in material)) return;
                        material.emissive.set(0x7fffd4);
                        material.emissiveIntensity = Math.max(material.emissiveIntensity || 0, 1.6);
                        material.needsUpdate = true;
                    };
                    
                    planetModel.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            if (isContactPlanet) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(boostContactEmissive);
                                } else {
                                    boostContactEmissive(child.material);
                                }
                            }
                        }
                    });
                    
                    scaleModelToRadius(planetModel, config.size);
                    planetGroup.add(planetModel);
                    solarModelsLoaded++;
                    checkSolarModelsReady();
                },
                undefined,
                (error) => {
                    console.error(`‚úó FAILED to load ${data.name}: ${planetModelPath}`, error);
                    solarModelsLoaded++;
                    checkSolarModelsReady();
                }
            );

            // Moons
            if (data.moons) {
                data.moons.forEach((moonData, moonIdx) => {
                    // Use specific texture if defined, otherwise fallback logic
                    const texName = moonData.texture;
                    const specificTex = texName && textureMap[texName] ? createCanvasTexture(512, 512, textureMap[texName]) : null;

                    const moonGeo = new THREE.SphereGeometry(moonData.size, 64, 64);
                    const moonTexture = specificTex || createCanvasTexture(1024, 1024, drawRocky);
                    const moonMat = new THREE.MeshPhongMaterial({
                        map: moonTexture,
                        shininess: 25,
                        side: THREE.FrontSide,
                        emissive: moonData.color ? new THREE.Color(moonData.color) : new THREE.Color(0x222222),
                        emissiveIntensity: 0.15
                    });
                    const moon = new THREE.Mesh(moonGeo, moonMat);
                    moon.castShadow = true;
                    moon.receiveShadow = true;
                    moon.userData = { 
                        ...moonData, 
                        isMoon: true, 
                        parentPlanet: planetGroup,
                        name: moonData.name,
                        moonDetails: moonData.moonDetails || "",
                        renderType: moonData.renderType // Ensure renderType is preserved
                    };
                    const moonGroup = moon;

                    // Create moon pivot centered on the planet
                    const moonPivot = new THREE.Group();
                    moonPivot.position.set(0, 0, 0); // Centered on planet (inside radialGroup)
                    
                    // Create moon orbit path with different inclination and orientation
                    const moonOrbitInclination = moonData.inclination !== undefined ? moonData.inclination : (Math.random() - 0.5) * 0.6; // Use custom or random inclination
                    const moonOrbitNode = moonData.node !== undefined ? moonData.node : Math.random() * Math.PI * 2; // Use custom or random node
                    
                    // Moon orbit plane group (for inclination)
                    const moonOrbitPlaneGroup = new THREE.Group();
                    moonOrbitPlaneGroup.rotation.y = moonOrbitNode;
                    moonPivot.add(moonOrbitPlaneGroup);
                    
                    // Moon orbit inclination group
                    const moonOrbitInclinationGroup = new THREE.Group();
                    moonOrbitInclinationGroup.rotation.x = moonOrbitInclination;
                    moonOrbitPlaneGroup.add(moonOrbitInclinationGroup);
                    
                    // Create moon orbit path visualization
                    const moonPathGeo = new THREE.BufferGeometry();
                    const moonPathPoints = [];
                    const planetRadius = data.size || 10;
                    const moonRadius = moonData.size || 1;
                    const baseMoonDistance = moonData.distance || (planetRadius * 2.6);
                    const minMoonDistance = planetRadius + moonRadius + 8;
                    const separation = (moonRadius * 2.2) + 8;
                    const moonOrbitRadius = Math.max(baseMoonDistance, minMoonDistance) + (moonIdx * separation);
                    
                    // Use circular orbit so moons stay on their path
                    const moonEccentricity = 0;
                    
                    for(let i = 0; i <= 128; i++) {
                        const angle = (i / 128) * Math.PI * 2;
                        const r = moonOrbitRadius;
                        moonPathPoints.push(
                            Math.cos(angle) * r,
                            0,
                            Math.sin(angle) * r
                        );
                    }
                    
                    moonPathGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(moonPathPoints), 3));
                    
                    // Moon orbit material - different color and style from planet orbits
                    const moonPathMat = new THREE.LineBasicMaterial({ 
                        color: moonData.color || 0x88ccff, // Use moon's color or default blue
                        transparent: true, 
                        opacity: 0.4, // Slightly more transparent than planet orbits
                        linewidth: 1
                    });
                    
                    const moonOrbitPath = new THREE.Line(moonPathGeo, moonPathMat);
                    moonOrbitPath.visible = false; // Initially hidden, will be shown when planet is focused
                    moonOrbitInclinationGroup.add(moonOrbitPath);
                    
                    // Store moon orbit data for visibility control
                    moonOrbitPaths.push({
                        path: moonOrbitPath,
                        parentPlanet: planetGroup,
                        moon: moon
                    });
                    
                    radialGroup.add(moonPivot); 
                    
                    // Add moon to the inclination group instead of directly to moonPivot for proper orbital mechanics
                    moonOrbitInclinationGroup.add(moon);
                    moon.position.x = moonOrbitRadius;

                    // SLOWER MOON SPEEDS - proper orbiting
                    objects.push({ 
                        mesh: moonOrbitPlaneGroup, // Use the plane group for rotation instead of moonPivot
                        speed: moonData.speed || 0.0025, 
                        type: 'orbit',
                        isExperienceMoon: data.name === 'Experience'
                    });
                    objects.push({ mesh: moon, speed: 0.005, type: 'rotate' });
                    clickableObjects.push(moon);
                    backgroundObjects.push(moon); // Add moon to background objects for dimming
                    createLabel(moonData.name, moon);
                });
            }

            // === ADD SPACESHIP TO SKILLS PLANET ===
            if (data.name === "Skills") {
                const shipGroup = new THREE.Group();
                
                // Body
                const bodyGeo = new THREE.ConeGeometry(1.5, 6, 8);
                bodyGeo.rotateX(Math.PI / 2);
                const bodyMat = new THREE.MeshPhongMaterial({ color: 0xeeeeee, shininess: 100 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                shipGroup.add(body);

                // Wings
                const wingGeo = new THREE.BoxGeometry(4, 0.2, 2);
                const wingMat = new THREE.MeshPhongMaterial({ color: 0xff3333 });
                const wings = new THREE.Mesh(wingGeo, wingMat);
                wings.position.set(0, 0, 1);
                shipGroup.add(wings);

                // Engine glow
                const engineGeo = new THREE.SphereGeometry(0.6, 8, 8);
                const engineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const engine = new THREE.Mesh(engineGeo, engineMat);
                engine.position.set(0, 0, 3);
                shipGroup.add(engine);

                // Position relative to planet center
                shipGroup.position.set(config.size + 8, 0, 0); 
                shipGroup.rotation.y = Math.PI; // Face forward
                shipGroup.userData = { isSpaceship: true, name: "Spaceship" };
                clickableObjects.push(shipGroup);
                
                // Add to radialGroup so it moves with the planet
                radialGroup.add(shipGroup);
                
                // Animate spaceship separately if needed, but adding to planetPivot makes it orbit the planet
                // To make it orbit independently around the planet:
                const shipOrbit = new THREE.Group();
                shipOrbit.add(shipGroup);
                radialGroup.add(shipOrbit); // Add to radialGroup so it orbits the planet center independently
                objects.push({ mesh: shipOrbit, speed: 0.02, type: 'rotate' });
            }
        });

        // === INTERACTION ===
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let mouseDownPos = { x: 0, y: 0 };

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            if (mouseDownPos) {
                const dx = event.clientX - mouseDownPos.x;
                const dy = event.clientY - mouseDownPos.y;
                if (Math.hypot(dx, dy) > 6) {
                    isDragging = true;
                }
            }

            // Hover-target the black hole so scroll zoom moves toward it
            if (!solarSystem.userData.isSucked && !isDragging) {
                raycaster.setFromCamera(mouse, camera);
                const hoverHits = raycaster.intersectObjects([blackHoleGroup], true);
                if (hoverHits.length > 0) {
                    const targetPos = new THREE.Vector3();
                    blackHoleGroup.getWorldPosition(targetPos);
                    controls.target.copy(targetPos);
                }
            }
        });

        window.addEventListener('mousedown', (event) => {
            mouseDownPos = { x: event.clientX, y: event.clientY };
            isDragging = false;
        });

        window.addEventListener('mouseup', () => {
            setTimeout(() => {
                isDragging = false;
            }, 0);
        });

        window.addEventListener('click', onMouseClick);

        function onMouseClick() {
            if (isDragging) {
                isDragging = false;
                return;
            }
            isDragging = false;
            raycaster.setFromCamera(mouse, camera);
            // Recursive true to hit parts of the spaceship group
            const intersects = raycaster.intersectObjects(clickableObjects, true);
            
            if (intersects.length > 0) {
                // Traverse up to find the object with userData (like the spaceship group)
                let target = intersects[0].object;
                while(target.parent && !target.userData.isSpaceship && !target.userData.isPlanet && !target.userData.isMoon && !target.userData.isSun && !target.userData.isBlackHole) { 
                    target = target.parent; 
                }
                
                if (target.userData.isBlackHole) {
                    triggerBlackHoleSuction();
                } else if (target.userData.isSpaceship) {
                    fireLasers(target);
                } else {
                    focusOnObject(target);
                }
            } else {
                // Clicked on empty space - try to go back to previous view
                const skyDetails = document.getElementById('sky-details');
                const overlayPanel = document.getElementById('overlay-panel');
                
                // If modals are open, close them first
                if (skyDetails.style.display === 'block') {
                    closeSkyModal();
                } else if (overlayPanel.classList.contains('active')) {
                    closeOverlay();
                    // For overlay panel (standard moons), return to planet if we were on a moon
                    if (focusedObject && focusedObject.userData.isMoon) {
                        const parentPlanet = focusedObject.userData.parentPlanet;
                        if (parentPlanet) {
                            setTimeout(() => focusOnObject(parentPlanet), 100);
                        }
                    }
                } else {
                    // No modals open, try to go back to previous view
                    const wentBack = goToPreviousView();
                    if (!wentBack) {
                        // No previous view available, just unselect current object
                        focusedObject = null;
                        undimBackground(); // Undim background when unselecting
                        updateMoonOrbitVisibility(); // Update moon orbit visibility
                        // Don't reset view completely, just stop following
                    }
                }
            }
        }

        function triggerBlackHoleSuction() {
            // Safety check - prevent animation from starting if already sucked in
            if (solarSystem.userData.isSucked) {
                console.log('Animation already in progress, ignoring click');
                return;
            }
            solarSystem.userData.isSucked = true;

            const blackHoleWorldPos = new THREE.Vector3();
            blackHoleGroup.getWorldPosition(blackHoleWorldPos);

            const uiLayer = document.getElementById('ui-layer');
            uiLayer.style.display = 'none';
            
            // Hide all buttons during animation
            const buttons = document.querySelectorAll('.hud-btn');
            buttons.forEach(btn => btn.style.display = 'none');

            // Disable controls during animation
            controls.enabled = false;

            blackHoleGroup.scale.set(1, 1, 1);

            // Get initial sun position (relative to solar system)
            const initialSunWorldPos = new THREE.Vector3();
            sun.getWorldPosition(initialSunWorldPos);

            // Calculate direction from sun to black hole
            const directionToHole = blackHoleWorldPos.clone().sub(initialSunWorldPos).normalize();

            // Position camera to see both sun (fully visible) and black hole centered on screen
            // Camera positioned perpendicular to the sun-to-black-hole line for best view
            const distanceBehind = 500;
            const verticalOffset = 70; // Center camera at midpoint height between sun and black hole
            const targetCameraPos = initialSunWorldPos.clone().add(directionToHole.clone().multiplyScalar(-distanceBehind)).add(new THREE.Vector3(0, verticalOffset, 0));

            // Smooth transition to camera position behind the sun
            const transitionDuration = 2.0;
            gsap.to(camera.position, {
                x: targetCameraPos.x,
                y: targetCameraPos.y,
                z: targetCameraPos.z,
                duration: transitionDuration,
                ease: 'sine.inOut'
            });

            // Look at midpoint between sun and black hole to keep both centered on screen
            const lookAtPoint = initialSunWorldPos.clone().add(blackHoleWorldPos).multiplyScalar(0.5);
            gsap.to(controls.target, {
                x: lookAtPoint.x,
                y: lookAtPoint.y,
                z: lookAtPoint.z,
                duration: transitionDuration,
                ease: 'sine.inOut'
            });

            const totalDuration = 107.822; // Main animation starts after transition (10% slower from 98.02)

            // After transition, start the suction animation
            setTimeout(() => {
                // Animate solar system moving towards black hole
                activeSuctionAnimations.position = gsap.to(solarSystem.position, {
                    x: blackHoleWorldPos.x,
                    y: blackHoleWorldPos.y,
                    z: blackHoleWorldPos.z,
                    duration: totalDuration,
                    ease: 'sine.inOut',
                    onUpdate: () => {
                        // Check if reset was called
                        if (stopSuctionAnimation) {
                            this.kill();
                            return;
                        }
                        
                        // Every frame, keep camera positioned to see both sun and black hole centered
                        const sunWorldPos = new THREE.Vector3();
                        sun.getWorldPosition(sunWorldPos);
                        
                        // Calculate current direction to black hole
                        const currentDirToHole = blackHoleWorldPos.clone().sub(sunWorldPos).normalize();
                        
                        // Keep camera at constant distance behind sun, at same height as midpoint for alignment
                        const distanceBehind = 500;
                        const verticalOffset = 70; // Align camera with midpoint height
                        const newCameraPos = sunWorldPos.clone().add(currentDirToHole.clone().multiplyScalar(-distanceBehind)).add(new THREE.Vector3(0, verticalOffset, 0));
                        camera.position.copy(newCameraPos);
                        
                        // Look at midpoint between sun and black hole to keep both centered on screen
                        const midpoint = sunWorldPos.clone().add(blackHoleWorldPos).multiplyScalar(0.5);
                        controls.target.copy(midpoint);
                    },
                    onComplete: () => {
                        controls.enabled = true;
                        stopSuctionAnimation = false;
                    }
                });

                // Black hole grows at 10% faster rate - 33.745 seconds (37.12 / 1.1)
                activeSuctionAnimations.scale = gsap.to(blackHoleGroup.scale, {
                    x: 26.0,
                    y: 26.0,
                    z: 26.0,
                    duration: 33.745,
                    ease: 'sine.inOut',
                    onUpdate: () => {
                        // Check if reset was called
                        if (stopSuctionAnimation) {
                            this.kill();
                        }
                    }
                });

                // Solar system spins as it's pulled in
                activeSuctionAnimations.rotation = gsap.to(solarSystem.rotation, {
                    y: solarSystem.rotation.y + Math.PI * 8,
                    duration: totalDuration,
                    ease: 'sine.inOut'
                });

                // Shrink and fade at the very end
                gsap.to(solarSystem.scale, {
                    x: 0.001,
                    y: 0.001,
                    z: 0.001,
                    duration: totalDuration * 0.15,
                    delay: totalDuration * 0.85,
                    ease: 'sine.inOut',
                    onComplete: () => {
                        solarSystem.visible = false;
                        blackHoleOverlay.style.display = 'block';
                        document.body.classList.add('labels-hidden');
                        // Reload page immediately when screen goes all black
                        window.location.reload();
                    }
                });
            }, transitionDuration * 1000);
        }

        // Double Click to Zoom
        window.addEventListener('dblclick', () => {
            if (isMobile) return;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects, true);
            
            if (intersects.length > 0) {
                let target = intersects[0].object;
                while(target.parent && !target.userData.isSpaceship && !target.userData.isPlanet && !target.userData.isMoon && !target.userData.isSun) { 
                    target = target.parent; 
                }
                focusOnObject(target);
            } else {
                // Zoom into empty space (move forward)
                const direction = new THREE.Vector3();
                raycaster.ray.direction.clone(direction);
                const moveDistance = 50;
                const newPos = camera.position.clone().add(direction.multiplyScalar(moveDistance));
                const newTarget = controls.target.clone().add(direction); // Keep target relative
                
                gsap.to(camera.position, { x: newPos.x, y: newPos.y, z: newPos.z, duration: 1.2 });
                gsap.to(controls.target, { x: newTarget.x, y: newTarget.y, z: newTarget.z, duration: 1.2 });
            }
        });

        // === BACKGROUND DIMMING SYSTEM ===
        function getDimmableMeshes(obj) {
            const meshes = [];
            if (!obj) return meshes;
            obj.traverse(child => {
                if (child.isMesh && child.material) {
                    meshes.push(child);
                }
            });
            return meshes;
        }

        function dimBackground(focusedPlanet) {
            if (backgroundDimming) return; // Already dimmed
            
            backgroundDimming = true;
            
            // Dim all objects except the focused planet and its moons
            backgroundObjects.forEach(obj => {
                if (obj === focusedPlanet) return; // Don't dim the focused planet
                
                // Don't dim moons of the focused planet
                if (obj.userData.isMoon && obj.userData.parentPlanet === focusedPlanet) return;
                
                const meshes = getDimmableMeshes(obj);
                if (meshes.length === 0) return;
                
                // Different dimming levels: planets vs moons of other planets
                let dimFactor, opacityFactor;
                if (obj.userData.isMoon) {
                    // Moons of other planets: make them nearly invisible (like real space)
                    dimFactor = 0.02; // Very dim
                    opacityFactor = 0.05; // Nearly transparent
                } else {
                    // Other planets: dim but still visible (no transparency)
                    dimFactor = 0.08; // Dim but visible
                    opacityFactor = 1.0; // Keep opaque
                }

                meshes.forEach(mesh => {
                    const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];

                    if (!mesh.userData.originalMaterial) {
                        mesh.userData.originalMaterial = materials.map(mat => ({
                            emissive: mat.emissive ? mat.emissive.clone() : null,
                            emissiveIntensity: typeof mat.emissiveIntensity === 'number' ? mat.emissiveIntensity : null,
                            opacity: typeof mat.opacity === 'number' ? mat.opacity : 1.0,
                            transparent: !!mat.transparent
                        }));
                    }

                    materials.forEach((mat, idx) => {
                        const original = mesh.userData.originalMaterial[idx];
                        if (mat.emissive && original && original.emissive) {
                            gsap.to(mat.emissive, {
                                r: original.emissive.r * dimFactor,
                                g: original.emissive.g * dimFactor,
                                b: original.emissive.b * dimFactor,
                                duration: 1.0
                            });
                        }

                        if (typeof mat.emissiveIntensity === 'number' && original && original.emissiveIntensity !== null) {
                            gsap.to(mat, {
                                emissiveIntensity: original.emissiveIntensity * dimFactor,
                                duration: 1.0
                            });
                        }

                        if (obj.userData.isMoon) {
                            if (!mat.transparent) {
                                mat.transparent = true;
                            }
                            gsap.to(mat, {
                                opacity: (original ? original.opacity : 1.0) * opacityFactor,
                                duration: 1.0
                            });
                        } else {
                            if (mat.transparent) {
                                mat.transparent = false;
                            }
                            gsap.to(mat, {
                                opacity: 1.0,
                                duration: 0.5
                            });
                        }
                    });
                });
            });
            
            // Also dim labels of background objects
            labels.forEach(labelItem => {
                const obj = labelItem.object;
                if (obj === focusedPlanet) return; // Don't dim focused planet label
                if (obj.userData.isMoon && obj.userData.parentPlanet === focusedPlanet) return; // Don't dim focused planet's moon labels
                
                // Store original label opacity if not stored
                if (!labelItem.originalOpacity) {
                    labelItem.originalOpacity = parseFloat(window.getComputedStyle(labelItem.div).opacity) || 1.0;
                }
                
                // Dim labels of background objects
                let labelOpacity;
                if (obj.userData.isMoon) {
                    labelOpacity = 0.1; // Very dim for background moons
                } else {
                    labelOpacity = 0.3; // Dim for background planets
                }
                
                gsap.to(labelItem.div, {
                    opacity: labelOpacity,
                    duration: 1.0
                });
            });
        }
        
        function undimBackground() {
            if (!backgroundDimming) return; // Not dimmed
            
            backgroundDimming = false;
            
            // Restore all objects to their original brightness
            backgroundObjects.forEach(obj => {
                const meshes = getDimmableMeshes(obj);
                if (meshes.length === 0) return;

                meshes.forEach(mesh => {
                    if (!mesh.userData.originalMaterial) return;
                    const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];

                    materials.forEach((mat, idx) => {
                        const original = mesh.userData.originalMaterial[idx];
                        if (!original) return;

                        if (mat.emissive && original.emissive) {
                            gsap.to(mat.emissive, {
                                r: original.emissive.r,
                                g: original.emissive.g,
                                b: original.emissive.b,
                                duration: 1.0
                            });
                        }

                        gsap.to(mat, {
                            emissiveIntensity: original.emissiveIntensity !== null ? original.emissiveIntensity : mat.emissiveIntensity,
                            opacity: original.opacity,
                            duration: 1.0
                        });
                    });
                });
            });
            
            // Restore all labels to their original opacity
            labels.forEach(labelItem => {
                if (labelItem.originalOpacity !== undefined) {
                    gsap.to(labelItem.div, {
                        opacity: labelItem.originalOpacity,
                        duration: 1.0
                    });
                }
            });
        }

        // === INTERACTION HELPERS & OVERLAY ===
        // add focus / overlay functions (show moon surface + details)
        function focusOnObject(object) {
            // Save current view before changing (unless it's the same object)
            if (object !== focusedObject) {
                saveCurrentView();
            }
            
        	if (object && object.userData && (object.userData.isSun || object.userData.viewType === 'center')) {
                focusedObject = null; // Disable auto-tracking for Center view
                undimBackground(); // Undim background when focusing on sun
                updateMoonOrbitVisibility(); // Update moon orbit visibility

                if (!isCenterView) {
                    previousCameraPos.copy(camera.position);
                    previousTarget.copy(controls.target);
                }
                
                const title = object.userData.isSun ? RESUME_DATA.name : object.userData.name;
                const content = object.userData.isSun ? RESUME_DATA.summary : object.userData.details;
                const subTitle = object.userData.isSun ? RESUME_DATA.role : "";

                showCenterProfile(title, subTitle, content, object.userData.isSun);
                
                isCenterView = true;
                controls.enableZoom = false;
                controls.maxDistance = 20; 
                controls.minDistance = 0.1;

                // Move camera to object center
                const targetPos = new THREE.Vector3();
                object.getWorldPosition(targetPos);
                
                gsap.to(camera.position, { x: targetPos.x, y: targetPos.y, z: targetPos.z + 1, duration: 1.5 });
                gsap.to(controls.target, { x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 1.5 });
                return;
            }

        	focusedObject = object;
        	updateMoonOrbitVisibility(); // Update moon orbit visibility when focusing on any object
        	
        	if (object && object.userData && (object.userData.isMoon || object.userData.isPlanet)) {
        		showMoonDetails(object);
        	} else {
                // Hide sky details if not a moon
                document.getElementById('sky-details').style.display = 'none';
                // Show side panel for planets
                if (object && object.userData && object.userData.isPlanet) {
                    showMoonDetails(object); // Reuse this for planets too if needed, or keep existing behavior
                }
        	}

        	// Ensure controls target will follow the object continuously
        	if (object) {
        		// Get world position for initial targeting
        		const targetPos = new THREE.Vector3();
        		object.getWorldPosition(targetPos);
        		
                // If it's a moon, zoom in close and don't dim background
                if (object.userData.isMoon) {
                    undimBackground(); // Undim when focusing on moon
                    const offset = new THREE.Vector3(object.geometry.parameters.radius * 4, 2, 2);
                    const camPos = targetPos.clone().add(offset);
                    gsap.to(camera.position, { x: camPos.x, y: camPos.y, z: camPos.z, duration: 1.5 });
                }
                // If it's a planet, zoom in comfortably to see moons and dim background
                else if (object.userData.isPlanet) {
                    dimBackground(object); // Dim background when focusing on planet
                    const dist = (object.userData.size || 5) * 3 + 15;
                    const currentDir = camera.position.clone().sub(targetPos).normalize();
                    const newPos = targetPos.clone().add(currentDir.multiplyScalar(dist));
                    
                    gsap.to(camera.position, { x: newPos.x, y: newPos.y, z: newPos.z, duration: 1.5 });
                }
                
                // Set initial target but don't animate it - let the animation loop handle continuous following
                controls.target.copy(targetPos);
        	}
        }

        function showCenterProfile(title, subTitle, content, isSun) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            titleEl.textContent = title;
            
            let html = `
                <div style="display: flex; flex-direction: column; height: 100%; max-height: 100%;">
                    ${isSun ? `
                    <!-- Profile Header -->
                    <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 15px; flex-shrink: 0;">
                        <img src="${RESUME_DATA.profileImage}" style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid #38bdf8; object-fit: cover; animation: pulseGlow 3s ease-in-out infinite; margin-right: 15px;">
                        <div style="text-align: left;">
                            <h3 style="color: #38bdf8; margin: 0 0 3px 0; font-size: 20px;">${subTitle}</h3>
                            <div style="color: #94a3b8; font-size: 12px;">Business Analyst</div>
                        </div>
                    </div>
                    
                    <!-- Contact Info Grid -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 8px; margin-bottom: 15px; flex-shrink: 0;">
                        <div style="background: rgba(255,255,255,0.05); padding: 6px 10px; border-radius: 6px; font-size: 11px;">
                            <strong>üìß</strong> <a href="mailto:${RESUME_DATA.contact.email}" style="color: #38bdf8; text-decoration: none;">${RESUME_DATA.contact.email}</a>
                        </div>
                        <div style="background: rgba(255,255,255,0.05); padding: 6px 10px; border-radius: 6px; font-size: 11px;">
                            <strong>üì±</strong> ${RESUME_DATA.contact.phone}
                        </div>
                        <div style="background: rgba(255,255,255,0.05); padding: 6px 10px; border-radius: 6px; font-size: 11px;">
                            <strong>üìç</strong> ${RESUME_DATA.contact.location}
                        </div>
                        <div style="background: rgba(255,255,255,0.05); padding: 6px 10px; border-radius: 6px; font-size: 11px;">
                            <strong>üîó</strong> <a href="https://${RESUME_DATA.contact.linkedin}" target="_blank" style="color: #38bdf8; text-decoration: none;">LinkedIn</a>
                        </div>
                    </div>
                    ` : ''}
                    
                    <!-- Summary Content -->
                    <div style="flex: 1; background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px; overflow: hidden; min-height: 0;">
                        ${isSun ? '<h4 style="color: #e2e8f0; margin: 0 0 12px 0; text-align: center; font-size: 16px;">Professional Summary</h4>' : ''}
                        <p style="line-height: 1.5; color: #cbd5e1; text-align: ${isSun ? 'left' : 'center'}; font-size: ${isSun ? '13px' : '16px'}; margin: 0; overflow: hidden; display: -webkit-box; -webkit-line-clamp: ${isSun ? '8' : '6'}; -webkit-box-orient: vertical;">${content}</p>
                    </div>
                    
                    ${isSun ? `
                    <!-- Quick Stats -->
                    <div style="display: flex; justify-content: space-around; margin-top: 12px; flex-shrink: 0;">
                        <div style="text-align: center;">
                            <div style="color: #38bdf8; font-size: 16px; font-weight: bold;">18+</div>
                            <div style="color: #94a3b8; font-size: 9px;">Years Experience</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #38bdf8; font-size: 16px; font-weight: bold;">4</div>
                            <div style="color: #94a3b8; font-size: 9px;">Languages</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #38bdf8; font-size: 16px; font-weight: bold;">10+</div>
                            <div style="color: #94a3b8; font-size: 9px;">Major Projects</div>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Enhanced modal system for all planets
        function showMoonDetails(moon) {
            const parentPlanet = moon.userData.parentPlanet;
            const parentName = parentPlanet && parentPlanet.userData ? parentPlanet.userData.name : '';
            const moonName = moon.userData.name || 'Moon';
            
            // Check if this is a special moon that needs enhanced modal
            const isLanguagesMoon = moon.userData.renderType === 'languages' || moonName === 'Languages';
            const isEducationMoon = parentName === 'Education';
            const isSkillsMoon = parentName === 'Skills & Tools';
            const isExperienceMoon = parentName === 'Experience';
            const isExpertiseMoon = parentName === 'Expertise & Impact';
            const isProjectsMoon = parentName === 'Projects';
            const isCertificationsMoon = parentName === 'Certifications';
            const isContactMoon = parentName === 'Contact';
            
            if (isLanguagesMoon || isEducationMoon) {
                showEnhancedModal(moon, parentName);
            } else if (isSkillsMoon || isCertificationsMoon) {
                showSkillsModal(moon);
            } else if (isExperienceMoon) {
                showExperienceModal(moon);
            } else if (isExpertiseMoon) {
                showExpertiseModal(moon);
            } else if (isProjectsMoon) {
                showProjectsModal(moon);
            } else if (isContactMoon) {
                showContactModal(moon);
            } else {
                showStandardModal(moon);
            }
        }

        // Enhanced modal for Languages and Education with 3D characters and maps
        function showEnhancedModal(moon, planetType) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            titleEl.textContent = moonName;
            
            let html = '';
            
            // Check if this is a Languages moon by its renderType or name
            const isLanguagesMoon = moon.userData.renderType === 'languages' || moonName === 'Languages';
            
            if (isLanguagesMoon) {
                // Check if this is the comprehensive Languages moon or individual language
                if (moon.userData.pdfDetails && moon.userData.pdfDetails.languages) {
                    // Comprehensive Languages modal showing all languages
                    const languagesData = moon.userData.pdfDetails.languages;
                    
                    html = `
                        <div style="display: flex; flex-direction: column; height: 100%; padding: 15px; overflow: hidden;">
                            <!-- Header -->
                            <div style="text-align: center; margin-bottom: 15px; flex-shrink: 0;">
                                <h2 style="color: #38bdf8; margin: 0; font-size: 20px;">üåç Languages</h2>
                                <div style="color: #94a3b8; font-size: 12px; margin-top: 3px;">Communication Capabilities</div>
                            </div>
                            
                            <!-- Languages Grid -->
                            <div class="language-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; flex: 1; overflow-y: auto; padding-right: 5px;">
                                ${languagesData.map(lang => {
                                    const heroData = createHeroFace(lang.hero || 'Einstein');
                                    return `
                                    <div style="background: rgba(56, 189, 248, 0.05); border: 1px solid rgba(56, 189, 248, 0.2); border-radius: 10px; padding: 12px; transition: all 0.3s ease; cursor: pointer; height: fit-content;" 
                                         onmouseover="this.style.transform='scale(1.02)'; this.style.background='rgba(56, 189, 248, 0.1)'; this.style.animation='languageCardGlow 2s ease-in-out infinite';" 
                                         onmouseout="this.style.transform='scale(1)'; this.style.background='rgba(56, 189, 248, 0.05)'; this.style.animation='none'; this.style.boxShadow='none';">
                                        <!-- Language Header -->
                                        <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                            <div style="margin-right: 8px; animation: ${heroData.animation}; flex-shrink: 0;">
                                                ${heroData.face}
                                            </div>
                                            <div style="flex: 1; min-width: 0;">
                                                <h3 style="color: #38bdf8; margin: 0; font-size: 14px; line-height: 1.2;">${lang.name}</h3>
                                                <div style="color: #94a3b8; font-size: 10px; margin-top: 1px;">${lang.proficiency}</div>
                                                <div style="color: #64748b; font-size: 8px; margin-top: 1px; font-style: italic; line-height: 1.1;">${heroData.description}</div>
                                            </div>
                                            <div style="background: linear-gradient(45deg, #38bdf8, #818cf8); border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 10px; color: white; font-weight: bold; flex-shrink: 0;">
                                                ${getProficiencyBadge(lang.proficiency)}
                                            </div>
                                        </div>
                                        
                                        <!-- Skills Assessment -->
                                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px;">
                                            ${['speaking', 'reading', 'writing', 'comprehension'].map((skill, index) => {
                                                const icons = ['üó£Ô∏è', 'üìñ', '‚úçÔ∏è', 'üëÇ'];
                                                const labels = ['Speaking', 'Reading', 'Writing', 'Listening'];
                                                const score = lang.skills[skill] || 5;
                                                const percentage = score * 10;
                                                
                                                return `
                                                <div style="background: rgba(255,255,255,0.05); border-radius: 4px; padding: 6px; text-align: center; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(255,255,255,0.1)'; this.style.transform='scale(1.05)';" onmouseout="this.style.background='rgba(255,255,255,0.05)'; this.style.transform='scale(1)';">
                                                    <div style="font-size: 10px; margin-bottom: 2px;">${icons[index]}</div>
                                                    <div style="font-size: 7px; color: #94a3b8; margin-bottom: 2px; font-weight: 600;">${labels[index].toUpperCase()}</div>
                                                    <div style="color: #38bdf8; font-weight: bold; font-size: 9px; margin-bottom: 2px;">${score}/10</div>
                                                    <div style="background: rgba(56, 189, 248, 0.2); height: 2px; border-radius: 1px; overflow: hidden;">
                                                        <div style="background: linear-gradient(90deg, #38bdf8, #818cf8); height: 100%; width: ${percentage}%; border-radius: 1px; transition: width 1s ease-in-out;"></div>
                                                    </div>
                                                </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                } else {
                    // Individual language modal (if we had individual language moons)
                    const proficiencyLevel = moon.userData.proficiencyLevel || getProficiencyLevel(moon.userData.details);
                    const heroName = moon.userData.hero || getHeroForLanguage(moonName);
                    const heroData = createHeroFace(heroName);
                    const skills = moon.userData.skills || {};
                    
                    // Extract key details from the description
                    const details = moon.userData.details || '';
                    const keyPoints = details.split('\n').filter(line => line.trim() && !line.includes('Proficiency')).slice(1, 3);
                    
                    html = `
                        <div style="display: flex; flex-direction: column; height: 100%; padding: 12px;">
                            <!-- Header with Language Name -->
                            <div style="text-align: center; margin-bottom: 12px;">
                                <h2 style="color: #38bdf8; margin: 0; font-size: 18px;">${moonName}</h2>
                                <div style="color: #94a3b8; font-size: 12px; margin-top: 2px;">${proficiencyLevel} Proficiency</div>
                            </div>
                            
                            <!-- Character and Level Section -->
                            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 15px; background: rgba(56, 189, 248, 0.05); border-radius: 10px; padding: 12px;">
                                <div style="text-align: center; margin-right: 15px; flex-shrink: 0;">
                                    <div style="animation: ${heroData.animation}; margin-bottom: 6px;">
                                        ${heroData.face}
                                    </div>
                                    <div style="color: #38bdf8; font-weight: bold; font-size: 10px;">${heroData.description}</div>
                                </div>
                                <div style="flex: 1; padding-left: 10px;">
                                    <div style="background: rgba(255,255,255,0.08); border-radius: 8px; padding: 10px; font-size: 11px; color: #e2e8f0; line-height: 1.3; border: 1px solid rgba(56, 189, 248, 0.2);">
                                        ${keyPoints.join(' ')}
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Compact Skills Assessment - Single Row -->
                            <div style="background: rgba(255,255,255,0.03); border-radius: 10px; padding: 12px; border: 1px solid rgba(56, 189, 248, 0.1);">
                                <h3 style="color: #38bdf8; margin: 0 0 10px 0; font-size: 14px; text-align: center;">Language Skills Assessment</h3>
                                <div style="display: flex; gap: 10px; justify-content: space-between;">
                                    ${['speaking', 'reading', 'writing', 'comprehension'].map((skill, index) => {
                                        const icons = ['üó£Ô∏è', 'üìñ', '‚úçÔ∏è', 'üëÇ'];
                                        const labels = ['Speaking', 'Reading', 'Writing', 'Listening'];
                                        const score = skills[skill] || parseInt(getProficiencyScore(proficiencyLevel, skill));
                                        const percentage = score * 10;
                                        
                                        return `
                                        <div style="background: rgba(56, 189, 248, 0.08); border-radius: 8px; padding: 10px; text-align: center; border: 1px solid rgba(56, 189, 248, 0.2); transition: transform 0.3s ease; flex: 1; min-width: 0;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                            <div style="font-size: 16px; margin-bottom: 4px;">${icons[index]}</div>
                                            <div style="font-size: 9px; color: #94a3b8; margin-bottom: 4px; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${labels[index].toUpperCase()}</div>
                                            <div style="color: #38bdf8; font-weight: bold; font-size: 14px; margin-bottom: 4px;">${score}/10</div>
                                            <div style="background: rgba(56, 189, 248, 0.2); height: 3px; border-radius: 2px; overflow: hidden;">
                                                <div style="background: linear-gradient(90deg, #38bdf8, #818cf8); height: 100%; width: 0%; border-radius: 2px; transition: width 1s ease-in-out 0.${index * 2}s; animation: fillBar${index} 1s ease-in-out 0.${index * 2}s forwards;"></div>
                                            </div>
                                        </div>
                                        <style>
                                            @keyframes fillBar${index} {
                                                from { width: 0%; }
                                                to { width: ${percentage}%; }
                                            }
                                        </style>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                }
            } else if (planetType === 'Education') {
                // Compact Education Modal with side-by-side layout
                const institution = moon.userData.institution || '';
                const degree = moon.userData.degree || '';
                const field = moon.userData.field || '';
                const duration = moon.userData.duration || '';
                const location = moon.userData.location || '';
                const achievements = moon.userData.achievements || [];
                
                html = `
                    <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                        <!-- Header with Icon and Basic Info -->
                        <div style="display: flex; align-items: center; margin-bottom: 15px;">
                            <div style="font-size: 50px; margin-right: 15px; animation: charHover 3s infinite ease-in-out;">üéì</div>
                            <div style="flex: 1;">
                                <h3 style="color: #38bdf8; margin: 0 0 5px 0; font-size: 20px;">${degree}</h3>
                                <p style="color: #e2e8f0; margin: 0 0 3px 0; font-size: 16px;">${field}</p>
                                <p style="color: #94a3b8; margin: 0; font-size: 14px;">${duration} ‚Ä¢ ${location}</p>
                            </div>
                        </div>
                        
                        <!-- Main Content: Two Columns -->
                        <div style="display: flex; gap: 15px; flex: 1; min-height: 0;">
                            <!-- Left Column: Institution & Achievements -->
                            <div style="flex: 1; display: flex; flex-direction: column;">
                                <div style="background: rgba(56, 189, 248, 0.1); border: 1px solid rgba(56, 189, 248, 0.3); border-radius: 10px; padding: 12px; margin-bottom: 12px;">
                                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                        <span style="font-size: 16px; margin-right: 8px;">üèõÔ∏è</span>
                                        <span style="color: #38bdf8; font-weight: bold; font-size: 15px;">${institution}</span>
                                    </div>
                                </div>
                                
                                ${achievements.length > 0 ? `
                                <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 12px; flex: 1; overflow: hidden;">
                                    <h4 style="color: #38bdf8; margin: 0 0 10px 0; font-size: 15px; display: flex; align-items: center;">
                                        <span style="margin-right: 6px;">üèÜ</span>
                                        Highlights
                                    </h4>
                                    <div style="color: #e2e8f0; font-size: 12px; line-height: 1.4; text-align: left; max-height: 200px; overflow: hidden;">
                                        ${achievements.slice(0, 4).map(achievement => `
                                            <div style="display: flex; align-items: flex-start; margin-bottom: 6px; padding: 4px 0; text-align: left;">
                                                <span style="color: #38bdf8; margin-right: 6px; margin-top: 1px; flex-shrink: 0;">‚Ä¢</span>
                                                <span style="flex: 1; text-align: left;">${achievement}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                            
                            <!-- Right Column: Map or Details -->
                            ${moon.userData.mapQuery ? `
                            <div style="flex: 1; display: flex; flex-direction: column;">
                                <div style="background: rgba(56, 189, 248, 0.1); border: 1px solid rgba(56, 189, 248, 0.3); border-radius: 10px; overflow: hidden; flex: 1;">
                                    <div style="background: rgba(56, 189, 248, 0.2); padding: 10px; text-align: center; color: #38bdf8; font-weight: bold; font-size: 14px;">
                                        üìç Location
                                    </div>
                                    <iframe width="100%" height="100%" frameborder="0" style="border:0; filter: hue-rotate(200deg) saturate(0.8); min-height: 180px;" 
                                        src="https://maps.google.com/maps?q=${encodeURIComponent(moon.userData.mapQuery)}&t=&z=15&ie=UTF8&iwloc=&output=embed">
                                    </iframe>
                                </div>
                            </div>
                            ` : `
                            <div style="flex: 1; background: rgba(255,255,255,0.05); border-radius: 10px; padding: 12px; overflow: hidden;">
                                <div style="color: #e2e8f0; font-size: 12px; line-height: 1.4; max-height: 200px; overflow: hidden;">
                                    ${moon.userData.details ? moon.userData.details.split('\n').slice(2).join('\n') : ''}
                                </div>
                            </div>
                            `}
                        </div>
                    </div>
                `;
            }
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Skills modal for Skills & Tools planet moons
        function showSkillsModal(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            const pdfDetails = moon.userData.pdfDetails || {};
            
            titleEl.textContent = moonName;
            
            let html = '';
            
            if (pdfDetails.skills) {
                // Enhanced Skills Moon Modal
                html = `
                    <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                        <div style="background: rgba(56, 189, 248, 0.1); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <h3 style="color: #38bdf8; margin: 0 0 10px 0; font-size: 22px;">${pdfDetails.title}</h3>
                            <p style="color: #94a3b8; margin: 0 0 15px 0; font-size: 16px;">${pdfDetails.description}</p>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; flex: 1;">
                            <h4 style="color: #38bdf8; margin: 0 0 15px 0; font-size: 18px; display: flex; align-items: center;">
                                <span style="margin-right: 8px;">üõ†Ô∏è</span>
                                Skills & Tools
                            </h4>
                            <div style="display: grid; gap: 8px; max-height: 400px; overflow-y: auto;">
                                ${pdfDetails.skills.map(skill => `
                                    <div style="display: flex; align-items: center; padding: 10px 15px; background: rgba(56, 189, 248, 0.08); border-radius: 8px; border: 1px solid rgba(56, 189, 248, 0.2); transition: transform 0.2s ease;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                                        <span style="color: #38bdf8; margin-right: 10px; font-size: 16px;">‚Ä¢</span>
                                        <span style="color: #e2e8f0; font-size: 15px; line-height: 1.4;">${skill}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Fallback for skills moons without detailed data
                html = `
                    <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                        <div style="background: rgba(56, 189, 248, 0.1); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <h3 style="color: #38bdf8; margin: 0 0 10px 0; font-size: 22px;">${moonName}</h3>
                            <p style="color: #94a3b8; margin: 0; font-size: 16px;">Skills and capabilities in this area</p>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; flex: 1;">
                            <div style="color: #e2e8f0; font-size: 16px; line-height: 1.6;">
                                ${moon.userData.details || moon.userData.moonDetails || 'Detailed information about this skill area.'}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Projects modal for Projects planet moons
        function showProjectsModal(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            const pdfDetails = moon.userData.pdfDetails || {};
            
            titleEl.textContent = moonName;
            
            let html = `
                <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                    <div style="background: rgba(231, 76, 60, 0.1); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <h3 style="color: #e74c3c; margin: 0 0 10px 0; font-size: 22px;">${pdfDetails.title || moonName}</h3>
                        <p style="color: #94a3b8; margin: 0 0 15px 0; font-size: 16px;">${pdfDetails.subtitle || 'Project Initiative'}</p>
                        <p style="color: #e2e8f0; margin: 0; font-size: 15px; line-height: 1.5;">${pdfDetails.description || 'Major project initiative with significant business impact.'}</p>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; flex: 1;">
                        <h4 style="color: #e74c3c; margin: 0 0 15px 0; font-size: 18px; display: flex; align-items: center;">
                            <span style="margin-right: 8px;">üéØ</span>
                            Impact & Results
                        </h4>
                        <div style="display: grid; gap: 8px; max-height: 300px; overflow-y: auto;">
                            ${(pdfDetails.impact || []).map(impact => `
                                <div style="display: flex; align-items: center; padding: 10px 15px; background: rgba(231, 76, 60, 0.08); border-radius: 8px; border: 1px solid rgba(231, 76, 60, 0.2); transition: transform 0.2s ease;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                                    <span style="color: #e74c3c; margin-right: 10px; font-size: 16px;">‚Ä¢</span>
                                    <span style="color: #e2e8f0; font-size: 15px; line-height: 1.4;">${impact}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Contact modal for Contact planet moons
        function showContactModal(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            const pdfDetails = moon.userData.pdfDetails || {};
            const contactInfo = pdfDetails.contact || {};
            
            titleEl.textContent = moonName;
            
            let html = `
                <div style="display: flex; flex-direction: column; height: 100%; padding: 20px; align-items: center; justify-content: center;">
                    <div style="background: rgba(26, 188, 156, 0.1); border-radius: 20px; padding: 40px; text-align: center; max-width: 500px;">
                        <div style="font-size: 80px; margin-bottom: 20px; animation: pulseGlow 2s infinite;">${contactInfo.icon || 'üìû'}</div>
                        <h3 style="color: #1abc9c; margin: 0 0 15px 0; font-size: 24px;">${pdfDetails.title || moonName}</h3>
                        <p style="color: #94a3b8; margin: 0 0 25px 0; font-size: 16px;">${pdfDetails.description || 'Contact information'}</p>
                        
                        <div style="background: rgba(255,255,255,0.05); border-radius: 15px; padding: 25px; margin-bottom: 20px;">
                            ${contactInfo.link ? `
                                <a href="${contactInfo.link}" style="color: #1abc9c; text-decoration: none; font-size: 18px; font-weight: bold; display: block; padding: 15px; background: rgba(26, 188, 156, 0.1); border-radius: 10px; border: 2px solid rgba(26, 188, 156, 0.3); transition: all 0.3s ease;" onmouseover="this.style.background='rgba(26, 188, 156, 0.2)'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='rgba(26, 188, 156, 0.1)'; this.style.transform='scale(1)'">
                                    ${contactInfo.value}
                                </a>
                            ` : `
                                <div style="color: #e2e8f0; font-size: 18px; font-weight: bold; padding: 15px; background: rgba(26, 188, 156, 0.1); border-radius: 10px; border: 2px solid rgba(26, 188, 156, 0.3);">
                                    ${contactInfo.value}
                                </div>
                            `}
                        </div>
                        
                        <p style="color: #94a3b8; font-size: 14px; margin: 0;">
                            ${contactInfo.method === 'Email' ? 'Click to send email' : 
                              contactInfo.method === 'Phone' ? 'Click to call' : 
                              contactInfo.method === 'LinkedIn' ? 'Click to view profile' : 
                              'Professional contact information'}
                        </p>
                    </div>
                </div>
            `;
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Experience modal for Experience planet moons
        function showExperienceModal(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            const pdfDetails = moon.userData.pdfDetails || {};
            
            titleEl.textContent = moonName;
            
            let html = `
                <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                    <!-- Company Header -->
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h2 style="color: #38bdf8; margin: 0; font-size: 24px;">${pdfDetails.company || moonName}</h2>
                        <div style="color: #94a3b8; font-size: 16px; margin-top: 5px;">${pdfDetails.role || 'Professional Role'}</div>
                        <div style="color: #64748b; font-size: 14px; margin-top: 3px;">${pdfDetails.duration || ''} | ${pdfDetails.location || ''}</div>
                    </div>
                    
                    <!-- Industry Badge -->
                    ${pdfDetails.industry ? `
                        <div style="text-align: center; margin-bottom: 20px;">
                            <span style="background: linear-gradient(45deg, #38bdf8, #818cf8); color: white; padding: 8px 16px; border-radius: 20px; font-size: 12px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;">
                                ${pdfDetails.industry}
                            </span>
                        </div>
                    ` : ''}
                    
                    <!-- Achievements -->
                    <div style="flex: 1; overflow-y: auto;">
                        <h3 style="color: #38bdf8; margin: 0 0 15px 0; font-size: 18px; text-align: center;">Key Achievements</h3>
                        <div style="background: rgba(255,255,255,0.03); border-radius: 12px; padding: 15px;">
                            ${(pdfDetails.achievements || []).map(achievement => `
                                <div style="background: rgba(56, 189, 248, 0.05); border-left: 3px solid #38bdf8; padding: 12px; margin-bottom: 10px; border-radius: 0 8px 8px 0;">
                                    <p style="margin: 0; color: #e2e8f0; font-size: 14px; line-height: 1.5;">${achievement}</p>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Expertise modal for Expertise & Impact planet moons
        function showExpertiseModal(moon) {
            const skyDetails = document.getElementById('sky-details');
            const titleEl = document.getElementById('sky-title');
            const contentEl = document.getElementById('sky-content');
            
            const moonName = moon.userData.name || 'Moon';
            const pdfDetails = moon.userData.pdfDetails || {};
            
            titleEl.textContent = moonName;
            
            let html = `
                <div style="display: flex; flex-direction: column; height: 100%; padding: 20px;">
                    <!-- Header -->
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h2 style="color: #f39c12; margin: 0; font-size: 24px;">${pdfDetails.title || moonName}</h2>
                        <div style="color: #94a3b8; font-size: 14px; margin-top: 5px;">${pdfDetails.subtitle || 'Domain Expertise'}</div>
                    </div>
                    
                    <!-- Description -->
                    ${pdfDetails.description ? `
                        <div style="background: rgba(243, 156, 18, 0.1); border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                            <p style="color: #e2e8f0; margin: 0; font-size: 14px; line-height: 1.5; text-align: center;">${pdfDetails.description}</p>
                        </div>
                    ` : ''}
                    
                    <!-- Content Sections -->
                    <div style="flex: 1; overflow-y: auto; display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <!-- Impact Column -->
                        ${pdfDetails.impact ? `
                            <div style="background: rgba(255,255,255,0.03); border-radius: 10px; padding: 15px;">
                                <h4 style="color: #f39c12; margin: 0 0 12px 0; font-size: 16px; text-align: center;">üìä Measurable Impact</h4>
                                ${pdfDetails.impact.map(item => `
                                    <div style="background: rgba(243, 156, 18, 0.1); padding: 8px; margin-bottom: 8px; border-radius: 6px; border-left: 3px solid #f39c12;">
                                        <p style="margin: 0; color: #e2e8f0; font-size: 12px; line-height: 1.4;">${item}</p>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        <!-- Problems/Approaches Column -->
                        ${(pdfDetails.problems || pdfDetails.approaches || pdfDetails.capabilities) ? `
                            <div style="background: rgba(255,255,255,0.03); border-radius: 10px; padding: 15px;">
                                <h4 style="color: #f39c12; margin: 0 0 12px 0; font-size: 16px; text-align: center;">
                                    ${pdfDetails.problems ? 'üéØ Problem Domains' : pdfDetails.approaches ? 'üöÄ Approaches' : '‚ö° Capabilities'}
                                </h4>
                                ${(pdfDetails.problems || pdfDetails.approaches || pdfDetails.capabilities || []).map(item => `
                                    <div style="background: rgba(243, 156, 18, 0.05); padding: 8px; margin-bottom: 8px; border-radius: 6px;">
                                        <p style="margin: 0; color: #cbd5e1; font-size: 12px; line-height: 1.4;">${item}</p>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
            
            contentEl.innerHTML = html;
            skyDetails.style.display = 'block';
            document.getElementById('overlay-panel').classList.remove('active');
        }

        // Standard modal for other planets/moons
        function showStandardModal(moon) {
            const panel = document.getElementById('overlay-panel');
            const title = document.getElementById('panel-title');
            const subtitle = document.getElementById('panel-subtitle');
            const content = document.getElementById('panel-content');

            const moonName = (moon.userData && moon.userData.name) || moon.name || 'Moon';
            const parentName = (moon.userData && moon.userData.parentPlanet && moon.userData.parentPlanet.userData && moon.userData.parentPlanet.userData.name) || '';

            title.textContent = moonName;
            subtitle.textContent = parentName;
            
            // Check if this is a Skills moon and format accordingly
            const pdfDetails = moon.userData.pdfDetails || {};
            if (parentName === 'Skills & Tools' && pdfDetails.skills) {
                // Enhanced Skills Moon Modal
                content.innerHTML = `
                    <div style="padding: 15px;">
                        <div style="background: rgba(56, 189, 248, 0.1); border-radius: 12px; padding: 15px; margin-bottom: 15px;">
                            <h3 style="color: #38bdf8; margin: 0 0 8px 0; font-size: 18px;">${pdfDetails.title}</h3>
                            <p style="color: #94a3b8; margin: 0 0 12px 0; font-size: 14px;">${pdfDetails.description}</p>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 15px;">
                            <h4 style="color: #38bdf8; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center;">
                                <span style="margin-right: 6px;">üõ†Ô∏è</span>
                                Skills & Tools
                            </h4>
                            <div style="display: grid; gap: 6px; max-height: 300px; overflow: hidden;">
                                ${pdfDetails.skills.slice(0, 8).map(skill => `
                                    <div style="display: flex; align-items: center; padding: 6px 10px; background: rgba(56, 189, 248, 0.08); border-radius: 6px; border: 1px solid rgba(56, 189, 248, 0.2);">
                                        <span style="color: #38bdf8; margin-right: 6px; font-size: 12px;">‚Ä¢</span>
                                        <span style="color: #e2e8f0; font-size: 13px; line-height: 1.3;">${skill}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Default modal content
                // robustly obtain a snapshot from the moon texture (canvas or image)
                let imgSrc = '';
                const tex = moon.material && moon.material.map;
                const sourceCanvas = tex && (tex._canvas || tex.image);
                if (sourceCanvas && sourceCanvas.toDataURL) {
                    try { imgSrc = sourceCanvas.toDataURL(); } catch(e) { imgSrc = ''; }
                } else if (tex && tex.image && tex.image.src) {
                    imgSrc = tex.image.src;
                }
                
                const detailsText = moon.userData.moonDetails || moon.userData.details || moon.userData.description || '';
                const imgHtml = imgSrc ? `<img src="${imgSrc}" style="width:100%;border-radius:8px;margin-bottom:12px;display:block">` : '';
                content.innerHTML = `${imgHtml}<div style="white-space:pre-wrap;margin:0;font-family:inherit;color:#dbeafe;font-size:16px;line-height:1.6;">${detailsText}</div>`;
            }

            panel.classList.add('active');
        }

        // Helper functions for language proficiency
        function getProficiencyLevel(details) {
            if (!details) return 'Basic';
            const text = details.toLowerCase();
            if (text.includes('native')) return 'Native';
            if (text.includes('professional') || text.includes('fluent')) return 'Professional';
            if (text.includes('intermediate')) return 'Intermediate';
            return 'Basic';
        }

        // Create 3D Hero Faces
        function createHeroFace(heroName) {
            const heroes = {
                'Einstein': {
                    face: `
                        <div style="position: relative; width: 50px; height: 50px; transform-style: preserve-3d; perspective: 200px;">
                            <!-- Main 3D Container -->
                            <div style="position: relative; width: 100%; height: 100%; border-radius: 50%; transform: rotateX(10deg) rotateY(-5deg); box-shadow: 0 8px 25px rgba(0,0,0,0.4), 0 4px 10px rgba(0,0,0,0.3); transition: transform 0.3s ease;">
                                <!-- Image Layer -->
                                <img src="assets/images/einstien.jpg" alt="Einstein" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%; filter: contrast(1.2) brightness(1.1) saturate(1.2);">
                                
                                <!-- 3D Depth Layers -->
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 50%; background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, transparent 25%, transparent 75%, rgba(0,0,0,0.2) 100%); transform: translateZ(2px);"></div>
                                <div style="position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px; border-radius: 50%; background: linear-gradient(45deg, rgba(255,255,255,0.1) 0%, transparent 50%); transform: translateZ(3px);"></div>
                                
                                <!-- Rim Light Effect -->
                                <div style="position: absolute; top: -3px; left: -3px; right: -3px; bottom: -3px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, rgba(56, 189, 248, 0.4), transparent 70%); transform: translateZ(-1px); filter: blur(2px);"></div>
                            </div>
                        </div>
                    `,
                    animation: '',
                    description: 'Genius of Relativity'
                },
                'Newton': {
                    face: `
                        <div style="position: relative; width: 50px; height: 50px; transform-style: preserve-3d; perspective: 200px;">
                            <!-- Main 3D Container -->
                            <div style="position: relative; width: 100%; height: 100%; border-radius: 50%; transform: rotateX(8deg) rotateY(3deg); box-shadow: 0 8px 25px rgba(0,0,0,0.4), 0 4px 10px rgba(0,0,0,0.3); transition: transform 0.3s ease;">
                                <!-- Image Layer -->
                                <img src="assets/images/newton.jpg" alt="Newton" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%; filter: contrast(1.15) brightness(1.05) saturate(1.1) sepia(0.1);">
                                
                                <!-- 3D Depth Layers -->
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 50%; background: linear-gradient(120deg, rgba(255,255,255,0.25) 0%, transparent 30%, transparent 70%, rgba(0,0,0,0.15) 100%); transform: translateZ(2px);"></div>
                                <div style="position: absolute; top: 1px; left: 1px; right: 1px; bottom: 1px; border-radius: 50%; background: linear-gradient(60deg, rgba(255,255,255,0.15) 0%, transparent 40%); transform: translateZ(3px);"></div>
                                
                                <!-- Rim Light Effect -->
                                <div style="position: absolute; top: -3px; left: -3px; right: -3px; bottom: -3px; border-radius: 50%; background: radial-gradient(circle at 25% 25%, rgba(139, 69, 19, 0.3), transparent 70%); transform: translateZ(-1px); filter: blur(2px);"></div>
                                
                                <!-- Apple Element -->
                                <div style="position: absolute; top: -8px; right: -6px; width: 8px; height: 8px; background: radial-gradient(circle at 30% 30%, #ff4444, #cc2222); border-radius: 50%; transform: translateZ(5px); box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                                    <div style="position: absolute; top: -1px; right: 1px; width: 2px; height: 3px; background: #228B22; border-radius: 50% 50% 50% 0; transform: rotate(45deg);"></div>
                                </div>
                            </div>
                        </div>
                    `,
                    animation: '',
                    description: 'Master of Physics'
                },
                'Gandhi': {
                    face: `
                        <div style="position: relative; width: 50px; height: 50px; transform-style: preserve-3d; perspective: 200px;">
                            <!-- Main 3D Container -->
                            <div style="position: relative; width: 100%; height: 100%; border-radius: 50%; transform: rotateX(5deg) rotateY(-8deg); box-shadow: 0 8px 25px rgba(0,0,0,0.4), 0 4px 10px rgba(0,0,0,0.3); transition: transform 0.3s ease;">
                                <!-- Image Layer -->
                                <img src="assets/images/gandhi.avif" alt="Gandhi" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%; filter: contrast(1.1) brightness(1.08) saturate(1.15) sepia(0.05);">
                                
                                <!-- 3D Depth Layers -->
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 50%; background: linear-gradient(150deg, rgba(255,255,255,0.2) 0%, transparent 35%, transparent 65%, rgba(0,0,0,0.1) 100%); transform: translateZ(2px);"></div>
                                <div style="position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px; border-radius: 50%; background: linear-gradient(30deg, rgba(255,255,255,0.12) 0%, transparent 45%); transform: translateZ(3px);"></div>
                                
                                <!-- Rim Light Effect -->
                                <div style="position: absolute; top: -3px; left: -3px; right: -3px; bottom: -3px; border-radius: 50%; background: radial-gradient(circle at 35% 35%, rgba(212, 175, 55, 0.35), transparent 70%); transform: translateZ(-1px); filter: blur(2px);"></div>
                                
                                <!-- Glasses Reflection -->
                                <div style="position: absolute; top: 15px; left: 8px; width: 12px; height: 8px; background: linear-gradient(45deg, rgba(255,255,255,0.4), transparent 60%); border-radius: 50%; transform: translateZ(4px);"></div>
                                <div style="position: absolute; top: 15px; right: 8px; width: 12px; height: 8px; background: linear-gradient(135deg, rgba(255,255,255,0.4), transparent 60%); border-radius: 50%; transform: translateZ(4px);"></div>
                            </div>
                        </div>
                    `,
                    animation: '',
                    description: 'Apostle of Peace'
                },
                'Buddha': {
                    face: `
                        <div style="position: relative; width: 50px; height: 50px; transform-style: preserve-3d; perspective: 200px;">
                            <!-- Main 3D Container -->
                            <div style="position: relative; width: 100%; height: 100%; border-radius: 50%; transform: rotateX(12deg) rotateY(0deg); box-shadow: 0 10px 30px rgba(255,215,0,0.3), 0 6px 15px rgba(0,0,0,0.4); transition: transform 0.3s ease;">
                                <!-- Image Layer -->
                                <img src="assets/images/buddha.png" alt="Buddha" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%; filter: contrast(1.1) brightness(1.1) saturate(1.3) hue-rotate(10deg);">
                                
                                <!-- 3D Depth Layers -->
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 50%; background: linear-gradient(135deg, rgba(255,215,0,0.2) 0%, transparent 30%, transparent 70%, rgba(255,140,0,0.15) 100%); transform: translateZ(2px);"></div>
                                <div style="position: absolute; top: 1px; left: 1px; right: 1px; bottom: 1px; border-radius: 50%; background: linear-gradient(45deg, rgba(255,255,255,0.2) 0%, transparent 50%); transform: translateZ(3px);"></div>
                                
                                <!-- Divine Aura -->
                                <div style="position: absolute; top: -4px; left: -4px; right: -4px; bottom: -4px; border-radius: 50%; background: radial-gradient(circle, rgba(255,215,0,0.4) 0%, rgba(255,165,0,0.2) 50%, transparent 80%); transform: translateZ(-1px); filter: blur(3px); animation: pulse 3s ease-in-out infinite;"></div>
                                
                                <!-- Third Eye Glow -->
                                <div style="position: absolute; top: 8px; left: 22px; width: 6px; height: 6px; background: radial-gradient(circle, rgba(255,69,0,0.8), rgba(255,140,0,0.4)); border-radius: 50%; transform: translateZ(5px); box-shadow: 0 0 8px rgba(255,69,0,0.6); filter: blur(0.5px);"></div>
                            </div>
                        </div>
                    `,
                    animation: '',
                    description: 'Enlightened One'
                }
            };
            
            return heroes[heroName] || heroes['Einstein'];
        }

        function getCharacterForProficiency(level, language) {
            const characters = {
                'Native': {
                    'Hindi': 'üßô‚Äç‚ôÇÔ∏è', // Wise sage for native Hindi
                    'English': 'üë®‚Äçüî¨', // Albert Einstein-like scientist for native English
                    'default': 'üë®‚Äçüî¨' // Albert Einstein for native level
                },
                'Professional': {
                    'Hindi': 'üë®‚Äçüíº', // Business person
                    'English': 'üï¥Ô∏è', // Professional figure
                    'default': 'üë®‚Äçüíª' // Professional worker
                },
                'Intermediate': {
                    'default': 'üë®‚Äçüéì' // Graduate student
                },
                'Basic': {
                    'default': 'üë∂' // Learning/beginner
                }
            };
            
            return characters[level]?.[language] || characters[level]?.['default'] || 'üë®‚Äçüéì';
        }

        function getAnimationForProficiency(level) {
            const animations = {
                'Native': 'expertGlow 4s ease-in-out',
                'Professional': 'professionalFloat 3s ease-in-out',
                'Intermediate': 'charHover 2s ease-in-out',
                'Basic': 'beginnerWobble 1.5s ease-in-out'
            };
            return animations[level] || 'charBounce 1.5s ease-in-out';
        }

        function getProficiencyBadge(level) {
            const badges = {
                'Native': '‚≠ê',
                'Professional': 'üíº',
                'Intermediate': 'üìö',
                'Basic': 'üå±'
            };
            return badges[level] || 'üìñ';
        }

        function getProficiencyScore(level, skill) {
            const scores = {
                'Native': { speaking: '10', reading: '10', writing: '10', comprehension: '10' },
                'Professional': { speaking: '9', reading: '9', writing: '8', comprehension: '10' },
                'Intermediate': { speaking: '7', reading: '7', writing: '6', comprehension: '8' },
                'Basic': { speaking: '5', reading: '6', writing: '4', comprehension: '6' }
            };
            return scores[level]?.[skill] || '5';
        }

        function getCharacterDescription(level, language) {
            const descriptions = {
                'Native': {
                    'Hindi': 'Master Linguist',
                    'English': 'Einstein-level Expert',
                    'default': 'Einstein-level Expert'
                },
                'Professional': {
                    'Hindi': 'Business Communicator',
                    'English': 'Professional Speaker',
                    'default': 'Fluent Speaker'
                },
                'Intermediate': {
                    'default': 'Learning Scholar'
                },
                'Basic': {
                    'default': 'Language Learner'
                }
            };
            return descriptions[level]?.[language] || descriptions[level]?.['default'] || 'Speaker';
        }

        // Get hero for individual language modals
        function getHeroForLanguage(languageName) {
            const heroMapping = {
                'Hindi': 'Buddha',
                'English': 'Einstein', 
                'Gujarati': 'Gandhi',
                'Marathi': 'Newton'
            };
            return heroMapping[languageName] || 'Einstein';
        }

        // close overlay
        function closeOverlay() {
        	const panel = document.getElementById('overlay-panel');
        	panel.classList.remove('active');
        }

        // === NUR WARS EXPERIENCE ===
        let nurWarsActive = false;
        let battleScene = null;
        let nurWarsCamera = null;
        let nurWarsScene = null;
        let nurWarsObjects = [];
        let nurWarsTimeouts = [];
        let movieTimeoutsPaused = [];
        let moviePaused = false;
        let movieStartTime = 0;
        let moviePauseTime = 0;
        let modelsToLoad = 0;
        let modelsLoaded = 0;
        let battleReady = false;
        
        function setNurWarsTimeout(callback, delay) {
            const id = setTimeout(callback, delay);
            nurWarsTimeouts.push(id);
            return id;
        }
        
        function clearNurWarsTimeouts() {
            nurWarsTimeouts.forEach(clearTimeout);
            nurWarsTimeouts = [];
        }

        window.toggleMoviePlayPause = () => {
            moviePaused = !moviePaused;
            const btn = document.getElementById('movie-play-btn');
            if (moviePaused) {
                btn.textContent = '‚ñ∂Ô∏è Play';
                moviePauseTime = Date.now() - movieStartTime;
                // Pause ALL audio during pause
                if (currentAudio && !currentAudio.paused) {
                    currentAudio.pause();
                }
                // Also pause any synth sounds
                if (audioContext && audioContext.state === 'running') {
                    audioContext.suspend().catch(() => {});
                }
            } else {
                btn.textContent = '‚è∏Ô∏è Pause';
                movieStartTime = Date.now() - moviePauseTime;
                // Resume audio
                if (currentAudio && currentAudio.paused) {
                    currentAudio.play().catch(() => {});
                }
                // Resume synth sounds
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().catch(() => {});
                }
            }
        };

        window.skipMovie = (seconds) => {
            const skipMs = seconds * 1000;
            if (moviePaused) {
                moviePauseTime = Math.max(0, moviePauseTime + skipMs);
            } else {
                movieStartTime -= skipMs; // Move start time back to jump forward/back
            }
            // Skip audio too
            if (currentAudio && !Number.isNaN(currentAudio.currentTime)) {
                const newTime = currentAudio.currentTime + seconds;
                const duration = Number.isFinite(currentAudio.duration) ? currentAudio.duration : null;
                if (duration !== null && duration > 0) {
                    currentAudio.currentTime = Math.min(Math.max(newTime, 0), Math.max(duration - 0.1, 0));
                } else {
                    currentAudio.currentTime = Math.max(newTime, 0);
                }
            }
        };

        function startNurWars() {
            if (nurWarsActive) return;
            
            nurWarsActive = true;
            moviePaused = false;
            movieStartTime = Date.now();
            moviePauseTime = 0;
            renderMode = 'default'; // Start in default mode (solar system view)
            
            // Enable sound automatically for NUR WARS
            if (!soundEnabled) {
                soundEnabled = true;
                document.getElementById('sound-btn').textContent = 'üîä Sound On';
            }
            
            // Update sound button in movie controls
            const nurWarsSoundBtn = document.getElementById('nur-wars-sound-btn');
            if (nurWarsSoundBtn) {
                nurWarsSoundBtn.textContent = soundEnabled ? 'üîä' : 'üîá';
            }
            
            // Reset movie play button
            const moviePlayBtn = document.getElementById('movie-play-btn');
            if (moviePlayBtn) {
                moviePlayBtn.textContent = '‚è∏Ô∏è Pause';
            }
            
            // Stop default solar system sounds and hide UI
            stopCurrentAudio();
            stopCometSounds(); // Stop comet sounds
            // Pause background audio completely during NUR WARS
            if (backgroundAudio) {
                const now = backgroundAudio.audioContext.currentTime;
                try {
                    backgroundAudio.gainNode.gain.cancelScheduledValues(now);
                    backgroundAudio.gainNode.gain.setValueAtTime(0, now);
                } catch(e) { backgroundAudio.gainNode.gain.value = 0; }
            }
            document.body.classList.add('nur-wars-active');
            
            // Show audio controls and exit button for NUR WARS
            const audioControls = document.getElementById('audio-controls');
            if (audioControls) {
                audioControls.style.opacity = '1';
                audioControls.style.pointerEvents = 'auto';
            }
            
            const exitBtn = document.getElementById('exit-hyperspace-btn');
            if (exitBtn) {
                exitBtn.style.display = 'block';
                exitBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    closeNurWars();
                };
            }
            
            // Save current camera state
            const originalCameraPos = camera.position.clone();
            const originalTarget = controls.target.clone();
            
            // Disable main controls during NUR WARS
            controls.enabled = false;
            
            // SILENT PAN: Pan up to see a different area in space, avoiding solar system
            // Move camera upward and shift target away from solar system center
            const panTarget = originalCameraPos.clone().add(new THREE.Vector3(0, 15000, 0));
            const targetShift = originalTarget.clone().add(new THREE.Vector3(0, 15000, 0));
            const panStart = Date.now();
            const panDuration = 2000; // 2 second quick pan
            
            function animatePanToCrawl() {
                const elapsed = Date.now() - panStart;
                const progress = Math.min(elapsed / panDuration, 1);
                const eased = easeInOut(progress);
                
                camera.position.lerpVectors(originalCameraPos, panTarget, eased);
                controls.target.lerpVectors(originalTarget, targetShift, eased);
                
                if (progress < 1) {
                    requestAnimationFrame(animatePanToCrawl);
                } else {
                    // Pan complete, now start the crawl sequence
                    showCrawlSequence(panTarget);
                }
            }
            
            animatePanToCrawl();
        }
        
        function stopCometSounds() {
            // Stop any comet-related audio if it exists
            if (window.cometAudio) {
                window.cometAudio.pause();
                window.cometAudio = null;
            }
        }
        
        function easeInOut(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }
        
        function showCrawlSequence(crawlLocation) {
            // Position camera for crawl view in isolated 3D space far from solar system
            camera.position.copy(crawlLocation);
            camera.rotation.z = 0;
            
            // Expand camera far plane to see more of 3D space
            camera.far = 100000;
            camera.updateProjectionMatrix();
            
            // Get the crawl text element and start 3D animation
            const crawlText = document.getElementById('crawl-text');
            
            // Reset position and styles for 3D effect
            crawlText.style.animation = 'none';
            crawlText.style.transition = 'none';
            crawlText.className = '';
            crawlText.style.position = 'absolute';
            crawlText.style.left = '50%';
            crawlText.style.transformOrigin = '50% 0%';
            crawlText.style.opacity = '1';
            
            // Show crawl overlay first
            const container = document.getElementById('nur-wars-container');
            const crawl = document.getElementById('opening-crawl');
            const battle = document.getElementById('battle-scene');
            
            container.style.display = 'block';
            crawl.style.display = 'block';
            battle.style.display = 'none';
            
            // Track timeline events
            let openingSoundPlayed = false;
            let battleTransitioned = false;
            const crawlStartTime = movieStartTime;
            const totalDuration = 35000; // Total crawl duration - reduced for faster battle start
            
            // Start scroll animation immediately
            start3DCrawlAnimation(crawlText);
            
            // Check for timeline events on every frame
            function checkCrawlTimeline() {
                if (!nurWarsActive) return;
                
                const elapsed = moviePaused ? moviePauseTime : (Date.now() - movieStartTime);
                
                // Play opening sound at 2.8 seconds
                if (!openingSoundPlayed && elapsed >= 2800) {
                    playNurWarsSound('opening');
                    openingSoundPlayed = true;
                }
                
                // Transition to battle when scroll completes (at totalDuration)
                if (!battleTransitioned && elapsed >= totalDuration) {
                    battleTransitioned = true;
                    transitionToBattle(crawlLocation);
                    return; // Stop checking timeline
                }
                
                if (elapsed < totalDuration) {
                    requestAnimationFrame(checkCrawlTimeline);
                }
            }
            
            checkCrawlTimeline();
        }
        
        function start3DCrawlAnimation(element) {
            const totalDuration = 35000; // Reduced to 35s for faster transition to battle
            
            // Start large at bottom, move up and get smaller
            element.style.top = '100vh';
            element.style.willChange = 'transform';
            element.style.opacity = '1';
            
            // Show opening text first
            const openingText = document.getElementById('opening-text');
            const imageContainer = document.getElementById('nurwars-image-container');

            function animateFrame() {
                if (!nurWarsActive) return;
                
                // Get elapsed time respecting pause state
                const elapsed = moviePaused ? moviePauseTime : (Date.now() - movieStartTime);
                const progress = Math.min(elapsed / totalDuration, 1); // Clamp progress to 0-1
                
                // Show opening text for first 2.5 seconds (static, no scroll effect)
                if (elapsed < 2500) {
                    openingText.style.display = 'block';
                    openingText.style.opacity = Math.min(1, elapsed / 500); // Fade in first 500ms
                } else if (elapsed < 3500) {
                    openingText.style.opacity = Math.max(0, 1 - ((elapsed - 2500) / 500)); // Fade out over 500ms
                } else {
                    openingText.style.display = 'none';
                }
                
                // Nur Wars image appears at 3.5 seconds (when music starts) and scrolls with text
                if (elapsed >= 3500 && elapsed < 25000) {
                    imageContainer.style.display = 'block';
                    
                    // Apply same scroll animation to image starting at 3.5 second mark
                    const imageProgress = Math.min((elapsed - 3500) / (totalDuration - 3500), 1);
                    const distance = window.innerHeight * 2;
                    const imageY = -distance * imageProgress;
                    const imageRotation = 60 * imageProgress;
                    const imageScale = 1.0 - (0.95 * imageProgress);
                    const imageZ = -500 * imageProgress;
                    
                    imageContainer.style.transform = `translate(-50%, calc(-50% + ${imageY}px)) rotateX(${imageRotation}deg) scale(${imageScale}) translateZ(${imageZ}px)`;
                } else {
                    imageContainer.style.display = 'none';
                }
                
                // Apply scroll animation to entire text (including image)
                // Constant speed upward motion - linear only
                const distance = window.innerHeight * 2;
                const currentY = -distance * progress;
                
                // Linear rotation to create receding effect
                const rotationAngle = 60 * progress;
                
                // Uniform scale reduction - shrink both width and height proportionally
                const currentScale = 1.0 - (0.95 * progress);
                
                // Z depth for receding effect
                const currentZ = -500 * progress;
                
                element.style.transform = `translateX(-50%) translateY(${currentY}px) rotateX(${rotationAngle}deg) scale(${currentScale}) translateZ(${currentZ}px)`;
                
                // Only continue animation if not finished
                if (elapsed < totalDuration) {
                    requestAnimationFrame(animateFrame);
                }
            }
            
            animateFrame();
        }
        
        function transitionToBattle(currentLocation) {
            // Play battle transition sound
            playNurWarsSound('battle');
            
            // Fade out crawl with slower pan/zoom effect
            const crawl = document.getElementById('opening-crawl');
            crawl.style.animation = 'panZoomToBattle 4s ease-in-out forwards'; 
            
            // Move camera to battle location (closer to solar system) with slower transition
            const battleLocation = new THREE.Vector3(currentLocation.x + 800, currentLocation.y - 150, currentLocation.z - 1200);
            const battleCamPos = new THREE.Vector3(battleLocation.x, battleLocation.y, battleLocation.z + 800);
            
            // Star Wars style pan down transition
            // Start looking straight ahead (where crawl was going)
            const startLookAt = new THREE.Vector3(0, 0, -1000).applyQuaternion(camera.quaternion).add(camera.position);
            // End looking at the battle scene (Death Star location)
            const endLookAt = battleLocation.clone();
            
            const transitionStart = Date.now();
            const transitionDuration = 2000; // 2 seconds quick transition to battle
            
            function animateToBattle() {
                if (!nurWarsActive) return;
                
                const elapsed = Date.now() - transitionStart;
                const progress = Math.min(elapsed / transitionDuration, 1);
                const eased = easeInOut(progress);
                
                // Move camera to battle position
                camera.position.lerpVectors(currentLocation, battleCamPos, eased);
                
                // Pan the camera (look down effect)
                const currentLook = new THREE.Vector3().lerpVectors(startLookAt, endLookAt, eased);
                camera.lookAt(currentLook);
                
                if (progress >= 1) {
                    // Start battle scene
                    crawl.style.display = 'none';
                    crawl.style.animation = 'none';
                    
                    const battle = document.getElementById('battle-scene');
                    battle.style.display = 'block';
                    
                    init3DBattleScene(battleLocation);
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animateToBattle);
                }
            }
            
            animateToBattle();
        }

        function closeNurWars() {
            nurWarsActive = false;
            renderMode = 'default';
            
            // Clear all pending timeouts
            clearNurWarsTimeouts();
            
            const container = document.getElementById('nur-wars-container');
            container.style.display = 'none';
            
            // Hide audio controls and exit button when exiting NUR WARS
            const audioControls = document.getElementById('audio-controls');
            if (audioControls) {
                audioControls.style.opacity = '0';
                audioControls.style.pointerEvents = 'none';
            }
            
            const exitBtn = document.getElementById('exit-hyperspace-btn');
            if (exitBtn) {
                exitBtn.style.display = 'none';
            }
            
            // Restore UI
            document.body.classList.remove('nur-wars-active');
            
            // Stop NUR WARS audio and restore background audio
            stopCurrentAudio();
            if (typeof backgroundAudio !== 'undefined' && backgroundAudio && soundEnabled && backgroundAudio.audioContext.state === 'suspended') {
                backgroundAudio.audioContext.resume().catch(e => console.log('Audio resume failed:', e));
            }
            
            // Restore original camera and controls
            controls.enabled = true;
            
            // Restore main canvas z-index
            const mainCanvas = webGLRenderer.domElement;
            mainCanvas.style.zIndex = '';
            
            // Smooth transition back to original solar system view
            const returnDuration = 3000; // Slower return
            const startTime = Date.now();
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            
            // Reset to overview position
            const targetPos = new THREE.Vector3(0, 200, 800);
            const targetLookAt = new THREE.Vector3(0, 0, 0);
            
            function animateReturn() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / returnDuration, 1);
                const eased = easeInOut(progress);
                
                camera.position.lerpVectors(startPos, targetPos, eased);
                controls.target.lerpVectors(startTarget, targetLookAt, eased);
                camera.rotation.z = 0; // Reset any rotation
                
                if (progress < 1) {
                    requestAnimationFrame(animateReturn);
                } else {
                    // Reload page after battle completes naturally
                    window.location.reload();
                }
            }
            
            animateReturn();
            
            // Reset battle scene variables
            if (battleScene) {
                battleScene = null;
            }
            
            nurWarsCamera = null;
            nurWarsScene = null;
            nurWarsObjects = [];
            battlePhase = 'approach';
            battleTimer = 0;
            explosions = [];
            lasers = [];
            finalExplosionStarted = false;
        }

        // === ENHANCED SOUND SYSTEM FOR NUR WARS ===
        let nurWarsSounds = {};
        let currentAudio = null;
        let audioContext = null;
        
        function initNurWarsSounds() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                nurWarsSounds = {
                    opening: () => playRealStarWarsTheme(),
                    crawl: () => {}, // Continue playing main theme from opening
                    battle: () => playRealBattleMusic(),
                    laser: () => playLaserSound(),
                    explosion: () => playExplosionSound(),
                    victory: () => playVictoryFanfare()
                };
            } catch (e) {
                console.warn('Audio not supported');
            }
        }
        
        function stopCurrentAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            updatePlayPauseButton();
            // Fix backgroundAudio reference error - check if it exists and has pause method
            if (typeof backgroundAudio !== 'undefined' && backgroundAudio && typeof backgroundAudio.pause === 'function') {
                try {
                    backgroundAudio.pause();
                } catch (e) {
                    console.log('Background audio pause failed:', e);
                }
            }
        }
        
        function playRealStarWarsTheme() {
            stopCurrentAudio();
            const audio = new Audio('assets/audio/Star Wars Main Theme.mp3');
            audio.volume = 1.0;
            // Ensure audio plays through user interaction
            audio.play().then(() => {
                currentAudio = audio;
                updatePlayPauseButton();
            }).catch(e => {
                console.warn("Audio play failed, falling back to synth", e);
                playStarWarsTheme();
            });
        }
        
        function playRealImperialMarch() {
            stopCurrentAudio();
            playImperialMarch();
        }
        
        function playRealBattleMusic() {
            stopCurrentAudio();
            const audio = new Audio('assets/audio/Star Wars Battle Background.mp3');
            audio.volume = 0.6;
            audio.loop = true;
            audio.play().then(() => {
                currentAudio = audio;
                updatePlayPauseButton();
            }).catch(e => {
                console.warn("Audio play failed", e);
                playBattleMusic();
            });
        }
        
        function playVictoryFanfare() {
            stopCurrentAudio();
            const audio = new Audio('assets/audio/Epic Star Wars Compilation.mp3');
            audio.currentTime = 952; // 15:52
            audio.volume = 1.0;
            audio.play().then(() => {
                currentAudio = audio;
                updatePlayPauseButton();
            }).catch(e => {
                console.warn("Audio play failed", e);
                playVictoryMusic();
            });
        }
        
        function playStarWarsTheme() {
            if (!audioContext) return;
            
            // Create a rich orchestral-like Star Wars theme
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            masterGain.gain.setValueAtTime(0.4, audioContext.currentTime);
            
            // Main melody (Star Wars theme)
            const melody = [
                {note: 'G4', duration: 0.5, time: 0},
                {note: 'G4', duration: 0.5, time: 0.5},
                {note: 'G4', duration: 0.5, time: 1.0},
                {note: 'C5', duration: 1.5, time: 1.5},
                {note: 'G5', duration: 1.5, time: 3.0},
                {note: 'F5', duration: 0.5, time: 4.5},
                {note: 'E5', duration: 0.5, time: 5.0},
                {note: 'D5', duration: 0.5, time: 5.5},
                {note: 'C6', duration: 1.5, time: 6.0},
                {note: 'G5', duration: 1.0, time: 7.5}
            ];
            
            const noteFreqs = {
                'G4': 392, 'C5': 523.25, 'G5': 783.99, 'F5': 698.46,
                'E5': 659.25, 'D5': 587.33, 'C6': 1046.50
            };
            
            melody.forEach(({note, duration, time}) => {
                // Main oscillator
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(noteFreqs[note], audioContext.currentTime + time);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2000, audioContext.currentTime + time);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime + time);
                gain.gain.linearRampToValueAtTime(0.8, audioContext.currentTime + time + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + time + duration);
                
                osc.start(audioContext.currentTime + time);
                osc.stop(audioContext.currentTime + time + duration);
                
                // Add harmonic
                const harmonic = audioContext.createOscillator();
                const harmonicGain = audioContext.createGain();
                
                harmonic.connect(harmonicGain);
                harmonicGain.connect(masterGain);
                
                harmonic.type = 'sine';
                harmonic.frequency.setValueAtTime(noteFreqs[note] * 2, audioContext.currentTime + time);
                
                harmonicGain.gain.setValueAtTime(0, audioContext.currentTime + time);
                harmonicGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + time + 0.1);
                harmonicGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + time + duration);
                
                harmonic.start(audioContext.currentTime + time);
                harmonic.stop(audioContext.currentTime + time + duration);
            });
        }
        
        function playImperialMarch() {
            if (!audioContext) return;
            
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            masterGain.gain.setValueAtTime(0.3, audioContext.currentTime);
            
            // Imperial March melody
            const march = [
                {note: 'A3', duration: 0.6}, {note: 'A3', duration: 0.6}, {note: 'A3', duration: 0.6},
                {note: 'F3', duration: 0.4}, {note: 'C4', duration: 0.2}, {note: 'A3', duration: 0.6},
                {note: 'F3', duration: 0.4}, {note: 'C4', duration: 0.2}, {note: 'A3', duration: 1.2}
            ];
            
            const noteFreqs = {
                'A3': 220, 'F3': 174.61, 'C4': 261.63
            };
            
            let currentTime = 0;
            
            // Play multiple times for the crawl duration
            for (let repeat = 0; repeat < 12; repeat++) {
                march.forEach(({note, duration}) => {
                    // Bass line
                    const bass = audioContext.createOscillator();
                    const bassGain = audioContext.createGain();
                    const bassFilter = audioContext.createBiquadFilter();
                    
                    bass.connect(bassFilter);
                    bassFilter.connect(bassGain);
                    bassGain.connect(masterGain);
                    
                    bass.type = 'sawtooth';
                    bass.frequency.setValueAtTime(noteFreqs[note], audioContext.currentTime + currentTime);
                    
                    bassFilter.type = 'lowpass';
                    bassFilter.frequency.setValueAtTime(800, audioContext.currentTime + currentTime);
                    
                    bassGain.gain.setValueAtTime(0, audioContext.currentTime + currentTime);
                    bassGain.gain.linearRampToValueAtTime(0.6, audioContext.currentTime + currentTime + 0.05);
                    bassGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + currentTime + duration);
                    
                    bass.start(audioContext.currentTime + currentTime);
                    bass.stop(audioContext.currentTime + currentTime + duration);
                    
                    // Add octave for richness
                    const octave = audioContext.createOscillator();
                    const octaveGain = audioContext.createGain();
                    
                    octave.connect(octaveGain);
                    octaveGain.connect(masterGain);
                    
                    octave.type = 'triangle';
                    octave.frequency.setValueAtTime(noteFreqs[note] * 2, audioContext.currentTime + currentTime);
                    
                    octaveGain.gain.setValueAtTime(0, audioContext.currentTime + currentTime);
                    octaveGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + currentTime + 0.05);
                    octaveGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + currentTime + duration);
                    
                    octave.start(audioContext.currentTime + currentTime);
                    octave.stop(audioContext.currentTime + currentTime + duration);
                    
                    currentTime += duration;
                });
                currentTime += 0.5; // Pause between repeats
            }
        }
        
        function playBattleMusic() {
            if (!audioContext) return;
            
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            masterGain.gain.setValueAtTime(0.25, audioContext.currentTime);
            
            // Create intense battle rhythm
            for (let i = 0; i < 4; i++) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(110 + i * 27.5, audioContext.currentTime);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1500 + i * 200, audioContext.currentTime);
                
                // Create rhythmic pattern
                let time = audioContext.currentTime;
                for (let j = 0; j < 300; j++) {
                    const intensity = 0.3 + Math.sin(j * 0.1) * 0.2;
                    gain.gain.setValueAtTime(intensity, time);
                    gain.gain.setValueAtTime(0.05, time + 0.08);
                    time += 0.15;
                }
                
                osc.start();
                setTimeout(() => osc.stop(), 45000);
            }
        }
        
        function playVictoryMusic() {
            if (!audioContext) return;
            
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            masterGain.gain.setValueAtTime(0.5, audioContext.currentTime);
            
            // Victory fanfare melody
            const victory = [
                {note: 'C5', duration: 0.8, time: 0},
                {note: 'G5', duration: 0.8, time: 0.8},
                {note: 'C6', duration: 1.2, time: 1.6},
                {note: 'G5', duration: 0.6, time: 2.8},
                {note: 'C6', duration: 1.5, time: 3.4}
            ];
            
            const noteFreqs = {
                'C5': 523.25, 'G5': 783.99, 'C6': 1046.50
            };
            
            victory.forEach(({note, duration, time}) => {
                // Main trumpet-like sound
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(noteFreqs[note], audioContext.currentTime + time);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(3000, audioContext.currentTime + time);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime + time);
                gain.gain.linearRampToValueAtTime(0.9, audioContext.currentTime + time + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + time + duration);
                
                osc.start(audioContext.currentTime + time);
                osc.stop(audioContext.currentTime + time + duration);
            });
        }
        
        function playLaserSound() {
            if (!audioContext) return;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(1200, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.3);
            
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(2000, audioContext.currentTime);
            filter.Q.setValueAtTime(5, audioContext.currentTime);
            
            gain.gain.setValueAtTime(0.4, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
        }
        
        function playExplosionSound() {
            if (!audioContext) return;
            
            // Create realistic explosion with multiple components
            const bufferSize = audioContext.sampleRate * 4;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            // Generate explosion noise
            for (let i = 0; i < bufferSize; i++) {
                const decay = Math.pow(1 - i / bufferSize, 1.5);
                data[i] = (Math.random() * 2 - 1) * decay;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            const compressor = audioContext.createDynamicsCompressor();
            
            noise.connect(filter);
            filter.connect(compressor);
            compressor.connect(gain);
            gain.connect(audioContext.destination);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(3000, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 3);
            
            gain.gain.setValueAtTime(0.6, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 4);
            
            noise.start();
        }
        
        function playNurWarsSound(soundName) {
            if (soundEnabled && nurWarsSounds[soundName]) {
                try {
                    nurWarsSounds[soundName]();
                } catch (e) {
                    console.warn('Could not play sound:', soundName);
                }
            }
        }
        
        // Battle scene creation functions
        function createDeathStar(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            modelsToLoad++;
            
            // Load Death Star GLTF model
            gltfLoader.load(
                'assets/models/death_star_-_star_wars/scene.gltf',
                (gltf) => {
                    const deathStar = gltf.scene;
                    deathStar.scale.set(150, 150, 150);
                    deathStar.position.copy(battleLocation);
                    deathStar.rotation.y = Math.PI / 4;
                    
                    battleSceneRef.add(deathStar);
                    nurWarsObjects.push({ 
                        object: deathStar, 
                        type: 'deathstar' 
                    });
                    
                    modelsLoaded++;
                    console.log('Death Star loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Death Star:', error);
                    modelsLoaded++;
                    checkBattleReady();
                    // Fallback to procedural geometry
                    const deathStarGeo = new THREE.SphereGeometry(300, 32, 32);
                    const deathStarMat = new THREE.MeshStandardMaterial({ 
                        color: 0x333333, 
                        metalness: 0.8, 
                        roughness: 0.3 
                    });
                    const deathStar = new THREE.Mesh(deathStarGeo, deathStarMat);
                    deathStar.position.copy(battleLocation);
                    battleSceneRef.add(deathStar);
                    nurWarsObjects.push({ 
                        object: deathStar, 
                        type: 'deathstar' 
                    });
                }
            );
        }
        
        function createStarDestroyer(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            modelsToLoad++;
            
            // Load Star Destroyer GLTF model
            gltfLoader.load(
                'assets/models/republic_venator_star_destroyer/scene.gltf',
                (gltf) => {
                    const destroyer = gltf.scene;
                    destroyer.scale.set(0.8, 0.8, 0.8);
                    destroyer.position.set(
                        battleLocation.x - 800,
                        battleLocation.y + 200,
                        battleLocation.z + 500
                    );
                    destroyer.rotation.y = -Math.PI / 4;
                    destroyer.rotation.z = Math.PI / 12;
                    
                    battleSceneRef.add(destroyer);
                    nurWarsObjects.push({ 
                        object: destroyer, 
                        type: 'destroyer',
                        isCapitalShip: true
                    });

                    modelsLoaded++;
                    console.log('Star Destroyer loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Star Destroyer:', error);
                    modelsLoaded++;
                    checkBattleReady();
                    // Fallback
                    const destroyerGroup = new THREE.Group();
                    const hullGeo = new THREE.ConeGeometry(150, 600, 4);
                    const hullMat = new THREE.MeshStandardMaterial({ 
                        color: 0x444444, 
                        metalness: 0.9, 
                        roughness: 0.2 
                    });
                    const hull = new THREE.Mesh(hullGeo, hullMat);
                    hull.rotation.z = Math.PI / 2;
                    destroyerGroup.add(hull);
                    destroyerGroup.position.set(
                        battleLocation.x - 800,
                        battleLocation.y + 200,
                        battleLocation.z + 500
                    );
                    battleSceneRef.add(destroyerGroup);
                    nurWarsObjects.push({ 
                        object: destroyerGroup, 
                        type: 'destroyer',
                        isCapitalShip: true
                    });
                }
            );
        }
        
        function createMillenniumFalcon(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            modelsToLoad++;
            
            // Load Millennium Falcon GLTF model
            gltfLoader.load(
                'assets/models/star_wars_-_halcon_milenario/scene.gltf',
                (gltf) => {
                    const falcon = gltf.scene;
                    falcon.scale.set(25, 25, 25);
                    falcon.position.set(
                        battleLocation.x + 400,
                        battleLocation.y - 100,
                        battleLocation.z - 600
                    );
                    falcon.rotation.y = Math.PI / 6;
                    
                    battleSceneRef.add(falcon);
                    nurWarsObjects.push({ 
                        object: falcon, 
                        type: 'falcon' 
                    });
                    
                    modelsLoaded++;
                    console.log('Millennium Falcon loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Millennium Falcon:', error);
                    modelsLoaded++;
                    checkBattleReady();
                }
            );
        }
        
        function createXWings(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            
            // Create 2 X-Wings using GLTF models
            for (let i = 0; i < 2; i++) {
                modelsToLoad++;
                gltfLoader.load(
                    'assets/models/x-wing_cockpit_version_3/scene.gltf',
                    (gltf) => {
                        const xwing = gltf.scene.clone();
                        xwing.scale.set(12, 12, 12);
                        xwing.position.set(
                            battleLocation.x + (i === 0 ? 200 : 350),
                            battleLocation.y - 200,
                            battleLocation.z - 400
                        );
                        xwing.rotation.y = Math.PI / 8;
                        
                        battleSceneRef.add(xwing);
                        nurWarsObjects.push({
                            object: xwing,
                            type: 'xwing',
                            isPlayer: i === 0,
                            health: 100,
                            velocity: new THREE.Vector3(0, 0, -3),
                            target: null
                        });
                        
                        modelsLoaded++;
                        console.log(`X-Wing ${i+1} loaded`, modelsLoaded, '/', modelsToLoad);
                        checkBattleReady();
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading X-Wing:', error);
                        modelsLoaded++;
                        checkBattleReady();
                    }
                );
            }
            
            // Add Anakin's Interceptor
            modelsToLoad++;
            gltfLoader.load(
                'assets/models/swbf2custom_-_anakins_eta-2_actis_interceptor/scene.gltf',
                (gltf) => {
                    const interceptor = gltf.scene;
                    interceptor.scale.set(15, 15, 15);
                    interceptor.position.set(
                        battleLocation.x + 150,
                        battleLocation.y - 150,
                        battleLocation.z - 500
                    );
                    interceptor.rotation.y = Math.PI / 6;
                    
                    battleSceneRef.add(interceptor);
                    nurWarsObjects.push({
                        object: interceptor,
                        type: 'interceptor',
                        isPlayer: false,
                        health: 120,
                        velocity: new THREE.Vector3(0, 0, -3.5),
                        target: null
                    });
                    
                    modelsLoaded++;
                    console.log('Interceptor loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Interceptor:', error);
                    modelsLoaded++;
                    checkBattleReady();
                }
            );
        }
        
        function createTIEFighters(battleLocation) {
            const battleSceneRef = nurWarsScene || scene;
            
            // Create 3 TIE Fighters using GLTF models
            for (let i = 0; i < 3; i++) {
                modelsToLoad++;
                gltfLoader.load(
                    'assets/models/3d_t.i.e_fighter_-_star_wars_model/scene.gltf',
                    (gltf) => {
                        const tie = gltf.scene.clone();
                        tie.scale.set(8, 8, 8);
                        tie.position.set(
                            battleLocation.x + (i - 1) * 300 - 500,
                            battleLocation.y + (Math.random() - 0.5) * 200,
                            battleLocation.z + 400
                        );
                        tie.rotation.y = Math.PI + Math.PI / 6;
                        
                        battleSceneRef.add(tie);
                        nurWarsObjects.push({
                            object: tie,
                            type: 'tiefighter',
                            health: 50,
                            velocity: new THREE.Vector3(
                                (Math.random() - 0.5) * 3,
                                (Math.random() - 0.5) * 2,
                                Math.random() * 2 + 1
                            )
                        });
                        
                        modelsLoaded++;
                        console.log(`TIE Fighter ${i+1} loaded`, modelsLoaded, '/', modelsToLoad);
                        checkBattleReady();
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading TIE Fighter:', error);
                        modelsLoaded++;
                        checkBattleReady();
                    }
                );
            }
            
            // Add Phantom ship as an enemy
            modelsToLoad++;
            gltfLoader.load(
                'assets/models/phantom/scene.gltf',
                (gltf) => {
                    const phantom = gltf.scene;
                    phantom.scale.set(10, 10, 10);
                    phantom.position.set(
                        battleLocation.x - 400,
                        battleLocation.y + 80,
                        battleLocation.z + 350
                    );
                    phantom.rotation.y = Math.PI + Math.PI / 4;
                    
                    battleSceneRef.add(phantom);
                    nurWarsObjects.push({
                        object: phantom,
                        type: 'phantom',
                        health: 80,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 2.5,
                            (Math.random() - 0.5) * 2,
                            Math.random() * 2.5 + 0.5
                        )
                    });
                    
                    modelsLoaded++;
                    console.log('Phantom loaded', modelsLoaded, '/', modelsToLoad);
                    checkBattleReady();
                },
                undefined,
                (error) => {
                    console.error('Error loading Phantom:', error);
                    modelsLoaded++;
                    checkBattleReady();
                }
            );
        }
        
        initNurWarsSounds();
        
        function checkBattleReady() {
            if (modelsLoaded >= modelsToLoad && !battleReady) {
                battleReady = true;
                console.log('All models loaded! Battle ready with', nurWarsObjects.length, 'objects');
            }
        }

        function init3DBattleScene(battleLocation) {
            // Reset loading counters
            modelsToLoad = 0;
            modelsLoaded = 0;
            battleReady = false;
            
            // Create 3D scene FIRST before calling create functions
            nurWarsScene = new THREE.Scene();
            nurWarsScene.background = new THREE.Color(0x000000);
            
            // Switch to battle render mode
            renderMode = 'battle';
            
            // Use existing camera
            nurWarsCamera = camera; // Use the main camera
            
            // Set fallback camera position immediately
            nurWarsCamera.position.set(
                battleLocation.x,
                battleLocation.y + 200,
                battleLocation.z + 800
            );
            nurWarsCamera.lookAt(battleLocation);
            
            // Add both starfields from main scene to battle
            scene.children.forEach(child => {
                if (child.type === 'Points') {
                    const battleStarfield = child.clone();
                    nurWarsScene.add(battleStarfield);
                }
            });
            
            // NOW create all battle objects - they will be added to nurWarsScene
            // Create Death Star
            createDeathStar(battleLocation);
            
            // Create Imperial Star Destroyer
            createStarDestroyer(battleLocation);
            
            // Create Millennium Falcon
            createMillenniumFalcon(battleLocation);
            
            // Create X-Wings
            createXWings(battleLocation);
            
            // Create TIE Fighters
            createTIEFighters(battleLocation);

            // Wait for models to load before adjusting camera
            const waitForModels = setInterval(() => {
                if (battleReady && nurWarsObjects.length > 0) {
                    clearInterval(waitForModels);
                    console.log('Adjusting camera for', nurWarsObjects.length, 'loaded objects');
                    
                    // Frame the battle so all ships are visible
                    const allShips = nurWarsObjects.filter(obj => 
                        obj.type === 'xwing' || obj.type === 'tiefighter' || 
                        obj.type === 'falcon' || obj.type === 'interceptor' || obj.type === 'phantom'
                    );
                    
                    if (allShips.length > 0) {
                        const focusCenter = new THREE.Vector3();
                        const tempPos = new THREE.Vector3();
                        allShips.forEach(obj => {
                            obj.object.getWorldPosition(tempPos);
                            focusCenter.add(tempPos);
                        });
                        focusCenter.multiplyScalar(1 / allShips.length);
                        console.log('Camera focusing on center:', focusCenter);
                        
                        nurWarsCamera.position.copy(focusCenter).add(new THREE.Vector3(0, 300, 1000));
                        nurWarsCamera.lookAt(focusCenter);
                    }
                }
            }, 100);
            
            // Add lighting for battle
            const battleAmbient = new THREE.AmbientLight(0xffffff, 0.8);
            nurWarsScene.add(battleAmbient);
            
            const battleLight = new THREE.DirectionalLight(0xffffff, 1.5);
            battleLight.position.set(100, 200, 300);
            nurWarsScene.add(battleLight);
            
            const battleLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            battleLight2.position.set(-100, -100, 200);
            nurWarsScene.add(battleLight2);
            
            function buildProceduralTIEFighter() {
                const tieGroup = new THREE.Group();

                // Cockpit ball - more detailed hexagonal sphere
                const cockpitGeometry = new THREE.SphereGeometry(10, 12, 12);
                const cockpitMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    metalness: 0.8,
                    roughness: 0.3
                });
                const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
                tieGroup.add(cockpit);

                // Viewport windows
                const windowGeometry = new THREE.CircleGeometry(4, 8);
                const windowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x88aaff,
                    transparent: true,
                    opacity: 0.3
                });

                // Front window
                const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                frontWindow.position.z = 10;
                tieGroup.add(frontWindow);

                // Back window
                const backWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                backWindow.position.z = -10;
                backWindow.rotation.y = Math.PI;
                tieGroup.add(backWindow);

                // Hexagonal solar panels - more detailed
                const panelShape = new THREE.Shape();
                const hexRadius = 35;
                for (let j = 0; j < 6; j++) {
                    const angle = j * Math.PI / 3;
                    panelShape.lineTo(Math.cos(angle) * hexRadius, Math.sin(angle) * hexRadius);
                }
                panelShape.closePath();

                const extrudeSettings = { depth: 2, bevelEnabled: false };
                const panelGeometry = new THREE.ExtrudeGeometry(panelShape, extrudeSettings);
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    metalness: 0.9,
                    roughness: 0.4,
                    side: THREE.DoubleSide
                });

                // Left solar panel
                const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                leftPanel.position.x = -18;
                leftPanel.rotation.y = Math.PI / 2;
                tieGroup.add(leftPanel);

                // Panel frame (left)
                const frameGeometry = new THREE.TorusGeometry(35, 1.5, 6, 6);
                const frameMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444444,
                    metalness: 0.8,
                    roughness: 0.3
                });
                const leftFrame = new THREE.Mesh(frameGeometry, frameMaterial);
                leftFrame.position.x = -18;
                leftFrame.rotation.y = Math.PI / 2;
                tieGroup.add(leftFrame);

                // Right solar panel
                const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                rightPanel.position.x = 18;
                rightPanel.rotation.y = Math.PI / 2;
                tieGroup.add(rightPanel);

                // Panel frame (right)
                const rightFrame = new THREE.Mesh(frameGeometry, frameMaterial);
                rightFrame.position.x = 18;
                rightFrame.rotation.y = Math.PI / 2;
                tieGroup.add(rightFrame);

                // Connecting struts
                const strutGeometry = new THREE.CylinderGeometry(1.5, 1.5, 16, 8);
                const strutMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x666666,
                    metalness: 0.7,
                    roughness: 0.4
                });

                const leftStrut = new THREE.Mesh(strutGeometry, strutMaterial);
                leftStrut.position.x = -9;
                leftStrut.rotation.z = Math.PI / 2;
                tieGroup.add(leftStrut);

                const rightStrut = new THREE.Mesh(strutGeometry, strutMaterial);
                rightStrut.position.x = 9;
                rightStrut.rotation.z = Math.PI / 2;
                tieGroup.add(rightStrut);

                return tieGroup;
            }
        }



        let battlePhase = 'approach';
        let battleTimer = 0;
        let explosions = [];
        let cameraTarget = new THREE.Vector3();
        let finalExplosionStarted = false;

        function updateBattleLogic() {
            if (!nurWarsActive || moviePaused || !battleReady) return;
            
            battleTimer++;
            
            // Update battle phases - much longer duration for better cinematic experience
            if (battlePhase === 'approach' && battleTimer > 900) { // Much longer approach
                battlePhase = 'battle';
            }
            
            // Dynamic camera movement for cinematic effect - closer and more dramatic
            if (battlePhase === 'approach') {
                // Wide establishing shot of the fleet approaching
                const xwings = nurWarsObjects.filter(obj => obj.type === 'xwing' || obj.type === 'interceptor');
                if (xwings.length === 0) return;
                const avgPos = new THREE.Vector3(0, 0, 0);
                xwings.forEach(xw => {
                    avgPos.add(xw.object.position);
                });
                avgPos.divideScalar(xwings.length);
                
                const cameraPos = avgPos.clone();
                cameraPos.z += 400;
                cameraPos.y += 150;
                cameraPos.x += 100;
                
                nurWarsCamera.position.lerp(cameraPos, 0.02);
                nurWarsCamera.lookAt(avgPos);
            } else if (battlePhase === 'battle') {
                // Multiple dynamic camera cuts for epic battle feel
                const cyclePhase = (battleTimer % 300) / 300; // 5 second cycles
                const deathStar = nurWarsObjects.find(obj => obj.type === 'deathstar');
                const playerXWing = nurWarsObjects.find(obj => obj.type === 'xwing' && obj.isPlayer);
                const falcon = nurWarsObjects.find(obj => obj.type === 'falcon');
                
                let cameraPos = new THREE.Vector3();
                let lookTarget = new THREE.Vector3();
                
                if (cyclePhase < 0.25 && playerXWing && deathStar) {
                    // Close follow on player X-Wing
                    cameraPos = playerXWing.object.position.clone();
                    cameraPos.z += 100;
                    cameraPos.y += 40;
                    lookTarget = deathStar.object.position.clone();
                } else if (cyclePhase < 0.5) {
                    // Wide shot of Millennium Falcon leading the assault
                    if (falcon && deathStar) {
                        cameraPos = falcon.object.position.clone();
                        cameraPos.z += 150;
                        cameraPos.y += 80;
                        lookTarget = deathStar.object.position.clone();
                    } else if (deathStar) {
                        cameraPos = deathStar.object.position.clone().add(new THREE.Vector3(400, 300, 400));
                        lookTarget = deathStar.object.position.clone();
                    }
                } else if (cyclePhase < 0.75 && playerXWing && deathStar) {
                    // Death Star approach shot
                    cameraPos = playerXWing.object.position.clone();
                    cameraPos.z -= 50; // In front
                    cameraPos.y += 60;
                    lookTarget = deathStar.object.position.clone();
                } else if (deathStar) {
                    // Dynamic action shot - rotating around battle
                    const angle = battleTimer * 0.005;
                    const distance = 400;
                    cameraPos = deathStar.object.position.clone();
                    cameraPos.x += Math.cos(angle) * distance;
                    cameraPos.z += Math.sin(angle) * distance;
                    cameraPos.y += 200;
                    lookTarget = deathStar.object.position.clone();
                }
                
                if (cameraPos.length() > 0) {
                    nurWarsCamera.position.lerp(cameraPos, 0.05);
                    nurWarsCamera.lookAt(lookTarget);
                }
            }
            
            // Update X-Wings with more aggressive behavior
            nurWarsObjects.filter(obj => obj.type === 'xwing').forEach(xwing => {
                if (xwing.health <= 0) return;
                
                if (battlePhase === 'approach') {
                    xwing.object.position.add(xwing.velocity);
                } else if (battlePhase === 'battle') {
                    if (xwing.isPlayer) {
                        // Nur's X-Wing targets the exhaust port with more dramatic approach
                        const deathStar = nurWarsObjects.find(obj => obj.type === 'deathstar');
                        if (deathStar && deathStar.exhaustPort) {
                            const target = deathStar.exhaustPort.position;
                            const direction = target.clone().sub(xwing.object.position).normalize();
                            xwing.object.position.add(direction.multiplyScalar(2.5)); // Slightly faster
                            
                            // Look at target
                            xwing.object.lookAt(target);
                            
                            // Fire lasers much more frequently for intense battle
                            if (battleTimer % 15 === 0) {
                                createLaser(xwing.object.position.clone(), direction.clone(), 0x00ff00, true);
                            }
                        }
                    } else {
                        // Other X-Wings engage TIE fighters more aggressively
                        xwing.object.position.add(xwing.velocity);
                        
                        // Fire at TIE fighters more frequently
                        if (battleTimer % 25 === Math.floor(Math.random() * 25)) {
                            const ties = nurWarsObjects.filter(obj => obj.type === 'tiefighter' && obj.health > 0);
                            if (ties.length > 0) {
                                const target = ties[Math.floor(Math.random() * ties.length)];
                                const direction = target.object.position.clone().sub(xwing.object.position).normalize();
                                createLaser(xwing.object.position.clone(), direction, 0x00ff00, false);
                            }
                        }
                    }
                }
            });
            
            // Update TIE Fighters with more aggressive behavior
            nurWarsObjects.filter(obj => obj.type === 'tiefighter').forEach(tie => {
                if (tie.health <= 0) return;
                
                tie.object.position.add(tie.velocity);
                tie.object.rotation.y += 0.15; // Faster rotation for more dynamic look
                
                // Keep in bounds
                if (Math.abs(tie.object.position.x) > 1500) tie.velocity.x *= -1;
                if (Math.abs(tie.object.position.y) > 500) tie.velocity.y *= -1;
                
                // Fire at X-Wings much more frequently for intense battle
                if (battleTimer % 35 === Math.floor(Math.random() * 35)) {
                    const xwings = nurWarsObjects.filter(obj => obj.type === 'xwing' && obj.health > 0);
                    if (xwings.length > 0) {
                        const target = xwings[Math.floor(Math.random() * xwings.length)];
                        const direction = target.object.position.clone().sub(tie.object.position).normalize();
                        createLaser(tie.object.position.clone(), direction, 0xff0000, false);
                    }
                }
            });
            
            // Update lasers
            updateLasers();
            
            // Update explosions
            updateExplosions();
            
            // Check for victory condition
            const deathStar = nurWarsObjects.find(obj => obj.type === 'deathstar');
            if (!deathStar && battlePhase !== 'victory') {
                battlePhase = 'victory';
                showVictoryMessage();
            }
            
            // Auto-close after much longer victory sequence
            if (battlePhase === 'victory' && battleTimer > 18000) { // Much longer victory sequence
                closeNurWars();
                return;
            }
        }

        function createLaser(position, direction, color, isPlayerShot) {
            const laserGeometry = new THREE.CylinderGeometry(0.5, 0.5, 20);
            const laserMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                emissive: color,
                transparent: true,
                opacity: 0.8
            });
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            laser.position.copy(position);
            laser.lookAt(position.clone().add(direction));
            laser.rotateX(Math.PI / 2);
            
            nurWarsScene.add(laser);
            lasers.push({
                object: laser,
                velocity: direction.multiplyScalar(15),
                life: 100,
                isPlayerShot: isPlayerShot
            });
            
            // Play laser sound
            playNurWarsSound('laser');
        }

        function updateLasers() {
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                laser.object.position.add(laser.velocity);
                laser.life--;
                
                // Check collisions
                if (laser.isPlayerShot) {
                    const deathStar = nurWarsObjects.find(obj => obj.type === 'deathstar');
                    if (deathStar && deathStar.exhaustPort) {
                        const distance = laser.object.position.distanceTo(deathStar.exhaustPort.position);
                        if (distance < 20) {
                            // Death Star hit! - Cinematic destruction sequence
                            startDeathStarDestruction(deathStar);
                            
                            // Remove laser
                            nurWarsScene.remove(laser.object);
                            lasers.splice(i, 1);
                            continue;
                        }
                    }
                }
                
                // Remove old lasers
                if (laser.life <= 0) {
                    nurWarsScene.remove(laser.object);
                    lasers.splice(i, 1);
                }
            }
        }

        function startDeathStarDestruction(deathStar) {
            if (finalExplosionStarted) return;
            finalExplosionStarted = true;
            
            // Zoom camera much closer to Death Star for ultra-dramatic effect
            const deathStarPos = deathStar.object.position.clone();
            
            // Create multiple explosion stages with much closer camera work
            setTimeout(() => {
                // First explosion at exhaust port - zoom in immediately
                createExplosion(deathStar.exhaustPort.position.clone(), 120);
                
                // Zoom camera much closer for intense destruction view
                const ultraClosePos = deathStarPos.clone();
                ultraClosePos.z += 250; // Much closer than before
                ultraClosePos.y += 80;
                ultraClosePos.x += 50; // Slight angle for better view
                
                const zoomDuration = 1500; // Faster zoom
                const startTime = Date.now();
                const startCameraPos = nurWarsCamera.position.clone();
                
                function zoomToDeathStar() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / zoomDuration, 1);
                    
                    nurWarsCamera.position.lerpVectors(startCameraPos, ultraClosePos, progress);
                    
                    // Look directly at the destruction point
                    const lookTarget = deathStar.exhaustPort.position.clone();
                    nurWarsCamera.lookAt(lookTarget);
                    
                    if (progress < 1) {
                        requestAnimationFrame(zoomToDeathStar);
                    }
                }
                zoomToDeathStar();
                
            }, 300);
            
            setTimeout(() => {
                // Secondary explosions - more dramatic and visible
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const explosionPos = deathStarPos.clone();
                        explosionPos.x += (Math.random() - 0.5) * 400;
                        explosionPos.y += (Math.random() - 0.5) * 400;
                        explosionPos.z += (Math.random() - 0.5) * 400;
                        createExplosion(explosionPos, 200 + Math.random() * 150);
                        
                        // Create additional smaller explosions for detail
                        for (let j = 0; j < 3; j++) {
                            setTimeout(() => {
                                const smallExplosionPos = explosionPos.clone();
                                smallExplosionPos.x += (Math.random() - 0.5) * 100;
                                smallExplosionPos.y += (Math.random() - 0.5) * 100;
                                smallExplosionPos.z += (Math.random() - 0.5) * 100;
                                createExplosion(smallExplosionPos, 80 + Math.random() * 60);
                            }, j * 150);
                        }
                    }, i * 200);
                }
            }, 1000);
            
            setTimeout(() => {
                // Final massive explosion - ultra close and dramatic
                createExplosion(deathStarPos, 1200); // Much larger explosion
                
                // Add shockwave ring
                const ringGeo = new THREE.RingGeometry(10, 20, 64);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffaa00, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const shockwave = new THREE.Mesh(ringGeo, ringMat);
                shockwave.position.copy(deathStarPos);
                shockwave.lookAt(nurWarsCamera.position);
                nurWarsScene.add(shockwave);
                
                // Animate shockwave in updateExplosions or separate logic
                explosions.push({
                    object: shockwave,
                    type: 'shockwave',
                    maxSize: 80, // Scale factor
                    currentSize: 1,
                    life: 100,
                    maxLife: 100
                });
                
                // Create ring of explosions around Death Star
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const ringPos = deathStarPos.clone();
                    ringPos.x += Math.cos(angle) * 300;
                    ringPos.y += Math.sin(angle) * 300;
                    createExplosion(ringPos, 300 + Math.random() * 200);
                }
                
                // Remove Death Star objects
                nurWarsScene.remove(deathStar.object);
                nurWarsScene.remove(deathStar.exhaustPort);
                nurWarsObjects.splice(nurWarsObjects.indexOf(deathStar), 1);
                
                // Intense camera shake effect
                const originalPos = nurWarsCamera.position.clone();
                let shakeTimer = 0;
                const shakeIntensity = 40; // Much more intense shake
                
                function cameraShake() {
                    if (shakeTimer < 90) { // Longer shake
                        nurWarsCamera.position.x = originalPos.x + (Math.random() - 0.5) * shakeIntensity;
                        nurWarsCamera.position.y = originalPos.y + (Math.random() - 0.5) * shakeIntensity;
                        nurWarsCamera.position.z = originalPos.z + (Math.random() - 0.5) * shakeIntensity;
                        shakeTimer++;
                        requestAnimationFrame(cameraShake);
                    } else {
                        // Pull back camera for victory view
                        const victoryPos = originalPos.clone();
                        victoryPos.z += 500;
                        victoryPos.y += 200;
                        
                        const pullBackDuration = 3000;
                        const pullBackStart = Date.now();
                        
                        function pullBackCamera() {
                            const elapsed = Date.now() - pullBackStart;
                            const progress = Math.min(elapsed / pullBackDuration, 1);
                            
                            nurWarsCamera.position.lerpVectors(originalPos, victoryPos, progress);
                            nurWarsCamera.lookAt(deathStarPos); // Look at explosion site
                            
                            if (progress < 1) {
                                requestAnimationFrame(pullBackCamera);
                            }
                        }
                        pullBackCamera();
                    }
                }
                cameraShake();
                
            }, 2500);
        }

        function createExplosion(position, maxSize) {
            const explosionGeometry = new THREE.SphereGeometry(1, 16, 16);
            const explosionMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff6600,
                transparent: true,
                opacity: 1
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(position);
            
            nurWarsScene.add(explosion);
            explosions.push({
                object: explosion,
                maxSize: maxSize,
                currentSize: 1,
                life: 120,
                maxLife: 120
            });
            
            // Play explosion sound
            playNurWarsSound('explosion');
        }

        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.life--;
                
                if (explosion.type === 'shockwave') {
                    explosion.currentSize += 1.5;
                    explosion.object.scale.setScalar(explosion.currentSize);
                    explosion.object.material.opacity = explosion.life / explosion.maxLife;
                } else {
                // Grow explosion
                if (explosion.currentSize < explosion.maxSize) {
                    explosion.currentSize += explosion.maxSize / 60;
                    explosion.object.scale.setScalar(explosion.currentSize);
                }
                
                // Fade out
                const alpha = explosion.life / explosion.maxLife;
                explosion.object.material.opacity = alpha;
                
                // Change color over time
                const hue = (1 - alpha) * 0.1; // From red to yellow
                explosion.object.material.color.setHSL(hue, 1, 0.5);
                }
                
                // Remove old explosions
                if (explosion.life <= 0) {
                    nurWarsScene.remove(explosion.object);
                    explosions.splice(i, 1);
                }
            }
        }

        function showVictoryMessage() {
            // Play victory fanfare with conclusion theme
            playNurWarsSound('victory');
            
            // Create enhanced 3D text for victory message
            setTimeout(() => {
                const battleHud = document.getElementById('battle-hud');
                battleHud.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 30px; text-shadow: 0 0 40px #FFD700; animation: pulse 2s infinite; color: #FFD700; font-weight: 900;">THE LEGACY SYSTEM IS DESTROYED!</div>
                    <div style="font-size: 32px; margin-bottom: 25px; color: #87CEEB; text-shadow: 0 0 20px #87CEEB;">NUR DAWOODANI HAS SAVED THE GALAXY!</div>
                    <div style="font-size: 24px; opacity: 0.9; margin-bottom: 25px; color: #FFFFFF;">The Force of Business Analysis is strong with this one...</div>
                    <div style="font-size: 20px; opacity: 0.8; margin-bottom: 25px; color: #98FB98;">The Death Star of Technical Debt has been eliminated!</div>
                    <div style="font-size: 18px; opacity: 0.7; margin-bottom: 35px; color: #DDA0DD;">The Rebel Alliance celebrates another victory against the Empire of Legacy Systems!</div>
                    <div style="font-size: 16px; opacity: 0.6; margin-bottom: 40px; color: #F0E68C; font-style: italic;">"That's one small step for Business Analysis, one giant leap for Digital Transformation!"</div>
                    <button onclick="closeNurWars()" style="margin-top: 25px; background: rgba(255,215,0,0.3); border: 3px solid #FFD700; color: #FFD700; padding: 20px 40px; border-radius: 12px; font-family: 'Orbitron', serif; font-size: 22px; font-weight: bold; cursor: pointer; backdrop-filter: blur(15px); box-shadow: 0 0 25px rgba(255,215,0,0.6); transition: all 0.3s; text-transform: uppercase; letter-spacing: 2px;">
                        RETURN TO MISSION CONTROL
                    </button>
                `;
                
                // Add enhanced hover effect to button
                const button = battleHud.querySelector('button');
                button.addEventListener('mouseenter', () => {
                    button.style.transform = 'scale(1.15)';
                    button.style.boxShadow = '0 0 40px rgba(255,215,0,0.9)';
                    button.style.background = 'rgba(255,215,0,0.5)';
                });
                button.addEventListener('mouseleave', () => {
                    button.style.transform = 'scale(1)';
                    button.style.boxShadow = '0 0 25px rgba(255,215,0,0.6)';
                    button.style.background = 'rgba(255,215,0,0.3)';
                });
            }, 1500);
        }
        
        // Make functions global
        window.startNurWars = startNurWars;
        window.closeNurWars = closeNurWars;

        function closeSkyModal() {
            const skyDetails = document.getElementById('sky-details');
            skyDetails.style.display = 'none';
            
            if (isCenterView) {
                // Force reset when closing the sun modal
                isCenterView = false;
                focusedObject = null;
                controls.enableZoom = true;
                controls.maxDistance = 2000;
                controls.minDistance = 5;
                camera.fov = 60;
                camera.updateProjectionMatrix();
                undimBackground();
                updateMoonOrbitVisibility();
                viewHistory.length = 0;
                currentViewIndex = -1;
                updateBackButton();
                gsap.to(controls.target, { x: 0, y: 0, z: 0, duration: 0.8 });
                gsap.to(camera.position, { x: 0, y: 200, z: 800, duration: 0.8 });
                closeOverlay();
                return;
            } else if (focusedObject) {
                // Return to following the focused object closely
                const targetPos = new THREE.Vector3();
                focusedObject.getWorldPosition(targetPos);
                
                if (focusedObject.userData.isMoon) {
                    // For moons, return to parent planet
                    const parentPlanet = focusedObject.userData.parentPlanet;
                    if (parentPlanet) {
                        focusedObject = parentPlanet; // Switch focus to parent
                        parentPlanet.getWorldPosition(targetPos);
                        
                        // Update moon orbit visibility when returning to parent planet
                        updateMoonOrbitVisibility();
                        
                        // Dim background when returning to parent planet
                        dimBackground(parentPlanet);
                        
                        const dist = (parentPlanet.userData.size || 5) * 3 + 15;
                        const currentDir = camera.position.clone().sub(targetPos).normalize();
                        const newPos = targetPos.clone().add(currentDir.multiplyScalar(dist));
                        
                        gsap.to(camera.position, { x: newPos.x, y: newPos.y, z: newPos.z, duration: 1.0 });
                        controls.target.copy(targetPos);
                    }
                } else {
                    // For planets, return to close following position
                    controls.target.copy(targetPos);
                    
                    if (focusedObject.userData.isPlanet) {
                        // Ensure background is dimmed when returning to planet
                        dimBackground(focusedObject);
                        
                        const dist = (focusedObject.userData.size || 5) * 3 + 15;
                        const currentDir = camera.position.clone().sub(targetPos).normalize();
                        const newPos = targetPos.clone().add(currentDir.multiplyScalar(dist));
                        
                        gsap.to(camera.position, { x: newPos.x, y: newPos.y, z: newPos.z, duration: 1.0 });
                    }
                }
            }
        }

        function resetView() {
            // Set flag to stop animation updates
            stopSuctionAnimation = true;
            
            // Kill all stored animation references
            if (activeSuctionAnimations.position) activeSuctionAnimations.position.kill();
            if (activeSuctionAnimations.scale) activeSuctionAnimations.scale.kill();
            if (activeSuctionAnimations.rotation) activeSuctionAnimations.rotation.kill();
            activeSuctionAnimations = {};
            
            // Re-enable controls
            controls.enabled = true;
            
            if (isCenterView) {
                isCenterView = false;
                controls.enableZoom = true;
                controls.maxDistance = 2000;
                controls.minDistance = 5;
                camera.fov = 60;
                camera.updateProjectionMatrix();
            }
            
            if (solarSystem && solarSystem.userData && solarSystem.userData.isSucked) {
                // Restore solar system immediately
                solarSystem.userData.isSucked = false;
                solarSystem.visible = true;
                solarSystem.position.set(0, 0, 0);
                solarSystem.scale.set(1, 1, 1);
                solarSystem.rotation.set(0, 0, 0);
                
                // Restore UI
                const uiLayer = document.getElementById('ui-layer');
                if (uiLayer) uiLayer.style.display = 'flex';
                const blackHoleOverlay = document.getElementById('blackhole-overlay');
                if (blackHoleOverlay) blackHoleOverlay.style.display = 'none';
                document.body.classList.remove('labels-hidden');
            }
            
            // Reset black hole
            if (blackHoleGroup) {
                blackHoleGroup.position.set(900, 260, -250);
                blackHoleGroup.scale.set(1, 1, 1);
                blackHoleGroup.rotation.set(0, 0, 0);
                blackHoleGroup.updateMatrix();
                blackHoleGroup.updateMatrixWorld(true);
            }
            
            focusedObject = null;
            undimBackground();
            updateMoonOrbitVisibility();
            viewHistory.length = 0;
            currentViewIndex = -1;
            updateBackButton();
            document.getElementById('sky-details').style.display = 'none';
            closeOverlay();
            
            // Animate camera back smoothly
            gsap.to(controls.target, { x: 0, y: 0, z: 0, duration: 1.0 });
            gsap.to(camera.position, { 
                x: 0, 
                y: 150, 
                z: 900, 
                duration: 1.0,
                onComplete: () => {
                    controls.enabled = true;
                }
            });
        }

        window.resetView = resetView;
        window.closeOverlay = closeOverlay;
        window.closeSkyModal = closeSkyModal;

        // small html-escape helper
        function escapeHtml(str) {
        	if (!str) return '';
        	return String(str)
        		.replace(/&/g, '&amp;')
        		.replace(/</g, '&lt;')
        		.replace(/>/g, '&gt;')
        		.replace(/"/g, '&quot;')
        		.replace(/'/g, '&#039;');
        }

        window.addEventListener('wheel', (e) => {
            if (isCenterView) {
                // Telescope zoom (FOV)
                let newFov = camera.fov + (e.deltaY * 0.05);
                newFov = Math.max(10, Math.min(60, newFov));
                camera.fov = newFov;
                camera.updateProjectionMatrix();
            }
        });

        // Keyboard navigation
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' || e.key === 'Backspace') {
                e.preventDefault();
                
                // Close modals first if open
                const skyDetails = document.getElementById('sky-details');
                const overlayPanel = document.getElementById('overlay-panel');
                
                if (skyDetails.style.display !== 'none') {
                    closeSkyModal();
                } else if (overlayPanel.classList.contains('active')) {
                    closeOverlay();
                } else {
                    // Try to go back to previous view
                    const wentBack = goToPreviousView();
                    if (!wentBack) {
                        // No previous view, just unselect and undim
                        focusedObject = null;
                        undimBackground();
                    }
                }
            }
        });

        // Prevent scrolling in modals from triggering zoom
        ['sky-content', 'overlay-panel'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('wheel', e => e.stopPropagation());
                el.addEventListener('click', e => e.stopPropagation());
                el.addEventListener('mousedown', e => e.stopPropagation());
            }
        });

        // === ANIMATION LOOP ===
        const clock = new THREE.Clock();

        function spawnComet() {
            // Create comet nucleus (brighter and more realistic)
            const nucleusGeo = new THREE.SphereGeometry(2, 12, 12);
            const nucleusMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffcc,
                transparent: true,
                opacity: 0.9
            });
            const nucleus = new THREE.Mesh(nucleusGeo, nucleusMat);
            
            // Create comet coma (glowing atmosphere around nucleus)
            const comaGeo = new THREE.SphereGeometry(4, 16, 16);
            const comaMat = new THREE.MeshBasicMaterial({ 
                color: 0xaaddff,
                transparent: true,
                opacity: 0.3
            });
            const coma = new THREE.Mesh(comaGeo, comaMat);
            
            // Group nucleus and coma together
            const cometGroup = new THREE.Group();
            cometGroup.add(nucleus);
            cometGroup.add(coma);
            
            // Random starting position (further out for more dramatic effect)
            const x = (Math.random() - 0.5) * 1200;
            const y = (Math.random() - 0.5) * 600;
            const z = (Math.random() - 0.5) * 1200;
            cometGroup.position.set(x, y, z);
            
            // Target closer to center for more visible trajectory
            const targetX = (Math.random() - 0.5) * 300;
            const targetY = (Math.random() - 0.5) * 150;
            const targetZ = (Math.random() - 0.5) * 300;
            const velocity = new THREE.Vector3(targetX - x, targetY - y, targetZ - z).normalize().multiplyScalar(4);
            
            scene.add(cometGroup);
            
            // Create trail system for this comet
            const trailPositions = [];
            const maxTrailLength = 80; // Longer trail
            
            comets.push({ 
                mesh: cometGroup, 
                nucleus: nucleus,
                coma: coma,
                velocity, 
                life: 600, // Longer life
                trailPositions: trailPositions,
                maxTrailLength: maxTrailLength,
                trailMeshes: [] // Store trail segment meshes
            });
            
            playSound('comet');
        }

        function fireLasers(ship) {
            const pos = new THREE.Vector3();
            ship.getWorldPosition(pos);
            const quat = new THREE.Quaternion();
            ship.getWorldQuaternion(quat);
            
            const laserGeo = new THREE.CylinderGeometry(0.2, 0.2, 10, 8);
            laserGeo.rotateX(Math.PI / 2);
            const laserMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            
            const l1 = new THREE.Mesh(laserGeo, laserMat);
            const l2 = new THREE.Mesh(laserGeo, laserMat);
            
            const offset = new THREE.Vector3(2, 0, 0).applyQuaternion(quat);
            l1.position.copy(pos).add(offset);
            l1.quaternion.copy(quat);
            l2.position.copy(pos).sub(offset);
            l2.quaternion.copy(quat);
            
            scene.add(l1);
            scene.add(l2);
            
            const velocity = new THREE.Vector3(0, 0, 10).applyQuaternion(quat);
            lasers.push({ mesh: l1, velocity, life: 100 });
            lasers.push({ mesh: l2, velocity, life: 100 });
            playSound('laser');
        }

        function animate() {
            requestAnimationFrame(animate);

            // Handle Nur Wars Battle Rendering
            if (nurWarsActive && renderMode === 'battle') {
                updateBattleLogic();
                webGLRenderer.render(nurWarsScene, camera);
                return; // Skip normal rendering
            }

            // Continue rendering main scene during NUR WARS opening crawl for starfield
            const time = Date.now() * 0.001;
            
            // Add subtle parallax movement to starfields during NUR WARS for depth perception
            if (nurWarsActive) {
                starMesh.rotation.y += 0.0001;
                starMesh.rotation.x += 0.00005;
                if (window.upperStarMesh) {
                    upperStarMesh.rotation.y -= 0.00015; // Opposite direction for depth
                    upperStarMesh.rotation.x -= 0.00008;
                }
            }
            
            // Clean sun animation - no corona layers
            sun.rotation.y += 0.001; // Rotate sun counterclockwise (same as planets)
            
            // Animate sun glow
            if (sun.userData.glowMaterial) {
                sun.userData.glowMaterial.uniforms.time.value = time;
            }
            
            // Animate sun lights for pulsing bright effect
            if (sunCoreLight) {
                sunCoreLight.intensity = 8 + Math.sin(time * 4) * 1.5; // More dramatic pulsing
            }
            if (sunBrightLight) {
                sunBrightLight.intensity = 6 + Math.sin(time * 3) * 1;
            }
            if (sunWarmLight) {
                sunWarmLight.intensity = 4 + Math.sin(time * 2) * 0.5;
            }
            if (sunAmbientLight) {
                sunAmbientLight.intensity = 2 + Math.sin(time * 1.5) * 0.3;
            }
            
            // Move entire solar system slightly (Drift)
            if (!solarSystem.userData.isSucked) {
                solarSystem.position.x = Math.sin(time * 0.1) * 20;
                solarSystem.position.z = Math.cos(time * 0.15) * 20;
                solarSystem.position.y = Math.sin(time * 0.05) * 5;
                solarSystem.rotation.y = Math.sin(time * 0.02) * 0.05; // Slight system rotation
            }

            // Rotate orbits and planets
            objects.forEach(obj => {
                if (obj.type === 'orbit') {
                    if (timelineActive && (obj.isExperiencePlanet || obj.isExperienceMoon)) {
                        return;
                    }
                    obj.mesh.rotation.y += obj.speed;
                } else if (obj.type === 'ellipticalOrbit') {
                    if (timelineActive && obj.pivot.children[0].children.some(c => c.userData.name === 'Experience')) return;
                    
                    obj.theta += obj.speed;
                    obj.pivot.rotation.y = obj.theta;
                    const r = (obj.a * (1 - obj.e * obj.e)) / (1 + obj.e * Math.cos(obj.theta));
                    obj.radial.position.x = r;
                } else if (obj.type === 'rotate') {
                    obj.mesh.rotation.y += obj.speed;
                }
            });

            // Comets with realistic trails
            if (Math.random() < 0.003) spawnComet(); // Slightly less frequent for better performance
            
            for (let i = comets.length - 1; i >= 0; i--) {
                const c = comets[i];
                
                // Store current position for trail
                c.trailPositions.push(c.mesh.position.clone());
                
                // Limit trail length
                if (c.trailPositions.length > c.maxTrailLength) {
                    c.trailPositions.shift();
                }
                
                // Move comet
                c.mesh.position.add(c.velocity);
                
                // Animate nucleus and coma
                c.nucleus.rotation.x += 0.02;
                c.nucleus.rotation.y += 0.01;
                c.coma.rotation.x -= 0.01;
                c.coma.rotation.y += 0.015;
                
                // Create/update trail geometry
                if (c.trailPositions.length > 2) {
                    // Remove old trail meshes
                    c.trailMeshes.forEach(trailMesh => {
                        scene.remove(trailMesh);
                        if (trailMesh.geometry) trailMesh.geometry.dispose();
                        if (trailMesh.material) trailMesh.material.dispose();
                    });
                    c.trailMeshes = [];
                    
                    // Create new trail segments
                    for (let j = 1; j < c.trailPositions.length; j++) {
                        const segmentGeo = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            c.trailPositions[j-1].x, c.trailPositions[j-1].y, c.trailPositions[j-1].z,
                            c.trailPositions[j].x, c.trailPositions[j].y, c.trailPositions[j].z
                        ]);
                        segmentGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        // Trail opacity decreases towards the back
                        const opacity = (j / c.trailPositions.length) * 0.8;
                        const segmentMat = new THREE.LineBasicMaterial({ 
                            color: 0xaaddff,
                            transparent: true,
                            opacity: opacity,
                            linewidth: 2
                        });
                        
                        const trailSegment = new THREE.Line(segmentGeo, segmentMat);
                        scene.add(trailSegment);
                        c.trailMeshes.push(trailSegment);
                    }
                }
                
                // Create glowing particles along the trail (less frequent for performance)
                if (c.life % 4 === 0 && c.trailPositions.length > 5) {
                    // Create particles at random positions along the trail
                    const randomIndex = Math.floor(Math.random() * Math.min(c.trailPositions.length, 20));
                    const trailPos = c.trailPositions[c.trailPositions.length - 1 - randomIndex];
                    
                    if (trailPos) {
                        const pGeo = new THREE.BufferGeometry();
                        // Add some randomness to particle position
                        const px = trailPos.x + (Math.random() - 0.5) * 3;
                        const py = trailPos.y + (Math.random() - 0.5) * 3;
                        const pz = trailPos.z + (Math.random() - 0.5) * 3;
                        
                        pGeo.setAttribute('position', new THREE.Float32BufferAttribute([px, py, pz], 3));
                        const pMat = new THREE.PointsMaterial({ 
                            color: Math.random() > 0.5 ? 0xffffcc : 0xaaddff,
                            size: Math.random() * 2 + 1,
                            transparent: true,
                            opacity: 0.8
                        });
                        const p = new THREE.Points(pGeo, pMat);
                        scene.add(p);
                        cometParticles.push({ mesh: p, life: 120 }); // Longer particle life
                    }
                }
                
                // Fade out comet as it ages
                const fadeStart = c.life < 150;
                if (fadeStart) {
                    const fadeOpacity = c.life / 150;
                    c.nucleus.material.opacity = fadeOpacity * 0.9;
                    c.coma.material.opacity = fadeOpacity * 0.3;
                }

                c.life--;
                if (c.life <= 0) {
                    // Clean up trail meshes
                    c.trailMeshes.forEach(trailMesh => {
                        scene.remove(trailMesh);
                        if (trailMesh.geometry) trailMesh.geometry.dispose();
                        if (trailMesh.material) trailMesh.material.dispose();
                    });
                    
                    scene.remove(c.mesh);
                    comets.splice(i, 1);
                }
            }

            // Comet Particles (enhanced with longer trails)
            for (let i = cometParticles.length - 1; i >= 0; i--) {
                const p = cometParticles[i];
                p.life--;
                
                if (p.mesh.material) {
                    // Smoother fade out over longer period
                    p.mesh.material.opacity = (p.life / 120) * 0.8;
                    
                    // Slight size reduction as particle ages
                    if (p.mesh.material.size) {
                        p.mesh.material.size = Math.max(0.2, (p.life / 120) * p.mesh.material.size);
                    }
                }
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    if (p.mesh.geometry) p.mesh.geometry.dispose();
                    if (p.mesh.material) p.mesh.material.dispose();
                    cometParticles.splice(i, 1);
                }
            }

            // Lasers
            for (let i = lasers.length - 1; i >= 0; i--) {
                const l = lasers[i];
                l.mesh.position.add(l.velocity);
                l.life--;
                if (l.life <= 0) {
                    scene.remove(l.mesh);
                    lasers.splice(i, 1);
                }
            }

            // Update labels to position above objects
            labels.forEach(item => {
                const pos = new THREE.Vector3();
                item.object.getWorldPosition(pos);

                // Hide Moon labels when zoomed out
                if (item.object.userData.isMoon) {
                    if (camera.position.distanceTo(pos) > 85) {
                        item.div.style.display = 'none';
                        return;
                    }
                }

                // Hide labels of background moons when dimmed (they're too faint to be useful)
                if (backgroundDimming && item.object.userData.isMoon && 
                    focusedObject && item.object.userData.parentPlanet !== focusedObject) {
                    item.div.style.display = 'none';
                    return;
                }

                // Position label above the object with appropriate spacing
                const objectRadius = item.object.geometry ? item.object.geometry.parameters.radius : 50;
                let labelOffset;
                
                // Adjust label positioning based on focus state
                const isFocusedPlanetSystem = focusedObject && 
                    (item.object === focusedObject || 
                     (item.object.userData.isMoon && item.object.userData.parentPlanet === focusedObject));
                
                if (item.object.userData.isMoon) {
                    if (isFocusedPlanetSystem) {
                        // Moons of focused planet: very close to moon surface
                        labelOffset = new THREE.Vector3(0, objectRadius + 3, 0);
                    } else {
                        // Moons of other planets: further away (but they'll be dimmed anyway)
                        labelOffset = new THREE.Vector3(0, objectRadius + 8, 0);
                    }
                } else if (item.object.userData.isSun) {
                    // Sun: higher above for visibility
                    labelOffset = new THREE.Vector3(0, objectRadius + 30, 0);
                } else {
                    // Planets
                    if (isFocusedPlanetSystem) {
                        // Focused planet: closer label
                        labelOffset = new THREE.Vector3(0, objectRadius + 8, 0);
                    } else {
                        // Other planets: standard spacing
                        labelOffset = new THREE.Vector3(0, objectRadius + 15, 0);
                    }
                }
                
                pos.add(labelOffset);
                pos.project(camera);
                
                const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (pos.y * -0.5 + 0.5) * window.innerHeight;
                
                // Hide Sun label if camera is inside/very close to Sun
                if ((item.object.userData.isSun || item.object.userData.viewType === 'center') && camera.position.distanceTo(item.object.position) < 5) {
                    item.div.style.display = 'none';
                    return;
                }

                if (pos.z > 1) {
                    item.div.style.display = 'none';
                } else {
                    item.div.style.display = 'block';
                    item.div.style.left = `${x}px`;
                    item.div.style.top = `${y}px`;
                }
            });

            if (revealLabelsOnNextFrame) {
                document.body.classList.remove('labels-hidden');
                revealLabelsOnNextFrame = false;
            }

            // Continuous object following
            if (focusedObject && !isCenterView) {
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                const targetPos = new THREE.Vector3();
                focusedObject.getWorldPosition(targetPos);
                
                // Smoothly follow the object as it moves through its orbit
                controls.target.lerp(targetPos, 0.05); // Smooth following with lerp
                
                // Optionally maintain camera distance relative to the object
                if (focusedObject.userData.isPlanet) {
                    const desiredDistance = (focusedObject.userData.size || 5) * 3 + 15;
                    const currentDistance = camera.position.distanceTo(targetPos);
                    
                    // Only adjust if we're too far or too close
                    if (Math.abs(currentDistance - desiredDistance) > 5) {
                        const direction = camera.position.clone().sub(targetPos).normalize();
                        const newPos = targetPos.clone().add(direction.multiplyScalar(desiredDistance));
                        camera.position.lerp(newPos, 0.02); // Gentle distance correction
                    }
                }
            } else if (!focusedObject && !isCenterView && !solarSystem.userData.isSucked) {
                // Allow normal controls - user can freely explore
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
            } else if (!isDragging) {
                // Re-enable damping when dragging is done
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
            }

            controls.update();
            webGLRenderer.render(scene, camera);
        }

        // === RESIZE ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            if (nurWarsCamera) {
                nurWarsCamera.aspect = window.innerWidth / window.innerHeight;
                nurWarsCamera.updateProjectionMatrix();
            }
            webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // === INITIALIZATION ===
        setTimeout(() => {
            document.getElementById('loading').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                animate();
            }, 1000);
        }, 1000);
        
        }
    </script>
</body>
</html>
